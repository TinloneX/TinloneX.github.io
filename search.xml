<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Jetpack之生命周期感知组件-Lifecycle使用篇</title>
    <url>/2021/02/25/Jetpack%E4%B9%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%84%9F%E7%9F%A5%E7%BB%84%E4%BB%B6-Lifecycle%E4%BD%BF%E7%94%A8%E7%AF%87/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>什么是生命周期感知组件？</p>
<blockquote>
<p>生命周期感知型组件可执行操作来响应另一个组件（如 Activity 和 Fragment）的生命周期状态的变化。这些组件有助于您写出更有条理且往往更精简的代码，这样的代码更易于维护。</p>
</blockquote>
<p>Lifecycle是什么？</p>
<blockquote>
<p>Lifecycle 是一个类，用于存储有关组件（如 Activity 或 Fragment）的生命周期状态的信息，并允许其他对象观察此状态。</p>
</blockquote>
<p>它所解决的痛点问题是什么？</p>
<blockquote>
<p>在 Android 框架中定义的大多数应用组件都存在生命周期。生命周期由操作系统或进程中运行的框架代码管理。它们是 Android 工作原理的核心，应用必须遵循它们。如果不这样做，可能会引发内存泄漏甚至应用崩溃。</p>
</blockquote>
<p><a href="https://github.com/TinloneX/ArchitecturalComponentExample">【本系列文章(JAVA/KOTLIN)演示案例均存储在github存储库ArchitecturalComponentExample中】</a></p>
<a id="more"></a>

<h3 id="使用Lifecycle的意义"><a href="#使用Lifecycle的意义" class="headerlink" title="使用Lifecycle的意义"></a>使用Lifecycle的意义</h3><p>说起Activity生命周期，不难想到Application有个方法<code>registerActivityLifecycleCallbacks()</code>可以注册生命周期回调, 且在<code>Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q</code>时的Activity也扩展了这个方法，获取activity生命周期状态：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">registerActivityLifecycleCallbacks(new Application.ActivityLifecycleCallbacks() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onActivityCreated(@NonNull Activity activity, @Nullable Bundle bundle) &#123;</span><br><span class="line">        Log.i(&quot;loglog&quot;, &quot;onActivityCreated&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onActivityStarted(@NonNull Activity activity) &#123;</span><br><span class="line">        Log.i(&quot;loglog&quot;, &quot;onActivityStarted&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onActivityResumed(@NonNull Activity activity) &#123;</span><br><span class="line">        Log.i(&quot;loglog&quot;, &quot;onActivityResumed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onActivityPaused(@NonNull Activity activity) &#123;</span><br><span class="line">        Log.i(&quot;loglog&quot;, &quot;onActivityPaused&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onActivityStopped(@NonNull Activity activity) &#123;</span><br><span class="line">        Log.i(&quot;loglog&quot;, &quot;onActivityStopped&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onActivitySaveInstanceState(@NonNull Activity activity, @NonNull Bundle bundle) &#123;</span><br><span class="line">        Log.i(&quot;loglog&quot;, &quot;onActivitySaveInstanceState&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onActivityDestroyed(@NonNull Activity activity) &#123;</span><br><span class="line">        Log.i(&quot;loglog&quot;, &quot;onActivityDestroyed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>同样的，我们也可以在Activity中单纯使用生命周期回调<code>onCreate()</code>、<code>onResume()</code>等来实现生命周期监听。</p>
<p><a href="https://developer.android.google.cn/topic/libraries/architecture/lifecycle">具体案例参考官方文档</a></p>
<p>我们不难发现这样写存在这样一些问题：</p>
<ul>
<li>生命周期管理集中，且并非所有生命周期回调我们都要用</li>
<li>若同一生命周期回调中要做多个功能，同一个回调方法中代码量将会很大，这将带来巨大的维护成本</li>
<li>无法保证组件会在 Activity 或 Fragment 停止之前启动。在我们需要执行长时间运行的操作（如 onStart() 中的某种配置检查）时尤其如此。这可能会导致出现一种竞态条件，在这种条件下，onStop() 方法会在 onStart() 之前结束，这使得组件留存的时间比所需的时间要长。</li>
</ul>
<p>Lifecycle 可以为你的每一个功能提供独立的生命周期观察者，做到功能代码与界面（Activity/Fragment）更小的耦合，且每一个功能的生命周期观察者都可以被复用，功能组件的抽离也能为你的程序带来更强大的扩展性。</p>
<h3 id="使用Lifecycle"><a href="#使用Lifecycle" class="headerlink" title="使用Lifecycle"></a>使用Lifecycle</h3><h4 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h4><p>文档编写时，稳定依赖版本为<code>2.2.0</code> ，下一候选预览版为<code>2.3.0-rc01</code>，引入时请检查官方文档推荐版本，以当前稳定版为主要选择。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    def lifecycle_version &#x3D; &quot;2.3.0&quot;</span><br><span class="line">    def arch_version &#x3D; &quot;2.1.0&quot;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ViewModel支持</span><br><span class="line">    implementation &quot;androidx.lifecycle:lifecycle-viewmodel:$lifecycle_version&quot;</span><br><span class="line">    &#x2F;&#x2F; LiveData支持</span><br><span class="line">    implementation &quot;androidx.lifecycle:lifecycle-livedata:$lifecycle_version&quot;</span><br><span class="line">    &#x2F;&#x2F; 仅Lifecycles (不包括 ViewModel 和 LiveData支持)</span><br><span class="line">    implementation &quot;androidx.lifecycle:lifecycle-runtime:$lifecycle_version&quot;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 保存ViewModel的状态模块</span><br><span class="line">    implementation &quot;androidx.lifecycle:lifecycle-viewmodel-savedstate:$lifecycle_version&quot;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 注解处理器</span><br><span class="line">    annotationProcessor &quot;androidx.lifecycle:lifecycle-compiler:$lifecycle_version&quot;</span><br><span class="line">    &#x2F;&#x2F; 另外——如果使用Java8，使用下面的代码代替lifecycle-compiler</span><br><span class="line">    implementation &quot;androidx.lifecycle:lifecycle-common-java8:$lifecycle_version&quot;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 可选——在服务中实现LifecycleOwner的助手</span><br><span class="line">    implementation &quot;androidx.lifecycle:lifecycle-service:$lifecycle_version&quot;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 可选- ProcessLifecycleOwner为整个应用程序过程提供一个生命周期</span><br><span class="line">    implementation &quot;androidx.lifecycle:lifecycle-process:$lifecycle_version&quot;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 可选- ReactiveStreams支持LiveData</span><br><span class="line">    implementation &quot;androidx.lifecycle:lifecycle-reactivestreams:$lifecycle_version&quot;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 可选的- LiveData的测试助手</span><br><span class="line">    testImplementation &quot;androidx.arch.core:core-testing:$arch_version&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上依赖库并非所有内容均需要引入，请根据实际需求引入对应依赖。</p>
<p>例如，你单纯的想使用Lifecycle的生命周期管理能力，你可以这样引入依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    def lifecycle_version &#x3D; &quot;2.3.0&quot;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 单纯生命周期组件</span><br><span class="line">    implementation &quot;androidx.lifecycle:lifecycle-runtime:$lifecycle_version&quot;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 负责进程(应用)的生命周期</span><br><span class="line">    implementation &#39;androidx.lifecycle:lifecycle-process:$lifecycle_version&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="LifecycleObserver"><a href="#LifecycleObserver" class="headerlink" title="LifecycleObserver"></a>LifecycleObserver</h4><p>编写你的LifecycleObserver 观察者，并将其添加到界面组件的LifecycleOwner观察队列（集合）中<br>，即可完成对界面组件生命周期的观察，你可以在你的LifecycleObserver 定义你感兴趣的生命周期事件，例如你需要控制相机在亮/息屏时开启或停止，你可以这样做：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CameraLifecycleObserver</span> <span class="keyword">implements</span> <span class="title">LifecycleObserver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_CREATE)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initCamera</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Log.i(<span class="string">&quot;loglog&quot;</span>, <span class="string">&quot;ON_CREATE 初始化相机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_RESUME)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openCamera</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.i(<span class="string">&quot;loglog&quot;</span>, <span class="string">&quot;ON_RESUME 打开相机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_PAUSE)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeCamera</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.i(<span class="string">&quot;loglog&quot;</span>, <span class="string">&quot;ON_PAUSE 关闭相机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_DESTROY)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Log.i(<span class="string">&quot;loglog&quot;</span>, <span class="string">&quot;ON_DESTROY 销毁资源&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，若你还想利用其他生命周期，或者主动获取组件的生命周期，你或可以将生命周期组件传入CameraLifecycleObserver组件中，通过其获取当前生命周期：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CameraLifecycleObserver</span> <span class="keyword">implements</span> <span class="title">LifecycleObserver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lifecycle mLifecycle = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 当然，此处也可以传递 LifecycleOwner 以及其他类型参数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CameraLifecycleObserver</span><span class="params">(Lifecycle lifecycle)</span></span>&#123;</span><br><span class="line">        mLifecycle = lifecycle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 你应当在合适的时机调用方法体中的两个API，而并非一定要在 ON_ANY 的时刻调用</span></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_ANY)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAny</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前状态</span></span><br><span class="line">        Lifecycle.State currentState = mLifecycle.getCurrentState();</span><br><span class="line">        <span class="comment">// 至少已经执行onStart了</span></span><br><span class="line">        <span class="keyword">boolean</span> hasStarted = currentState.isAtLeast(Lifecycle.State.STARTED);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="组件实现LifecycleOwner"><a href="#组件实现LifecycleOwner" class="headerlink" title="组件实现LifecycleOwner"></a>组件实现LifecycleOwner</h4><p>完成了观察者的编写，我们可以将观察者的实例传递给LifecycleOwner，而关于Lifecycleowner你可能存在以下两种情况：</p>
<ul>
<li>你使用了Androidx支持库，且版本 <code>>=26.1.0</code>, Fragment 和 Activity 已实现 LifecycleOwner 接口，此处主要指继承自<code>ComponentActivity</code>及其子类的Activity和继承自<code>androidx.fragment.app.Fragment</code>的Fragment。</li>
<li>其他情况，你需要自行实现LifecycleOwner ，并重写<code>getLifecycle()</code>方法，并手动分发你需要的生命周期：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">LifecycleOwner</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LifecycleRegistry lifecycleRegistry;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    </span><br><span class="line">        lifecycleRegistry = <span class="keyword">new</span> LifecycleRegistry(<span class="keyword">this</span>);</span><br><span class="line">        lifecycleRegistry.markState(Lifecycle.State.CREATED);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">        lifecycleRegistry.markState(Lifecycle.State.STARTED);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Lifecycle <span class="title">getLifecycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lifecycleRegistry;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="将观察者交给LifecycleOwner"><a href="#将观察者交给LifecycleOwner" class="headerlink" title="将观察者交给LifecycleOwner"></a>将观察者交给LifecycleOwner</h4><p>当你拥有LifecycleOwner对象后，你就可以将你实现的观察者LifecycleObserver 交给它了，当有生命周期变化事件发生，LifecycleObserver将会通知你的LifecycleOwner。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getLifecycle().addObserver(<span class="keyword">new</span> CameraLifecycleObserver(...params));</span><br></pre></td></tr></table></figure>
<p>让我们来看一下其执行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">I&#x2F;loglog: ON_CREATE 初始化相机</span><br><span class="line">I&#x2F;loglog: onActivityStarted</span><br><span class="line">I&#x2F;loglog: onActivityResumed</span><br><span class="line">I&#x2F;loglog: ON_RESUME 打开相机</span><br><span class="line">I&#x2F;loglog: ON_PAUSE 关闭相机</span><br><span class="line">I&#x2F;loglog: onActivityPaused</span><br><span class="line">I&#x2F;loglog: onActivityStopped</span><br><span class="line">I&#x2F;loglog: ON_DESTROY 销毁资源</span><br><span class="line">I&#x2F;loglog: onActivityDestroyed</span><br></pre></td></tr></table></figure>
<h3 id="为进程添加生命周期事件"><a href="#为进程添加生命周期事件" class="headerlink" title="为进程添加生命周期事件"></a>为进程添加生命周期事件</h3><p>如果你想监听应用前后台变化，你可以看下此小节。<br>以往的，观察应用是否前台，你可以这样做：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">inAppOnForeground</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ActivityManager activityManager = (ActivityManager) context.getSystemService(ACTIVITY_SERVICE);</span><br><span class="line">        String packageName = context.getPackageName();</span><br><span class="line">        <span class="keyword">if</span> (activityManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">            List&lt;ActivityManager.RunningAppProcessInfo&gt; appProcesses = activityManager.getRunningAppProcesses();</span><br><span class="line">            <span class="keyword">if</span> (appProcesses == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (ActivityManager.RunningAppProcessInfo appProcess : appProcesses) &#123;</span><br><span class="line">                <span class="keyword">if</span> (packageName.equals(appProcess.processName)</span><br><span class="line">                        &amp;&amp; appProcess.importance == ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样你只能知道应用是否前台，但无法知道它什么时候进入前台，什么时候进入后台，如果你恰好需要知道应用何时进入后台执行某项工作，这样做可能并不适合。当然你也可以通过Application.registerActivityLifecycleCallbacks()监听activity的启动和退出，为其启动和退出计数，当退出时计数为0则可视作应用后台，当启动时计数为1则可视做应用前台，emmmm，想想我就觉得工作量挺大~</p>
<p>让我们看看使用Lifecycle如何简单做到这件事情吧（需引入依赖androidx.lifecycle:lifecycle-process:$last_version）：</p>
<ul>
<li>编写生命周期观察者</li>
<li>为你的Application添加生命周期观察者</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessLifecycleObserver</span> <span class="keyword">implements</span> <span class="title">LifecycleObserver</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 标记前后台状态的一种方案</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isForeground = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_START)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onForeground</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.i(<span class="string">&quot;loglog&quot;</span>, <span class="string">&quot;onForeground: ON_START&quot;</span>);</span><br><span class="line">        isForeground = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent(Lifecycle.Event.ON_STOP)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBackground</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.i(<span class="string">&quot;loglog&quot;</span>, <span class="string">&quot;onBackground: ON_STOP&quot;</span>);</span><br><span class="line">        isForeground = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取前后台状态的一种方案</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isForeground</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isForeground;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ProcessLifecycleObserver observer;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line"></span><br><span class="line">        observer = <span class="keyword">new</span> ProcessLifecycleObserver();</span><br><span class="line">        ProcessLifecycleOwner.get().getLifecycle().addObserver(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取前后台状态的一种方案</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isForeground</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> observer.isForeground();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就简单的完成了应用前后台切换的监听，以及前后台状态的查询了~</p>
<h3 id="生命周期感知型组件的最佳做法"><a href="#生命周期感知型组件的最佳做法" class="headerlink" title="生命周期感知型组件的最佳做法"></a><a href="https://developer.android.google.cn/topic/libraries/architecture/lifecycle#lc-bp">生命周期感知型组件的最佳做法</a></h3><p>如需了解生命周期感知组建的最佳做法，请点击 <a href="https://developer.android.google.cn/topic/libraries/architecture/lifecycle#lc-bp">官方文档</a> 获得详细内容</p>
<p>关于Lifecycle 与LiveData等jetpack组件配合使用，将在架构组件基础使用系列完结后一并编写介绍，在此之前，请参考<a href="https://developer.android.google.cn/topic/libraries/architecture/lifecycle">官方文档</a> </p>
]]></content>
      <categories>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>Lifecycle</tag>
      </tags>
  </entry>
  <entry>
    <title>WorkManager基本使用及源码分析(三) - SystemAlarmService</title>
    <url>/2021/02/06/WorkManager%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%B8%89)%20-%20SystemAlarmService/</url>
    <content><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="#part_source">源码篇</a><ul>
<li><a href="#SystemAlarmService">2.1.1 SystemAlarmService</a><ul>
<li><a href="#processCommand">如何处置命令 (processCommand)</a></li>
<li><a href="#CommandHandler">如何分发命令 (CommandHandler)</a><ul>
<li><a href="#startWork">是怎么调用到Worker.doWork()的？</a></li>
</ul>
</li>
<li><a href="#DequeueAndCheckForCompletion">如何完成回调 (DequeueAndCheckForCompletion)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="源码篇"><a href="#源码篇" class="headerlink" title=" 源码篇"></a><span id="part_source"> 源码篇</h3><p>上一篇中我们了解了WorkManager使用的的主要组件，猜测了各个组件的作用，并简单介绍了WorkManager是如何初始化的。本篇将延续前文，介绍WorkManager中Service组件之一的SystemAlarmService。</p>
<p><strong><span id="SystemAlarmService"> SystemAlarmService</strong></p>
<blockquote>
<p>Service invoked by {@link android.app.AlarmManager} to run work tasks.</p>
</blockquote>
<p>服务将被AlarmManager调用来执行工作任务.</p>
<a id="more"></a>

<p>注: 此节中凡 描述中的 <strong>“命令”</strong> 及 <strong>“intent”</strong> 均指代包括 <strong>[规划任务、重新规划任务、约束条件改变、执行完毕、延时执行、停止执行…]</strong> 的事件，可视作状态模式。</p>
<p><strong><span id="processCommand"> 如何处置命令 (processCommand)</strong></p>
<p>SystemAlarmService 主要逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemAlarmService</span> <span class="keyword">extends</span> <span class="title">LifecycleService</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">SystemAlarmDispatcher</span>.<span class="title">CommandsCompletedListener</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">        <span class="comment">// onCreate时执行initializeDispatcher()初始化并绑定闹钟事件调度器</span></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStartCommand(intent, flags, startId);</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">        <span class="comment">// 添加调度事件,若当前无任务则立即调度</span></span><br><span class="line">        <span class="keyword">if</span> (intent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mDispatcher.add(intent, startId);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果服务崩溃，我们希望所有未确认的意图都得到重新交付。</span></span><br><span class="line">        <span class="keyword">return</span> Service.START_REDELIVER_INTENT;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到, 此服务在创建时初始化并绑定闹钟事件调度器,当服务被start时,若有intent事件,则将intent传递给调度器. 调度器收到intent后执行以下操作:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(<span class="meta">@NonNull</span> <span class="keyword">final</span> Intent intent, <span class="keyword">final</span> <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">    assertMainThread();</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="comment">// 保证命令列表安全,只进或只出</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mIntents) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> hasCommands = !mIntents.isEmpty();</span><br><span class="line">        mIntents.add(intent);</span><br><span class="line">        <span class="keyword">if</span> (!hasCommands) &#123;</span><br><span class="line">            <span class="comment">// 如果是第一个命令则执行</span></span><br><span class="line">            <span class="comment">// 一般情况下,若上一个命令执行完毕会被移除</span></span><br><span class="line">            processCommand();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当闹钟调度器收到新命令,会将新命令放入命令集合，若新命令为集合中第一个命令则直接进入执行命令逻辑中，否则不处理，前一命令执行完毕后再次调用执行命令：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processCommand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    mWorkManager.getWorkTaskExecutor().executeOnBackgroundThread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">     <span class="keyword">try</span> &#123;   </span><br><span class="line">        <span class="comment">// 若当前命令不为空，则将命令交给状态机执行</span></span><br><span class="line">        mCommandHandler.onHandleIntent(mCurrentIntent, startId, SystemAlarmDispatcher.<span class="keyword">this</span>);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;&#125;</span><br><span class="line">     <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 当前命令执行完毕，回调SystemAlarmDispatcher处理命令集以及后续操作</span></span><br><span class="line">        postOnMainThread( <span class="keyword">new</span> DequeueAndCheckForCompletion(SystemAlarmDispatcher.<span class="keyword">this</span>));</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当<code>processCommand</code>被调用，将开启新的线程处理命令，主要干了两件事：</p>
<ul>
<li>将命令交给CommandHandler分发[规划任务、重新规划任务、约束条件改变、执行完毕…]事件</li>
<li>将事件处理完毕回调到闹钟事件调度器，由调度器处理后续事宜。</li>
</ul>
<p>我们来依次跟进这两件事：</p>
<p><strong><span id="CommandHandler"> CommandHandler如何分发命令</strong></p>
<p>我们前面看到<code>processCommand</code>中调用<code>CommandHandler</code>分发命令，其代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WorkerThread</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onHandleIntent</span><span class="params">(<span class="meta">@NonNull</span> Intent intent,<span class="keyword">int</span> startId, <span class="meta">@NonNull</span> SystemAlarmDispatcher dispatcher)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String action = intent.getAction();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ACTION_CONSTRAINTS_CHANGED.equals(action)) &#123;</span><br><span class="line">        <span class="comment">// 约束条件改变</span></span><br><span class="line">        handleConstraintsChanged(intent, startId, dispatcher);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ACTION_RESCHEDULE.equals(action)) &#123;</span><br><span class="line">        <span class="comment">// 异常中断，需重新规划</span></span><br><span class="line">        handleReschedule(intent, startId, dispatcher);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Bundle extras = intent.getExtras();</span><br><span class="line">        <span class="keyword">if</span> (!hasKeys(extras, KEY_WORKSPEC_ID)) &#123;</span><br><span class="line">            <span class="comment">// log error</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ACTION_SCHEDULE_WORK.equals(action)) &#123;</span><br><span class="line">                <span class="comment">// 规划任务</span></span><br><span class="line">                handleScheduleWorkIntent(intent, startId, dispatcher);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ACTION_DELAY_MET.equals(action)) &#123;</span><br><span class="line">                <span class="comment">// 时延到点</span></span><br><span class="line">                handleDelayMet(intent, startId, dispatcher);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ACTION_STOP_WORK.equals(action)) &#123;</span><br><span class="line">                <span class="comment">// 取消任务</span></span><br><span class="line">                handleStopWork(intent, dispatcher);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ACTION_EXECUTION_COMPLETED.equals(action)) &#123;</span><br><span class="line">                <span class="comment">// 完成任务</span></span><br><span class="line">                handleExecutionCompleted(intent, startId);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// log error</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到这里主要依据命令(intent)的action执行命令分发操作，此处我们主要关注<code>handleDelayMet</code> 时延结束后，处理任务的主线：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleDelayMet</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@NonNull</span> Intent intent,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> startId,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@NonNull</span> SystemAlarmDispatcher dispatcher)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Bundle extras = intent.getExtras();</span><br><span class="line">    <span class="comment">// 保证任务处理线程安全</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        String workSpecId = extras.getString(KEY_WORKSPEC_ID);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check to see if we are already handling an ACTION_DELAY_MET for the WorkSpec.</span></span><br><span class="line">        <span class="comment">// If we are, then there is nothing for us to do.</span></span><br><span class="line">        <span class="comment">// 检查该任务是否已经在即将执行队伍(map)中，如果是则不再重复操作</span></span><br><span class="line">        <span class="keyword">if</span> (!mPendingDelayMet.containsKey(workSpecId)) &#123;</span><br><span class="line">            DelayMetCommandHandler delayMetCommandHandler = <span class="keyword">new</span> DelayMetCommandHandler(mContext, startId, workSpecId, dispatcher);</span><br><span class="line">            <span class="comment">// 将任务放入即将执行队伍(map)中</span></span><br><span class="line">            mPendingDelayMet.put(workSpecId, delayMetCommandHandler);</span><br><span class="line">            <span class="comment">// 处理任务</span></span><br><span class="line">            delayMetCommandHandler.handleProcessWork();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// log error</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，<code>CommandHandler</code>中维护了一个 mPendingDelayMet的Map来保证单次任务不被多次处理，若命令未被处理过，则将其加入到队伍中，然后调用<code>delayMetCommandHandler.handleProcessWork()</code>去处理任务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WorkerThread</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleProcessWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建WakeLocks</span></span><br><span class="line">    mWakeLock = WakeLocks.newWakeLock(...);</span><br><span class="line">    <span class="comment">// 获取WorkSpec</span></span><br><span class="line">    WorkSpec workSpec = mDispatcher.getWorkManager().getWorkDatabase().workSpecDao().getWorkSpec(mWorkSpecId);</span><br><span class="line">    <span class="comment">// 处理通常不会发生的情况 - 未获取到WorkSpec。</span></span><br><span class="line">    <span class="comment">// 取消工作应该删除alarm，但是如果alarm已经触发，那么就触发一个stop work请求来删除挂起的delay met命令处理程序。</span></span><br><span class="line">    <span class="keyword">if</span> (workSpec == <span class="keyword">null</span>) &#123;</span><br><span class="line">        stopWork();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 跟踪工作任务是否有约束</span></span><br><span class="line">    mHasConstraints = workSpec.hasConstraints();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mHasConstraints) &#123;</span><br><span class="line">        <span class="comment">// 若无约束</span></span><br><span class="line">        onAllConstraintsMet(Collections.singletonList(mWorkSpecId));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 允许跟踪器报告约束更改</span></span><br><span class="line">        <span class="comment">// 此处可见，我们可以将时延视作一种特殊的约束</span></span><br><span class="line">        mWorkConstraintsTracker.replace(Collections.singletonList(workSpec));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里判断了任务状态及约束状态，依据约束状态执行任务或更新任务状态，<br>执行任务时：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onAllConstraintsMet(@NonNull List&lt;String&gt; workSpecIds) &#123;</span><br><span class="line">    &#x2F;&#x2F; 保证任务正确    </span><br><span class="line">    if (!workSpecIds.contains(mWorkSpecId)) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 保证执行安全</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        if (mCurrentState &#x3D;&#x3D; STATE_INITIAL) &#123;</span><br><span class="line">            &#x2F;&#x2F; 更改状态</span><br><span class="line">            mCurrentState &#x3D; STATE_START_REQUESTED;</span><br><span class="line">            &#x2F;&#x2F; startWork &#x3D;&gt; doWork</span><br><span class="line">            &#x2F;&#x2F;这里没有使用WorkManagerImpl#startWork()，因为我们需要知道处理器是否在这里将工作排队</span><br><span class="line">            boolean isEnqueued &#x3D; mDispatcher.getProcessor().startWork(mWorkSpecId);</span><br><span class="line">            &#x2F;&#x2F; 若任务状态是轮询</span><br><span class="line">            if (isEnqueued) &#123;</span><br><span class="line">               &#x2F;&#x2F; 设置计时器以强制已进入队列的任务配额</span><br><span class="line">                mDispatcher.getWorkTimer()</span><br><span class="line">                        .startTimer(mWorkSpecId, WORK_PROCESSING_TIME_IN_MS, this);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; 执行完毕或取消，则清除状态</span><br><span class="line">                cleanUp();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Logger.get().debug(TAG, String.format(&quot;Already started work for %s&quot;, mWorkSpecId));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里最终改变任务状态并调用<code>Processor.startWork()</code>执行任务，我们将关注<code>Processor.startWork()</code>，这个方法最终执行到我们定义的Worker中<code>doWork()</code>方法，并且前面说到的WorkManager中负责任务执行的Service们最终都会调用到<code>Processor.startWork()</code>。</p>
<p>由于内容流程较长且属于公共流程，关于<code>Processor.startWork()</code>将单独整理未一小节，<a href="https://tinlone.com/2021/02/06/WorkManager%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%BA%94)%20-%20Processor/">点击此处查看</a>。</p>
<p><strong><span id="DequeueAndCheckForCompletion"> DequeueAndCheckForCompletion如何完成回调</strong></p>
<p><code>DequeueAndCheckForCompletion</code> 是一个Runnable对象，<code>postOnMainThread</code>时调用run：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mDispatcher.dequeueAndCheckForCompletion();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终回调到<code>dequeueAndCheckForCompletion</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void dequeueAndCheckForCompletion() &#123;</span><br><span class="line">   &#x2F;&#x2F; 保证mIntents命令集只进或只出</span><br><span class="line">    synchronized (mIntents) &#123;</span><br><span class="line">        if (mCurrentIntent !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 从命令集中移除已完成（第一个）命令</span><br><span class="line">            if (!mIntents.remove(0).equals(mCurrentIntent)) &#123;</span><br><span class="line">                throw new IllegalStateException(&quot;something&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            mCurrentIntent &#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line">        SerialExecutor serialExecutor &#x3D; mTaskExecutor.getBackgroundExecutor();</span><br><span class="line">        &#x2F;&#x2F; 若无预计执行和待执行命令，则通知SystemAlarmService执行完毕</span><br><span class="line">        if (!mCommandHandler.hasPendingCommands()</span><br><span class="line">                &amp;&amp; mIntents.isEmpty()</span><br><span class="line">                &amp;&amp; !serialExecutor.hasPendingTasks()) &#123;</span><br><span class="line">            if (mCompletedListener !&#x3D; null) &#123;</span><br><span class="line">                mCompletedListener.onAllCommandsCompleted();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (!mIntents.isEmpty()) &#123;</span><br><span class="line">           &#x2F;&#x2F; 若命令集中还有未执行的命令，则继续执行</span><br><span class="line">            processCommand();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，若当前命令存在，则从命令集中移除当前命令。若无预计执行和待执行命令，则调用<code>mCompletedListener.onAllCommandsCompleted()</code>通知SystemAlarmService执行完毕；若命令集合中还有未执行命令，则调用<code>processCommand()</code>继续执行。</p>
<p>而<code>SystemAlarmService.onAllCommandsCompleted()</code>最终会执行<code>stopSelf()</code>停止服务</p>
<p>假装下面是时序图：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SystemAlarmService.java</span><br><span class="line">|- initializeDispatcher(); <span class="comment">// 初始化并绑定闹钟调度器</span></span><br><span class="line">|- SystemAlarmService.onStartCommand()  <span class="comment">// 通过startService添加命令</span></span><br><span class="line">    |- SystemAlarmDispatcher.add()				<span class="comment">// 委托调度器添加命令</span></span><br><span class="line">        |- mIntents.add(intent);    <span class="comment">// 添加命令进入命令集</span></span><br><span class="line">        |- SystemAlarmDispatcher.processCommand()			<span class="comment">// 若是第一个则,执行命令, 若不是第一个,将在后续流程中继续执行</span></span><br><span class="line">            |- <span class="keyword">try</span> CommandHandler.onHandleIntent()</span><br><span class="line">                |- ACTION_CONSTRAINTS_CHANGED</span><br><span class="line">                |- ...</span><br><span class="line">                |- ACTION_DELAY_MET</span><br><span class="line">                    |- delayMetCommandHandler.handleProcessWork()</span><br><span class="line">                        |- onAllConstraintsMet()</span><br><span class="line">                            |- mDispatcher.getProcessor().startWork()</span><br><span class="line">            |- <span class="function"><span class="keyword">finally</span> <span class="title">postOnMainThread</span><span class="params">( new DequeueAndCheckForCompletion(SystemAlarmDispatcher.<span class="keyword">this</span>)</span>)<span class="comment">// 分发完成命令事件</span></span></span><br><span class="line"><span class="function">				|- SystemAlarmDispatcher.<span class="title">dequeueAndCheckForCompletion</span><span class="params">()</span>  <span class="comment">// 回调</span></span></span><br><span class="line"><span class="function">					|- mIntents.<span class="title">remove</span><span class="params">(<span class="number">0</span>)</span></span>;					   <span class="comment">// 从命令集移出(当前)第一个命令</span></span><br><span class="line">					|- CommandsCompletedListener.onAllCommandsCompleted() </span><br><span class="line">					    OR SystemAlarmDispatcher.processCommand()  <span class="comment">// 命令集执行完毕 或 执行下一个命令</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>WorkManager</tag>
      </tags>
  </entry>
  <entry>
    <title>WorkManager基本使用及源码分析(二) - WorkManagerInitializer</title>
    <url>/2021/02/06/WorkManager%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%BA%8C)%20-%20WorkManagerInitializer/</url>
    <content><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="#part_source">源码篇</a><ul>
<li><a href="#AndroidManifest">2.1 AndroidManifest</a><ul>
<li><a href="#WorkManagerInitializer">2.1.1 WorkManagerInitializer</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="源码篇"><a href="#源码篇" class="headerlink" title=" 源码篇"></a><span id="part_source"> 源码篇</h3><p>上一篇中我们简单使用了WorkManager的一般功能，基础使用还是比较简单的。<strong>“WorkManager 是一个 API，可供您轻松调度那些即使在退出应用或重启设备后仍应运行的可延期异步任务”</strong>。那么我们来了解一下他到底是怎么工作的吧。</p>
<a id="more"></a>

<h4 id="2-1-AndroidManifest"><a href="#2-1-AndroidManifest" class="headerlink" title=" 2.1 AndroidManifest"></a><span id="AndroidManifest"> 2.1 AndroidManifest</h4><p>秉承看三方库源码的一般习惯，先从AndroidManifest.xml文件看起，我们知道一般的，想要了解一个库的主要组成就要想了解一个App一样首先要了解它有哪些组件构成，而<strong>库的AndroidManifest文件一般都会合并至应用AndroidManifest.xml中</strong>，且一般的需要初始化的库，常规的初始化方案是<strong>使用ContentProvider尽早地初始化且减少代码侵入</strong>，对这种方式不了解的，请参见<a href="https://blog.csdn.net/a1018875550/article/details/102760643">Android-使用ContentProvider来初始化你的sdk</a>系列文章。</p>
<p>废话不多说，让我们来看看work-runtime库的AndroidManifest.xml有哪些玄机。</p>
<p>work-runtime库的AndroidManifest.xml我们可以在AndroidStudio的 <strong>Project窗口中External Libraries</strong>栏目中查找”work-runtime”即可看到WorkManager的aar包结构和内容。打开AndroidManefest.xml我们发现以下重要组件：</p>
<ul>
<li><strong><provider></strong> <code>androidx.work.impl.WorkManagerInitializer</code></li>
<li><strong><service></strong> <code>androidx.work.impl.background.systemalarm.SystemAlarmService</code></li>
<li><strong><service></strong> <code>androidx.work.impl.background.systemjob.SystemJobService</code></li>
<li><strong><service></strong> <code>androidx.work.impl.foreground.SystemForegroundService</code></li>
<li><strong><receiver></strong> <code>androidx.work.impl.utils.ForceStopRunnable$BroadcastReceiver</code></li>
<li><strong><receiver></strong> <code>androidx.work.impl.background.systemalarm.ConstraintProxy$BatteryChargingProxy</code></li>
<li><strong><receiver></strong> <code>androidx.work.impl.background.systemalarm.ConstraintProxy$BatteryNotLowProxy</code></li>
<li><strong><receiver></strong> <code>androidx.work.impl.background.systemalarm.ConstraintProxy$StorageNotLowProxy</code></li>
<li><strong><receiver></strong> <code>androidx.work.impl.background.systemalarm.ConstraintProxy$NetworkStateProxy</code></li>
<li><strong><receiver></strong> <code>androidx.work.impl.background.systemalarm.RescheduleReceiver</code></li>
<li><strong><receiver></strong> <code>androidx.work.impl.background.systemalarm.ConstraintProxyUpdateReceiver</code></li>
<li><strong><receiver></strong> <code>androidx.work.impl.diagnostics.DiagnosticsReceiver</code></li>
</ul>
<p>我们可以大胆猜测： <em>WorkManager使用ContentProvider <code>WorkManagerInitializer</code>执行初始化操作, 通过Service管理任务执行及状态，通过BroadcastReceiver掌握任务执行时机和条件。</em></p>
<p><strong><span id="WorkManagerInitializer"> WorkManagerInitializer</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The &#123;<span class="doctag">@link</span> ContentProvider&#125; responsible for initializing &#123;<span class="doctag">@link</span> WorkManagerImpl&#125;.</span></span><br><span class="line"><span class="comment"> * // 机翻：负责初始化&#123;<span class="doctag">@link</span> WorkManagerImpl&#125;的&#123;<span class="doctag">@link</span> ContentProvider&#125;。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@hide</span>  // 隐藏API，对调用者不可见</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkManagerInitializer</span> <span class="keyword">extends</span> <span class="title">ContentProvider</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Initialize WorkManager with the default configuration.</span></span><br><span class="line">        <span class="comment">// 机翻：使用默认配置初始化WorkManager。</span></span><br><span class="line">        WorkManager.initialize(getContext(), <span class="keyword">new</span> Configuration.Builder().build());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... 省略其他无关代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>WorkManager.initialize -&gt; WorkManagerImpl.initialize</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &#123;@link WorkManagerImpl#initialize&#125;</span></span><br><span class="line"><span class="meta">@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(<span class="meta">@NonNull</span> Context context, <span class="meta">@NonNull</span> Configuration configuration)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (sLock) &#123;</span><br><span class="line">     <span class="comment">// ... 重复创建检查，若被多次调用此创建方法则抛错WorkManager is already initialized.</span></span><br><span class="line">        <span class="keyword">if</span> (sDelegatedInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            context = context.getApplicationContext();</span><br><span class="line">            <span class="keyword">if</span> (sDefaultInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                sDefaultInstance = <span class="keyword">new</span> WorkManagerImpl(</span><br><span class="line">                        context, configuration,</span><br><span class="line">                        <span class="keyword">new</span> WorkManagerTaskExecutor(configuration.getTaskExecutor()));</span><br><span class="line">            &#125;</span><br><span class="line">            sDelegatedInstance = sDefaultInstance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中<code>configuration.getTaskExecutor()</code>最终调用方法为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="meta">@NonNull</span> <span class="function">Executor <span class="title">createDefaultExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Executors.newFixedThreadPool(</span><br><span class="line">            <span class="comment">// This value is the same as the core pool size for AsyncTask#THREAD_POOL_EXECUTOR.</span></span><br><span class="line">            <span class="comment">// 机翻：这个值与AsyncTask#THREAD_POOL_EXECUTOR的核心池大小相同。</span></span><br><span class="line">            Math.max(<span class="number">2</span>, Math.min(Runtime.getRuntime().availableProcessors() - <span class="number">1</span>, <span class="number">4</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>备注：一般地，AsyncTask里线程池核心线程数为CPU + 1，最大线程数为CPU * 2 + 1</p>
<p>纵观代码，我们发现WorkManagerInitializer就是一个负责初始化WorkManager的ContentProvider，职责单一，简单明了。<br><code>WorkManager.initialize()</code>最终使用ContentProvider上下文对象context、默认configuration及线程池容量与AsyncTask核心线程数一致的Executor创建了WorkManagerImpl单例实例。</p>
]]></content>
      <categories>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>WorkManager</tag>
      </tags>
  </entry>
  <entry>
    <title>WorkManager基本使用及源码分析(五) - Processor</title>
    <url>/2021/02/06/WorkManager%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%BA%94)%20-%20Processor/</url>
    <content><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="#part_source">源码篇</a><ul>
<li><a href="#Processor">Processor</a></li>
</ul>
</li>
</ul>
<hr>
<h3 id="源码篇"><a href="#源码篇" class="headerlink" title=" 源码篇"></a><span id="part_source"> 源码篇</h3><p>前面从work-runtime库的AndroidManifest.xml中了解到，WorkManager工作主要通过ContentProvider、Service、BroadcastReceiver协同工作，而关注几个主要Service工作流程发现，最终都会执行到<code>Processor.startWork()</code>方法，此篇将重点关注<code>Processor.startWork()</code>是何方神圣。</p>
<a id="more"></a>
<p>首先我们简单过一下<code> mWorkManagerImpl.getProcessor().startWork(mWorkSpecId, mRuntimeExtras)</code>的代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean startWork(@NonNull String id,  @Nullable WorkerParameters.RuntimeExtras runtimeExtras) &#123;</span><br><span class="line">    WorkerWrapper workWrapper;</span><br><span class="line">    &#x2F;&#x2F; 保证任务队列(MAP)只进或只出</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        &#x2F;&#x2F; doing 验证id不在队列中</span><br><span class="line">        &#x2F;&#x2F; 初始化WorkerWrapper</span><br><span class="line">        workWrapper &#x3D; new WorkerWrapper.Builder(...).build();</span><br><span class="line">        ListenableFuture&lt;Boolean&gt; future &#x3D; workWrapper.getFuture();</span><br><span class="line">        &#x2F;&#x2F; 为执行结果添加监听，注意这里监听回调何时调用后面会说明</span><br><span class="line">        &#x2F;&#x2F; 特别注意：future.addListener中 FutureListener 是一个Runnable对象</span><br><span class="line">        &#x2F;&#x2F; 特别注意： FutureListener 是一个Runnable对象</span><br><span class="line">        future.addListener(</span><br><span class="line">                new FutureListener(this, id, future),</span><br><span class="line">                mWorkTaskExecutor.getMainThreadExecutor());</span><br><span class="line">        &#x2F;&#x2F; 将此任务加入队列</span><br><span class="line">        mEnqueuedWorkMap.put(id, workWrapper);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 使用工作线程执行任务</span><br><span class="line">    mWorkTaskExecutor.getBackgroundExecutor().execute(workWrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code> mWorkManagerImpl.getProcessor().startWork(mWorkSpecId, mRuntimeExtras)</code>主要做了三个操作：</p>
<ul>
<li>将任务要素封装为WorkerWrapper并为其执行期望添加监听</li>
<li>任务要素入队</li>
<li>工作线程执行处理任务</li>
</ul>
<p>相对主要的，我们继续跟进工作线程处理任务流程<code>execute(Runnable)</code>, excute将WorkerWrapper继续封装为Task并加入任务队列，若当前无活跃Task则安排任务执行，任务执行完毕后继续检查任务队列，直到任务队列空置为止：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="meta">@NonNull</span> Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 保证任务队列只进或只出</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="comment">// 封装任务并入队</span></span><br><span class="line">        mTasks.add(<span class="keyword">new</span> Task(<span class="keyword">this</span>, command));</span><br><span class="line">        <span class="comment">// 若无活跃任务，则尝试安排任务</span></span><br><span class="line">        <span class="keyword">if</span> (mActive == <span class="keyword">null</span>) &#123;</span><br><span class="line">            scheduleNext();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Synthetic access</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 保证任务队列只进或只出</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="comment">// 有任务且任务出队</span></span><br><span class="line">        <span class="keyword">if</span> ((mActive = mTasks.poll()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 执行任务</span></span><br><span class="line">            mExecutor.execute(mActive);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>mExecutor.execute(mActive)</code>会通过Task执行<code>execute(Runnable)</code>传入的Runnable，即执行<code>WorkerWrapper</code>（这里有点绕，可以多看两遍~），Task不论WorkerWrapper执行结果最终会继续轮询任务队列（此处不赘述）。此时，我们将目光移到<code>WorkerWrapper.run()</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@WorkerThread</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    mTags &#x3D; mWorkTagDao.getTagsForWorkSpecId(mWorkSpecId);</span><br><span class="line">    mWorkDescription &#x3D; createWorkDescription(mTags);</span><br><span class="line">    runWorker();</span><br><span class="line">&#125;</span><br><span class="line">private void runWorker() &#123;</span><br><span class="line">&#x2F;&#x2F; 各个状态判断最终调用到resolve(false);</span><br><span class="line">resolve(true); &#x2F;&#x2F; OR resolve(false);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 尝试将工作设置为运行状态。注意，这可能会失败，因为自从上次在这个函数的顶部检查之后，另一个线程可能已经修改了数据库。</span><br><span class="line">if (trySetRunning()) &#123;</span><br><span class="line">    if (tryCheckForInterruptionAndResolve()) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final SettableFuture&lt;ListenableWorker.Result&gt; future &#x3D; SettableFuture.create();</span><br><span class="line">    &#x2F;&#x2F; Call mWorker.startWork() on the main thread.</span><br><span class="line">    mWorkTaskExecutor.getMainThreadExecutor()</span><br><span class="line">            .execute(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        &#x2F;&#x2F; 调用Worker执行工作任务</span><br><span class="line">                        mInnerFuture &#x3D; mWorker.startWork();</span><br><span class="line">                        &#x2F;&#x2F; 将任务结果回调添加到期望回调中</span><br><span class="line">                        future.setFuture(mInnerFuture);</span><br><span class="line">                    &#125; catch (Throwable e) &#123;</span><br><span class="line">                        future.setException(e);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Avoid synthetic accessors.</span><br><span class="line">    final String workDescription &#x3D; mWorkDescription;</span><br><span class="line">    future.addListener(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        @SuppressLint(&quot;SyntheticAccessor&quot;)</span><br><span class="line">        public void run() &#123;</span><br><span class="line">           &#x2F;&#x2F; 最终调用到resolve(false);</span><br><span class="line">           resolve(false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, mWorkTaskExecutor.getBackgroundExecutor());</span><br><span class="line">&#125; else &#123;</span><br><span class="line">     &#x2F;&#x2F; 最终调用到resolve(false);</span><br><span class="line">     resolve(boolean);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void resolve(final boolean needsReschedule) &#123;</span><br><span class="line">    &#x2F;&#x2F; 数据库事务操作</span><br><span class="line">    </span><br><span class="line">    mFuture.set(needsReschedule);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>runWorker()</code> 中包含各种任务状态的判断，并尝试将任务置为运行状态，若设置运行状态成功，则调用<code>Worker.startWork()</code> 即最终会走向个人定义的Worker的<code>doWork()</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public final @NonNull ListenableFuture&lt;Result&gt; startWork() &#123;</span><br><span class="line">        mFuture &#x3D; SettableFuture.create();</span><br><span class="line">        getBackgroundExecutor().execute(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Result result &#x3D; doWork();</span><br><span class="line">                    mFuture.set(result);</span><br><span class="line">                &#125; catch (Throwable throwable) &#123;</span><br><span class="line">                    mFuture.setException(throwable);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        return mFuture;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>后续跟进<code>resolve</code>, 此方法除了数据库相关操作（更新Worker状态）外，最终会执行<code>mFuture.set(needsReschedule)</code>，即目标期望回调。</p>
<p>在跟进绕来绕去的<code>mFuture.set(needsReschedule)</code>之前，先回想一下，还记得<code>WorkManagerImpl.startWork</code>代码片段里的初始化代码段，future.addListener中 FutureListener 是一个Runnable对象，而addListener入参最终会被封装到<code>AbstractFuture.Listener</code>中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此处Runnable task实际为FutureListener</span></span><br><span class="line">Listener(Runnable task, Executor executor) &#123;</span><br><span class="line">    <span class="keyword">this</span>.task = task;</span><br><span class="line">    <span class="keyword">this</span>.executor = executor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>切回正题，继续跟进<code>mFuture.set(needsReschedule)</code>，此处set(boolean)最终会调用<code>AbstractFuture.set()</code>,继而调用<code>AbstractFuture.complete</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">set</span><span class="params">(<span class="meta">@Nullable</span> V value)</span> </span>&#123;</span><br><span class="line">    Object valueToSet = value == <span class="keyword">null</span> ? NULL : value;</span><br><span class="line">    <span class="keyword">if</span> (ATOMIC_HELPER.casValue(<span class="keyword">this</span>, <span class="keyword">null</span>, valueToSet)) &#123;</span><br><span class="line">        complete(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>AbstractFuture.complete</code>会遍历期望回调结合，找出其中代表执行结果回调的项并执行Runnable回调封装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void complete(AbstractFuture&lt;?&gt; future) &#123;</span><br><span class="line">	Listener next &#x3D; null;</span><br><span class="line">	outer:</span><br><span class="line">	while (true) &#123;</span><br><span class="line">		future.releaseWaiters();</span><br><span class="line">		future.afterDone();</span><br><span class="line">		next &#x3D; future.clearListeners(next);</span><br><span class="line">		future &#x3D; null;</span><br><span class="line">		while (next !&#x3D; null) &#123;</span><br><span class="line">			Listener curr &#x3D; next;</span><br><span class="line">			next &#x3D; next.next;</span><br><span class="line">			Runnable task &#x3D; curr.task;</span><br><span class="line">			if (task instanceof SetFuture) &#123;</span><br><span class="line">			    &#x2F;&#x2F; do something</span><br><span class="line">			    continue outer;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">			    &#x2F;&#x2F; 执行Runnable回调封装</span><br><span class="line">				executeListener(task, curr.executor);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		break;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里<code>executeListener(task, curr.executor)</code>中的task参数即在Processor中封装<code>WorkWrapper</code>时的<code>FutureListener</code>参数，即此处最终会执行<code>FutureListener.run()</code>方法，从而调用<code>mExecutionListener.onExecuted(mWorkSpecId, needsReschedule)</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureListener</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// something</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> needsReschedule;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            needsReschedule = mFuture.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            <span class="comment">// Should never really happen(?)</span></span><br><span class="line">            needsReschedule = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mExecutionListener.onExecuted(mWorkSpecId, needsReschedule);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们回想一下<code>Processor.startWork()</code>中关于设置futureListener的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">future.addListener(</span><br><span class="line">        <span class="keyword">new</span> FutureListener(<span class="keyword">this</span>, id, future),</span><br><span class="line">        mWorkTaskExecutor.getMainThreadExecutor());</span><br></pre></td></tr></table></figure>
<p>此处FutureListener中的第一个参数ExecutionListener是“this”，即会调用<code>ExecutionListener.onExecuted()</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onExecuted</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@NonNull</span> <span class="keyword">final</span> String workSpecId,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> needsReschedule)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        mEnqueuedWorkMap.remove(workSpecId);</span><br><span class="line">        <span class="comment">// mOuterListeners来自哪里，还记得本节SystemJobService最开始需要记住的addExecutionListener吗，没错，就是这里。</span></span><br><span class="line">        <span class="keyword">for</span> (ExecutionListener executionListener : mOuterListeners) &#123;</span><br><span class="line">            executionListener.onExecuted(workSpecId, needsReschedule);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们来看看<code>mOuterListeners</code>赋值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addExecutionListener</span><span class="params">(<span class="meta">@NonNull</span> ExecutionListener executionListener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        mOuterListeners.add(executionListener);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>嗨，跑了一圈，我们又回来了，即上面<code>onExecuted</code>中遍历执行的<code>executionListener.onExecuted(workSpecId, needsReschedule)</code>，<br>以SystemJobService为例，会调用<code>SystemJobService.onExecuted()</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onExecuted</span><span class="params">(<span class="meta">@NonNull</span> String workSpecId, <span class="keyword">boolean</span> needsReschedule)</span> </span>&#123;</span><br><span class="line">    Logger.get().debug(TAG, String.format(<span class="string">&quot;%s executed on JobScheduler&quot;</span>, workSpecId));</span><br><span class="line">    JobParameters parameters;</span><br><span class="line">    <span class="keyword">synchronized</span> (mJobParameters) &#123;</span><br><span class="line">        parameters = mJobParameters.remove(workSpecId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (parameters != <span class="keyword">null</span>) &#123;</span><br><span class="line">        jobFinished(parameters, needsReschedule);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，从XXXService调用SystemXXXService执行任务到最终任务结束及回调流程形成了一个完整的链。</p>
]]></content>
      <categories>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>WorkManager</tag>
      </tags>
  </entry>
  <entry>
    <title>WorkManager基本使用及源码分析(六) - SystemForegroundService</title>
    <url>/2021/02/06/WorkManager%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E5%85%AD)%20-%20SystemForegroundService/</url>
    <content><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="#part_source">源码篇</a><ul>
<li><a href="#SystemForegroundService">SystemForegroundService</a></li>
</ul>
</li>
</ul>
<hr>
<h3 id="源码篇"><a href="#源码篇" class="headerlink" title=" 源码篇"></a><span id="part_source"> 源码篇</h3><p>上一篇中我们了解了WorkManager使用的的主要组件，猜测了各个组件的作用，并简单介绍了WorkManager是如何初始化的。本篇将延续前文，介绍WorkManager中Service组件之一的SystemForegroundService。</p>
<p><strong><span id="SystemForegroundService"> SystemForegroundService</strong></p>
<p>在看过前面<code>SystemAlarmService & SystenJobService</code> 后，我本以为<br><code>SystemForegroundService</code>也如前者一般是处理任务执行的，但简单阅读代码后发现并非如此，尽管结构上与前者类似，但其主要作用是<strong>给运行任务的服务提权，保证其在前台执行</strong>。</p>
<a id="more"></a>

<p> <code>SystemAlarmService & SystenJobService</code>相似，<code>SystemForegroundService</code>也是<code>LifecycleService</code>的子类，主要方法有：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate();</span><br><span class="line">    sForegroundService = <span class="keyword">this</span>;</span><br><span class="line">    initializeDispatcher();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(<span class="meta">@Nullable</span> Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onStartCommand(intent, flags, startId);</span><br><span class="line">    <span class="comment">// 若正在被关闭，则</span></span><br><span class="line">    <span class="keyword">if</span> (mIsShutdown) &#123;</span><br><span class="line">        <span class="comment">// 结束旧    Dispatcher 的生命周期</span></span><br><span class="line">        mDispatcher.onDestroy();</span><br><span class="line">        <span class="comment">// 创建新的Dispatcher并设置新的生命周期</span></span><br><span class="line">        initializeDispatcher();</span><br><span class="line">        mIsShutdown = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (intent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 告诉Dispatcher 有活儿来了</span></span><br><span class="line">        mDispatcher.onStartCommand(intent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果服务崩溃，我们希望所有未确认的意图都得到重新交付。</span></span><br><span class="line">    <span class="keyword">return</span> Service.START_REDELIVER_INTENT;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initializeDispatcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mHandler = <span class="keyword">new</span> Handler(Looper.getMainLooper());</span><br><span class="line">    mNotificationManager = (NotificationManager)</span><br><span class="line">            getApplicationContext().getSystemService(Context.NOTIFICATION_SERVICE);</span><br><span class="line">    mDispatcher = <span class="keyword">new</span> SystemForegroundDispatcher(getApplicationContext());</span><br><span class="line">    mDispatcher.setCallback(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化时创建新的SystemForegroundDispatcher绑定并设置新的生命周期，当收到指令被启动时，调用<code>SystemForegroundDispatcher.onStartCommand()</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SystemForegroundDispatcher#onStartCommand</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onStartCommand</span><span class="params">(<span class="meta">@NonNull</span> Intent intent)</span> </span>&#123;</span><br><span class="line">    String action = intent.getAction();</span><br><span class="line">    <span class="keyword">if</span> (ACTION_START_FOREGROUND.equals(action)) &#123;</span><br><span class="line">        handleStartForeground(intent);</span><br><span class="line">        <span class="comment">// 调用handleNotify()，它反过来调用start前台()作为处理这个命令的一部分。这对一些原始设备制造商来说很重要。</span></span><br><span class="line">        handleNotify(intent);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ACTION_NOTIFY.equals(action)) &#123;</span><br><span class="line">        handleNotify(intent);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ACTION_CANCEL_WORK.equals(action)) &#123;</span><br><span class="line">        handleCancelWork(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当intent (<em>此处intent可视作前面提到的SystemXXXService的意图</em>) 状态处于启动、更新状态时会调用<code>handleNotify(intent)</code>，取消时会调用<code>handleCancelWork(intent)</code>,<br>状态为取消时，则最终会调用<code>mWorkManagerImpl.cancelWorkById(UUID.fromString(workSpecId))</code>取消任务执行。</p>
<p>我们再来看看handleNotify干了哪些事情吧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SystemForegroundDispatcher#handleNotify</span></span><br><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleNotify</span><span class="params">(<span class="meta">@NonNull</span> Intent intent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> notificationId = intent.getIntExtra(KEY_NOTIFICATION_ID, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> notificationType = intent.getIntExtra(KEY_FOREGROUND_SERVICE_TYPE, <span class="number">0</span>);</span><br><span class="line">    String workSpecId = intent.getStringExtra(KEY_WORKSPEC_ID);</span><br><span class="line">    Notification notification = intent.getParcelableExtra(KEY_NOTIFICATION);</span><br><span class="line">    <span class="keyword">if</span> (notification != <span class="keyword">null</span> &amp;&amp; mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ForegroundInfo info = <span class="keyword">new</span> ForegroundInfo(</span><br><span class="line">                notificationId, notification, notificationType);</span><br><span class="line">        <span class="comment">// 缓存信息</span></span><br><span class="line">        mForegroundInfoById.put(workSpecId, info);</span><br><span class="line">        <span class="keyword">if</span> (TextUtils.isEmpty(mCurrentForegroundWorkSpecId)) &#123;</span><br><span class="line">            <span class="comment">// 这是拥有前台生命周期的当前workSpecId.</span></span><br><span class="line">            mCurrentForegroundWorkSpecId = workSpecId;</span><br><span class="line">            mCallback.startForeground(notificationId, notificationType, notification);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 更新通知</span></span><br><span class="line">            mCallback.notify(notificationId, notification);</span><br><span class="line">            <span class="comment">// 如有必要，更新前台的通知，使其成为当前所有前台服务类型的联合。</span></span><br><span class="line">            <span class="keyword">if</span> (notificationType != FOREGROUND_SERVICE_TYPE_NONE</span><br><span class="line">                    &amp;&amp; Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q) &#123;</span><br><span class="line">                <span class="keyword">int</span> foregroundServiceType = FOREGROUND_SERVICE_TYPE_NONE;</span><br><span class="line">                <span class="keyword">for</span> (Map.Entry&lt;String, ForegroundInfo&gt; entry : mForegroundInfoById.entrySet()) &#123;</span><br><span class="line">                    ForegroundInfo foregroundInfo = entry.getValue();</span><br><span class="line">                    foregroundServiceType |= foregroundInfo.getForegroundServiceType();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//缓存中取出信息</span></span><br><span class="line">                ForegroundInfo currentInfo = mForegroundInfoById.get(mCurrentForegroundWorkSpecId);</span><br><span class="line">                <span class="keyword">if</span> (currentInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mCallback.startForeground(</span><br><span class="line">                            currentInfo.getNotificationId(),</span><br><span class="line">                            foregroundServiceType,</span><br><span class="line">                            currentInfo.getNotification()</span><br><span class="line">                    );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若当前服务intent是首个，那么就启动<code>SystemForegroundService.startForeground()</code>做周期性递归，而<code>SystemForegroundService.startForeground()</code>实际上是一个空方法，类似于使用了<code>Looper</code>保证<code>SystemForegroundService</code>一直运行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; SystemForegroundService#startForeground</span><br><span class="line">@Override</span><br><span class="line">public void startForeground(</span><br><span class="line">        final int notificationId,</span><br><span class="line">        final int notificationType,</span><br><span class="line">        @NonNull final Notification notification) &#123;</span><br><span class="line"></span><br><span class="line">    mHandler.post(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            if (Build.VERSION.SDK_INT &gt;&#x3D; Build.VERSION_CODES.Q) &#123;</span><br><span class="line">                startForeground(notificationId, notification, notificationType);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                startForeground(notificationId, notification);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若当前服务intent不是首个，则更新一则通知，并合并前台服务类型，<code>mCallback.notify(notificationId, notification)</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SystemForegroundService#notify</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> notificationId, <span class="meta">@NonNull</span> <span class="keyword">final</span> Notification notification)</span> </span>&#123;</span><br><span class="line">    mHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            mNotificationManager.notify(notificationId, notification);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><code>SystemForegroundService</code>会在任务启动时启动，且会创建一个类似于<code>Looper</code>的结构保持服务前台持续运行，后续有任务触发时，会发送notification以保证其执行任务的服务可被视作前台服务保持运行。</p>
]]></content>
      <categories>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>WorkManager</tag>
      </tags>
  </entry>
  <entry>
    <title>WorkManager基本使用及源码分析(四) - SystemJobService</title>
    <url>/2021/02/06/WorkManager%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E5%9B%9B)%20-%20SystemJobService/</url>
    <content><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="#part_source">源码篇</a><ul>
<li><a href="#SystemJobService">SystemJobService</a></li>
</ul>
</li>
</ul>
<hr>
<h3 id="源码篇"><a href="#源码篇" class="headerlink" title=" 源码篇"></a><span id="part_source"> 源码篇</h3><p>上一篇中我们简单使用了WorkManager的一般功能，基础使用还是比较简单的。<strong>“WorkManager 是一个 API，可供您轻松调度那些即使在退出应用或重启设备后仍应运行的可延期异步任务”</strong>。那么我们来了解一下他到底是怎么工作的吧。</p>
<p><strong><span id="SystemJobService"> SystemJobService</strong></p>
<blockquote>
<p>Service invoked by {@link android.app.job.JobScheduler} to run work tasks.</p>
</blockquote>
<p>服务将被JobScheduler调用来执行工作任务。<br>从描述可得<code>SystemJobService</code>与<code>SystemAlarmService</code>职责是一致的，都是“run work tasks”。</p>
<a id="more"></a>

<p>类似地，我们可以猜测<code>SystemJobService</code>执行流程始于<code>onStartJob</code>终于<code>onStopJob</code>。</p>
<p><code>SystemJobService.onCreate()</code>获取了<code>WorkManagerImpl</code>实例并将执行监听绑定到（任务）处理器Processor：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 还记得WorkManagerImpl是哪里初始化的吗？</span><br><span class="line">mWorkManagerImpl &#x3D; WorkManagerImpl.getInstance(getApplicationContext());</span><br><span class="line">&#x2F;&#x2F; 记住此处addExecutionListener</span><br><span class="line">&#x2F;&#x2F; 记住此处addExecutionListener</span><br><span class="line">&#x2F;&#x2F; 记住此处addExecutionListener</span><br><span class="line">mWorkManagerImpl.getProcessor().addExecutionListener(this);</span><br></pre></td></tr></table></figure>
<p>当SystemJobService被调用时会执行<code>SystemJobService.onStartJob()</code>，此时会将JobParameters以workId为Key存入工作Map中，并初始化<code>WorkerParameters.RuntimeExtras</code>, 最终调用<code>mWorkManagerImpl.startWork(workSpecId, runtimeExtras)</code>执行任务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onStartJob</span><span class="params">(<span class="meta">@NonNull</span> JobParameters params)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// WorkManagerImpl NonNull</span></span><br><span class="line">    String workSpecId = getWorkSpecIdFromJobParameters(params);</span><br><span class="line">    <span class="comment">// workSpecId NonNull</span></span><br><span class="line">    <span class="comment">// 保证mJobParameters 工作参数集只进或只出</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mJobParameters) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mJobParameters.containsKey(workSpecId)) &#123;</span><br><span class="line">           <span class="comment">// log</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 存入工作参数</span></span><br><span class="line">        mJobParameters.put(workSpecId, params);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化WorkerParameters.RuntimeExtras</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// WorkManagerImpl执行任务</span></span><br><span class="line">    mWorkManagerImpl.startWork(workSpecId, runtimeExtras);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>WorkManagerImpl.startWork</code>后续会执行<code> mWorkManagerImpl.getProcessor().startWork(mWorkSpecId, mRuntimeExtras)</code>。</p>
<p>由于内容流程较长且属于公共流程，关于<code>Processor.startWork()</code>将单独整理未一小节，<a href="./WorkManager%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%BA%94)+-+Processor.md">点击此处查看</a>。</p>
<p>由<code>Processor.startWork()</code>中代码可知，流程末尾<code>onExecuted</code>中遍历执行的<code>executionListener.onExecuted(workSpecId, needsReschedule)</code>会调用<code>SystemJobService.onExecuted()</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onExecuted</span><span class="params">(<span class="meta">@NonNull</span> String workSpecId, <span class="keyword">boolean</span> needsReschedule)</span> </span>&#123;</span><br><span class="line">    Logger.get().debug(TAG, String.format(<span class="string">&quot;%s executed on JobScheduler&quot;</span>, workSpecId));</span><br><span class="line">    JobParameters parameters;</span><br><span class="line">    <span class="keyword">synchronized</span> (mJobParameters) &#123;</span><br><span class="line">        parameters = mJobParameters.remove(workSpecId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (parameters != <span class="keyword">null</span>) &#123;</span><br><span class="line">        jobFinished(parameters, needsReschedule);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，根据JobService的生命周期，我们可以认定，最后会调用<code>SystemJobService.onStopJob()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onStopJob</span><span class="params">(<span class="meta">@NonNull</span> JobParameters params)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mWorkManagerImpl == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String workSpecId = getWorkSpecIdFromJobParameters(params);</span><br><span class="line">    <span class="keyword">if</span> (TextUtils.isEmpty(workSpecId)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// mJobParameters数据安全</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mJobParameters) &#123;</span><br><span class="line">        <span class="comment">// 移出任务参数队列（Map）</span></span><br><span class="line">        mJobParameters.remove(workSpecId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 结束此任务</span></span><br><span class="line">    mWorkManagerImpl.stopWork(workSpecId);</span><br><span class="line">    <span class="keyword">return</span> !mWorkManagerImpl.getProcessor().isCancelled(workSpecId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，从JobService调用SystemJobService执行任务到最终任务结束流程形成了一个完整的链。</p>
]]></content>
      <categories>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>WorkManager</tag>
      </tags>
  </entry>
  <entry>
    <title>Jetpack之应用启动组件-StartUp</title>
    <url>/2021/02/24/Jetpack%E4%B9%8B%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E7%BB%84%E4%BB%B6-StartUp/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>应用程序启动库<code>StartUp</code>提供了一种在应用程序启动时初始化组件的简单、高效的方法。库开发者和应用开发者都可以使用app Startup来简化启动序列，并显式设置初始化顺序。</p>
</blockquote>
<blockquote>
<p>不同于为每个需要初始化的组件定义单独的内容提供程序，App Startup允许你定义共享单个内容提供程序的组件初始化程序。这可以显著提高应用程序的启动时间。</p>
</blockquote>
<p>此组件主要解决的痛点问题是：简化各个外部引用SDK初始化操作，并优化SDK初始化时机，在确保启动速度的情况下以更优更稳定的方式按需初始化SDK（当然，也可以利用它的按需按序执行的功能来初始化某些类）。</p>
<p><a href="https://github.com/TinloneX/ArchitecturalComponentExample">【本系列文章演示案例均存储在github存储库ArchitecturalComponentExample中】</a></p>
<a id="more"></a>

<h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><h4 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h4><p>在<code>app/build.gradle</code>文件的<code>dependencies</code>中加入以下内容：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">&quot;androidx.startup:startup-runtime:1.0.0&quot;</span></span><br></pre></td></tr></table></figure>
<p>若获取依赖包报错，请检查项目目录下<code>build.gradle</code>中是否包含以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例项目结构说明"><a href="#示例项目结构说明" class="headerlink" title="示例项目结构说明"></a>示例项目结构说明</h4><p><a href="https://github.com/TinloneX/ArchitecturalComponentExample/tree/main/StartUpExample/StartUpExampleJava">本项目Java版本地址</a></p>
<p><a href="https://github.com/TinloneX/ArchitecturalComponentExample/tree/main/StartUpExample/StartUpExampleKotlin">本项目Kotlin版本地址</a></p>
<p><a href="https://developer.android.google.cn/topic/libraries/app-startup">最简实践请参考官方开发文档</a></p>
<p>本项目示例主要结构如下：</p>
<p><img src="https://s3.ax1x.com/2021/02/23/yL3Fz9.png" alt="yL3Fz9.png"></p>
<p>图中②部分代表用来初始化各个组件SDK的初始化器。</p>
<p>图中①部分代表模拟的需初始化的三方SDK，<strong>SDK之间存在”有向无环”的相互依赖关系</strong>，依赖关系如下：</p>
<p><img src="https://s3.ax1x.com/2021/02/24/yXhL40.png" alt="yXhL40.png"></p>
<p>上述图中表述的依赖关系为：</p>
<ul>
<li>Cache 依赖于 DatabaseProxy 及 Logger</li>
<li>DatabaseProxy 依赖于 DatabaseHelper 及 Logger</li>
<li>DatabaseHelper 及 TXMap 均依赖于 Logger</li>
</ul>
<h4 id="创建初始化器"><a href="#创建初始化器" class="headerlink" title="创建初始化器"></a>创建初始化器</h4><blockquote>
<p>通过创建一个实现了初始化器接口的类来定义每个组件初始化器。这个接口定义了两个重要的方法:</p>
<ul>
<li>create()方法包含初始化组件所需的所有操作，并返回T的实例。</li>
<li>dependencies()方法，它返回初始化器所依赖的其他初始化器对象的列表。你可以使用这个方法来控制应用程序在启动时运行初始化器的顺序。</li>
</ul>
</blockquote>
<p>依照上述规则，我们来编写Logger的初始化类LoggerInitializer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerInitializer</span> <span class="keyword">implements</span> <span class="title">Initializer</span>&lt;<span class="title">Logger</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Logger <span class="title">create</span><span class="params">(<span class="meta">@NonNull</span> Context context)</span> </span>&#123;</span><br><span class="line">        Log.i(<span class="string">&quot;loglog&quot;</span>, <span class="string">&quot;create: LoggerInitializer&quot;</span>);</span><br><span class="line">        Logger.initialize();</span><br><span class="line">        <span class="keyword">return</span> Logger.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Class&lt;? extends Initializer&lt;?&gt;&gt;&gt; dependencies() &#123;</span><br><span class="line">        <span class="comment">// 预示没有其他依赖需要初始化</span></span><br><span class="line">        <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>首先初始化器需要实现<code>Initializer<?></code>接口，并传入需初始化的对象的泛型，<em>思考如果不传或传入Void会怎样？</em></li>
<li>实现create方法，此方法中完成组件初始化，如有需要可返回实例</li>
<li>实现dependencies方法，此方法中声明当前初始化组件依赖于其他组件，并返回被依赖组件的初始化器，此处Logger未依赖其他组件，故返回空数组，<em>思考如果返回null会怎样？</em></li>
</ul>
<p>类似的，我们根据组件依赖关系依次定义出各个组件的初始化器，对比上述无依赖的Logger，我们再来看看多个依赖的DatabaseProxy的初始化器是如何定义的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatabaseProxyInitializer</span> <span class="keyword">implements</span> <span class="title">Initializer</span>&lt;<span class="title">DatabaseProxy</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DatabaseProxy <span class="title">create</span><span class="params">(<span class="meta">@NonNull</span> Context context)</span> </span>&#123;</span><br><span class="line">        Log.i(<span class="string">&quot;loglog&quot;</span>, <span class="string">&quot;create: DatabaseProxyInitializer&quot;</span>);</span><br><span class="line">        DatabaseProxy.initialize(DatabaseHelper.getInstance());</span><br><span class="line">        <span class="keyword">return</span> DatabaseProxy.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Class&lt;? extends Initializer&lt;?&gt;&gt;&gt; dependencies() &#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(LoggerInitializer.class, DatabaseHelperInitializer.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到在<code>dependencies</code>中声明了DatabaseProxy依赖于Logger和DatabaseHelper。</p>
<p>接下来，我们尝试一下上述的两个思考题。</p>
<ol>
<li>当Initializer&lt;?&gt;泛型传入Void会怎样？</li>
</ol>
<p>此场景类似于：当我们仅单纯的想执行某组件的初始化而没有返回实例的情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomethingInitializer</span> <span class="keyword">implements</span> <span class="title">Initializer</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Void <span class="title">create</span><span class="params">(<span class="meta">@NonNull</span> Context context)</span> </span>&#123;</span><br><span class="line">        Log.i(<span class="string">&quot;loglog&quot;</span>, <span class="string">&quot;create: SomethingInitializer&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Class&lt;? extends Initializer&lt;?&gt;&gt;&gt; dependencies() &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，我们让TXMap的初始化器去依赖这SomethingInitializer：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapInitializer</span> <span class="keyword">implements</span> <span class="title">Initializer</span>&lt;<span class="title">TXMap</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TXMap <span class="title">create</span><span class="params">(<span class="meta">@NonNull</span> Context context)</span> </span>&#123;</span><br><span class="line">        Log.i(<span class="string">&quot;loglog&quot;</span>, <span class="string">&quot;create: MapInitializer&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TXMap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Class&lt;? extends Initializer&lt;?&gt;&gt;&gt; dependencies() &#123;</span><br><span class="line">        <span class="comment">// map依赖了log，现在我们让它依赖Something</span></span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(LoggerInitializer.class, SomethingInitializer.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们看看其执行结果 <em>（当然，仅编写初始化器的代码仍不能正常工作，还未在AndroidManifest中声明初始化组件，此处我们暂只关注结果，下一节将介绍声明初始化组件）</em>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">I&#x2F;tag: create: LoggerInitializer</span><br><span class="line">I&#x2F;tag: Logger initialized</span><br><span class="line">I&#x2F;tag: create: SomethingInitializer</span><br><span class="line">I&#x2F;tag: create: MapInitializer</span><br><span class="line">I&#x2F;tag: Map initialized</span><br></pre></td></tr></table></figure>
<p>我们可以看到，其依旧正常按需执行了初始化操作，先调用了被TXMap依赖的Logger及Something的初始化器，最终完成Map的初始化。说明，Initializer&lt;?&gt;中有无传入泛型及传入Void泛型，其均可正常执行，正常适用于仅执行初始化操作，无返回实例的情景。</p>
<ol start="2">
<li>如果dependencies返回值为null会发生什么？</li>
</ol>
<p>我们将LoggerInitializer的依赖由<code>return Collections.emptyList()</code>修改为<code>return null</code>然后执行 <em>（仅编写初始化器的代码仍不能正常工作，还未在AndroidManifest中声明初始化组件，此处我们只关注结果，下一节将介绍声明初始化组件）</em>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 报错日志</span><br><span class="line">java.lang.RuntimeException: Unable to get provider androidx.startup.InitializationProvider:</span><br><span class="line">androidx.startup.StartupException:</span><br><span class="line">androidx.startup.StartupException:</span><br><span class="line">java.lang.NullPointerException: Attempt to invoke interface method &#39;boolean java.util.List.isEmpty()&#39; on a null object reference</span><br></pre></td></tr></table></figure>
<p>我们发现程序报错了，故dependencies返回值不能为null，至于原因将在原理篇中具体说明，记住此处【伏笔1】。</p>
<h4 id="注册初始化器提供者"><a href="#注册初始化器提供者" class="headerlink" title="注册初始化器提供者"></a>注册初始化器提供者</h4><p>上文提到，仅编写初始化器并不能完成组件初始化，显然的，我们没有配置其执行的时机。</p>
<blockquote>
<p>应用程序启动包括一个叫做InitializationProvider的特殊内容提供程序，它用来发现和调用你的组件初始化器。应用启动时通过首先检查InitializationProvider清单项下的项来发现组件初始化器。然后，App Startup为它已经发现的任何初始化器调用dependencies()方法。<br>这意味着，为了让组件初始化器在应用启动时被发现，必须满足以下条件之一:</p>
<ul>
<li>组件初始化器在InitializationProvider清单项下有一个对应的项。</li>
<li>组件初始化器在dependencies()方法中列出，它来自一个已经可以发现的初始化器。</li>
</ul>
</blockquote>
<p>此案例中，为了确保应用程序启动时可以发现这些初始化器，请将以下内容添加到清单文件中:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;provider</span><br><span class="line">    android:name&#x3D;&quot;androidx.startup.InitializationProvider&quot;</span><br><span class="line">    android:authorities&#x3D;&quot;$&#123;applicationId&#125;.androidx-startup&quot;</span><br><span class="line">    android:exported&#x3D;&quot;false&quot;</span><br><span class="line">    tools:node&#x3D;&quot;merge&quot;&gt;</span><br><span class="line">    &lt;!-- This entry makes ExampleLoggerInitializer discoverable. --&gt;</span><br><span class="line">    &lt;meta-data</span><br><span class="line">        android:name&#x3D;&quot;com.tinlone.startupexamplejava.initializers.CacheInitializer&quot;</span><br><span class="line">        android:value&#x3D;&quot;androidx.startup&quot; &#x2F;&gt;</span><br><span class="line">    &lt;meta-data</span><br><span class="line">        android:name&#x3D;&quot;com.tinlone.startupexamplejava.initializers.MapInitializer&quot;</span><br><span class="line">        android:value&#x3D;&quot;androidx.startup&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;provider&gt;</span><br></pre></td></tr></table></figure>
<p>上述代码将初始化器传递给初始化提供者。</p>
<p>若初始化链有多个，类似本示例中包含：</p>
<ul>
<li>Logger -&gt; TXMap</li>
<li>Logger -&gt; DatabaseHelper -&gt; DatabaseProxy</li>
</ul>
<p>以上两条独立的链，故此处为每条独立的链的链尾初始化器传递给InitializationProvider，为何要这样写呢？我们也将在源码篇中具体探讨，记住此处【伏笔2】.</p>
<h4 id="手动初始化组件"><a href="#手动初始化组件" class="headerlink" title="手动初始化组件"></a>手动初始化组件</h4><p>当然，如果你不想InitializationProvider自动初始化某些组件，你也可以手动调用初始化流程，此时你应该这样做：</p>
<ul>
<li>将不需要初始化的组件标记为<code>remove</code>:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;meta-data android:name&#x3D;&quot;com.example.ExampleLoggerInitializer&quot;</span><br><span class="line">          tools:node&#x3D;&quot;remove&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>在需要初始化的时机调用以下代码，以Logger为例：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AppInitializer.getInstance(context)</span><br><span class="line">    .initializeComponent(LoggerInitializer.class);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>您在条目中使用工具:node=”remove”，而不是简单地删除条目，以确保合并工具也从所有其他合并的清单文件中删除条目。</p>
</blockquote>
<blockquote>
<p>注意:禁用组件的自动初始化也会禁用该组件的依赖项的自动初始化。</p>
</blockquote>
<p>若你想完全禁止组件自动初始化，你可以将<code>InitializationProvider</code>组件声明为<code>remove</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;provider</span><br><span class="line">    android:name&#x3D;&quot;androidx.startup.InitializationProvider&quot;</span><br><span class="line">    android:authorities&#x3D;&quot;$&#123;applicationId&#125;.androidx-startup&quot;</span><br><span class="line">    tools:node&#x3D;&quot;remove&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p>并在需要初始化的时机调用以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AppInitializer.getInstance(context)</span><br><span class="line">    .initializeComponent(ExampleLoggerInitializer.class);</span><br></pre></td></tr></table></figure>
<h4 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h4><p>StartUp的使用仅需完成上述两个步骤即可，让我们来看一下器执行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">I&#x2F;loglog: create: LoggerInitializer</span><br><span class="line">I&#x2F;loglog: Logger initialized</span><br><span class="line">I&#x2F;loglog: create: SomethingInitializer</span><br><span class="line">I&#x2F;loglog: create: MapInitializer</span><br><span class="line">I&#x2F;loglog: Map initialized</span><br><span class="line">I&#x2F;loglog: create: DatabaseHelperInitializer</span><br><span class="line">I&#x2F;loglog: DatabaseHelper initialized</span><br><span class="line">I&#x2F;loglog: create: DatabaseProxyInitializer</span><br><span class="line">I&#x2F;loglog: DatabaseHelper initialized</span><br><span class="line">I&#x2F;loglog: DatabaseProxy initialized</span><br><span class="line">I&#x2F;loglog: create: CacheInitializer</span><br><span class="line">I&#x2F;loglog: Cache initialized</span><br></pre></td></tr></table></figure>
<p>我们在AndroidManifest中声明的是链尾的初始化器<code>CacheInitializer</code>及<code>MapInitializer</code>, 他却是从依赖链的头开始执行的初始化，他是如何做到完全符合依赖链顺序执行的呢？<br>让我们来简单看一下其原理。</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>上面使用篇中我们埋下了一些伏笔和问题：</p>
<ul>
<li>为什么dependencies返回值不能为null？</li>
<li>为什么要将每条独立的链的链尾初始化器传递给InitializationProvider？</li>
<li>他是如何做到完全符合依赖链顺序执行的？</li>
</ul>
<p>为解答这些问题，我们先从初始化的入口类<code>InitializationProvider</code>看起。</p>
<h4 id="InitializationProvider"><a href="#InitializationProvider" class="headerlink" title="InitializationProvider"></a>InitializationProvider</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestrictTo(RestrictTo.Scope.LIBRARY)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InitializationProvider</span> <span class="keyword">extends</span> <span class="title">ContentProvider</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Context context = getContext();</span><br><span class="line">        <span class="keyword">if</span> (context != <span class="keyword">null</span>) &#123;</span><br><span class="line">            AppInitializer.getInstance(context).discoverAndInitialize();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StartupException(<span class="string">&quot;Context cannot be null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// something else ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>InitializationProvider</code>内容相对简单，其作为内容提供者在初始化时调用了<code> AppInitializer.getInstance(context).discoverAndInitialize()</code>去扫描初始化器配置并执行后续操作。</p>
<h4 id="AppInitializer"><a href="#AppInitializer" class="headerlink" title="AppInitializer"></a>AppInitializer</h4><p>AppInitializer 维持了一个单例结构，主要包含两个重要方法<code>discoverAndInitialize</code>及<code>doInitialize</code>, 分别负责发现初始化器及执行初始化器，我们一一看来。</p>
<h5 id="discoverAndInitialize"><a href="#discoverAndInitialize" class="headerlink" title="discoverAndInitialize()"></a>discoverAndInitialize()</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">discoverAndInitialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Trace.beginSection(SECTION_NAME);</span><br><span class="line">        <span class="comment">// 创建组件标识符，获取InitializationProvider信息</span></span><br><span class="line">        ComponentName provider = <span class="keyword">new</span> ComponentName(mContext.getPackageName(),</span><br><span class="line">                InitializationProvider.class.getName());</span><br><span class="line">        <span class="comment">// 根据组件标识符从包管理器中取得组件，并获取组件元数据</span></span><br><span class="line">        ProviderInfo providerInfo = mContext.getPackageManager()</span><br><span class="line">                .getProviderInfo(provider, GET_META_DATA);</span><br><span class="line">        <span class="comment">// 取得元数据</span></span><br><span class="line">        Bundle metadata = providerInfo.metaData;</span><br><span class="line">        String startup = mContext.getString(R.string.androidx_startup);</span><br><span class="line">        <span class="keyword">if</span> (metadata != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Set&lt;Class&lt;?&gt;&gt; initializing = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            <span class="comment">// 取出元数据中 key的集合， 此处metadata的本质实为ArrayMap，参见&#123;@link Bundle#keySet&#125;</span></span><br><span class="line">            Set&lt;String&gt; keys = metadata.keySet();</span><br><span class="line">            <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">                String value = metadata.getString(key, <span class="keyword">null</span>);</span><br><span class="line">                <span class="comment">// 校验是否为androidx_startup元数据</span></span><br><span class="line">                <span class="keyword">if</span> (startup.equals(value)) &#123;</span><br><span class="line">                    <span class="comment">// 根据元数据key中的全类名生成字节码对象</span></span><br><span class="line">                    Class&lt;?&gt; clazz = Class.forName(key);</span><br><span class="line">                    <span class="comment">// 校验字节码对象是否是 Initializer 的实现类</span></span><br><span class="line">                    <span class="keyword">if</span> (Initializer.class.isAssignableFrom(clazz)) &#123;</span><br><span class="line">                        Class&lt;? extends Initializer&lt;?&gt;&gt; component =</span><br><span class="line">                                (Class&lt;? extends Initializer&lt;?&gt;&gt;) clazz;</span><br><span class="line">                        <span class="comment">// 加入Set备用</span></span><br><span class="line">                        mDiscovered.add(component);</span><br><span class="line">                        <span class="keyword">if</span> (StartupLogger.DEBUG) &#123;</span><br><span class="line">                            StartupLogger.i(String.format(<span class="string">&quot;Discovered %s&quot;</span>, key));</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 执行初始化</span></span><br><span class="line">                        doInitialize(component, initializing);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (PackageManager.NameNotFoundException | ClassNotFoundException exception) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StartupException(exception);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Trace.endSection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由代码可知，其主要做了以下事情：</p>
<ul>
<li>创建组件标识符，获取InitializationProvider信息</li>
<li>根据组件标识符从包管理器中取得组件，并获取组件元数据</li>
<li>取得元数据， 取出元数据中 key的集合</li>
<li>遍历元数据集合（ArrayMap）中的数据，校验是否为androidx_startup元数据</li>
<li>根据元数据key中的全类名生成字节码对象，校验字节码对象是否是 Initializer 的实现类</li>
<li>将Initializer 的实现类 字节码对象加入变量mDiscovered的Set中备用</li>
<li>执行初始化</li>
</ul>
<h5 id="doInitialize"><a href="#doInitialize" class="headerlink" title="doInitialize()"></a>doInitialize()</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; T doInitialize(</span><br><span class="line">        @NonNull Class&lt;? extends Initializer&lt;?&gt;&gt; component,</span><br><span class="line">        @NonNull Set&lt;Class&lt;?&gt;&gt; initializing) &#123;</span><br><span class="line">    synchronized (sLock) &#123;</span><br><span class="line">        boolean isTracingEnabled &#x3D; Trace.isEnabled();</span><br><span class="line">        try &#123;</span><br><span class="line">            if (isTracingEnabled) &#123;</span><br><span class="line">                &#x2F;&#x2F; 这里使用simpleName，因为否则节名会太大。</span><br><span class="line">                Trace.beginSection(component.getSimpleName());</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 保证初始化链无环，initializing为执行记录集合</span><br><span class="line">            &#x2F;&#x2F; 从discoverAndInitialize中传递的initializing值为空，故此判断不会执行</span><br><span class="line">            &#x2F;&#x2F; 从本函数递归执行传递的是已包含执行的初始化器，若此时初始化器有重复，说明相互依赖关系成环了，应抛错</span><br><span class="line">            if (initializing.contains(component)) &#123;</span><br><span class="line">                String message &#x3D; String.format(</span><br><span class="line">                        &quot;Cannot initialize %s. Cycle detected.&quot;, component.getName()</span><br><span class="line">                );</span><br><span class="line">                throw new IllegalStateException(message);</span><br><span class="line">            &#125;</span><br><span class="line">            Object result;</span><br><span class="line">            &#x2F;&#x2F; 若（被多次依赖且）已初始化则跳过</span><br><span class="line">            if (!mInitialized.containsKey(component)) &#123;</span><br><span class="line">                &#x2F;&#x2F; 将需要执行的初始化器字节码对象加入执行记录中</span><br><span class="line">                initializing.add(component);</span><br><span class="line">                try &#123;</span><br><span class="line">                    &#x2F;&#x2F; 获取初始化器实例</span><br><span class="line">                    Object instance &#x3D; component.getDeclaredConstructor().newInstance();</span><br><span class="line">                    Initializer&lt;?&gt; initializer &#x3D; (Initializer&lt;?&gt;) instance;</span><br><span class="line">                    &#x2F;&#x2F; 获取初始化器依赖关系</span><br><span class="line">                    List&lt;Class&lt;? extends Initializer&lt;?&gt;&gt;&gt; dependencies &#x3D;</span><br><span class="line">                            initializer.dependencies();</span><br><span class="line">                    &#x2F;&#x2F; 若此初始化器有相关依赖</span><br><span class="line">                    &#x2F;&#x2F; 是否记得【伏笔1】有提到为何dependencies不能返回null吗？</span><br><span class="line">                    &#x2F;&#x2F; 此处dependencies取得的值并未作空判断，故 null.isEmpty()会报空指针异常</span><br><span class="line">                    if (!dependencies.isEmpty()) &#123;</span><br><span class="line">                        &#x2F;&#x2F; 则遍历依赖，执行其初始化器，并传递初始化执行记录，防止依赖成环</span><br><span class="line">                        for (Class&lt;? extends Initializer&lt;?&gt;&gt; clazz : dependencies) &#123;</span><br><span class="line">                            if (!mInitialized.containsKey(clazz)) &#123;</span><br><span class="line">                                doInitialize(clazz, initializing);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (StartupLogger.DEBUG) &#123;</span><br><span class="line">                        StartupLogger.i(String.format(&quot;Initializing %s&quot;, component.getName()));</span><br><span class="line">                    &#125;</span><br><span class="line">                    result &#x3D; initializer.create(mContext);</span><br><span class="line">                    if (StartupLogger.DEBUG) &#123;</span><br><span class="line">                        StartupLogger.i(String.format(&quot;Initialized %s&quot;, component.getName()));</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F; 执行完毕，移除记录</span><br><span class="line">                    initializing.remove(component);</span><br><span class="line">                    &#x2F;&#x2F; 记录初始化完成</span><br><span class="line">                    mInitialized.put(component, result);</span><br><span class="line">                &#125; catch (Throwable throwable) &#123;</span><br><span class="line">                    throw new StartupException(throwable);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                result &#x3D; mInitialized.get(component);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 返回执行结果</span><br><span class="line">            return (T) result;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            Trace.endSection();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由代码可知，其主要做了以下事情：</p>
<ul>
<li>首先根据单链执行记录判断此链中是否有依赖关系成环，成环则抛错</li>
<li>根据初始换执行完成的记录判断（被多次依赖的）依赖是否已被初始化，已初始化则跳过</li>
<li>将需要执行的初始化器字节码对象加入执行记录中备用，用以判断依赖链中是否成环</li>
<li>调用 initializer.dependencies() 获取初始化器依赖关系</li>
<li>若此初始化器有其他依赖则遍历依赖递归调用 doInitialize() 执行至依赖链的链头的初始化</li>
<li>链执行完毕，则移除此链的执行记录</li>
<li>链执行完毕，将元数据中声明的初始化器加入至已完成集合中，用以避免重复初始化</li>
</ul>
<p>那么至此，我们似乎可以解释此节初始留下的三个伏笔问题了。</p>
<ol>
<li>为什么dependencies()返回值不能为null？</li>
</ol>
<p>答：因为在执行初始化前，会判断当前初始化器的dependencies是否为空，但此时使用的时 List.isEmpty() 并未对dependencies判空，故而，若dependencies()返回null，会导致null.isEmpty()的调用，导致空指针异常。</p>
<ol start="2">
<li>为什么要将每条独立的链的链尾初始化器传递给InitializationProvider？</li>
</ol>
<p>答：因为可以根据链尾的初始化器可以通过遍历递归dependencies()获取该链所有以来的初始化器，从而找到链首的初始化器，然后从头至尾折叠递归运算，同时也保证了依赖链顺序执行</p>
<ol start="3">
<li>他是如何做到完全符合依赖链顺序执行的？</li>
</ol>
<p>答同问题2</p>
]]></content>
      <categories>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>StartUp</tag>
      </tags>
  </entry>
  <entry>
    <title>Jetpack之界面数据存储组件-ViewModel</title>
    <url>/2021/03/07/Jetpack%E4%B9%8B%E7%95%8C%E9%9D%A2%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%84%E4%BB%B6-ViewModel/</url>
    <content><![CDATA[<p>ViewModel这个名称常常使人误解为MVVM中的ViewModel层，那么它是不是同一个东西呢？</p>
<p>ViewModel可以作为MVVM中的ViewModel层，但不是特指MVVM中的ViewModel层。</p>
<blockquote>
<p>ViewModel 类旨在以注重生命周期的方式存储和管理界面相关的数据。ViewModel 类让数据可在发生屏幕旋转等配置更改后继续留存。</p>
</blockquote>
<p>它是一个独立的组件，你可以把它视作生命周期相关的数据存储工具, 把它用在你觉得合适的任意地方，<strong>它可以是Fragment共享数据的桥梁、可以是屏幕方向切换时的数据来源、当然也可以是 MVVM 中 ViewModel层的 数据提供者，你可以使用LiveData让它变成可观察的数据，也可以使用DataBinding让他成为View的数据源</strong>。</p>
<p><a href="https://github.com/TinloneX/ArchitecturalComponentExample">【本系列文章(JAVA/KOTLIN)演示案例均存储在github存储库ArchitecturalComponentExample中】</a></p>
<p>本篇所述源码及代码基于 <strong>API 30</strong>；</p>
<a id="more"></a>
<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>以往，我们在系统销毁或重新创建界面控制器时，为保证存储在其中的任何瞬态界面相关数据不丢失，往往使用Activity 可以使用 onSaveInstanceState() 方法从 onCreate() 中的捆绑包恢复其数据。此方法在一定场景下有可能不适用，例如：</p>
<blockquote>
<p>此方法仅适合可以序列化再反序列化的少量数据，而不适合数量可能较大的数据，如用户列表或位图。</p>
</blockquote>
<p>在这一方面上，ViewModel可以存储任意你想要存储的数据，相对于onSaveInstanceState() 显然是具有明显优势的。同时，它是一个生命周期敏感组件，对于像横竖屏切换类似情况，重建界面时，可以不必做类似重建位图、重新反序列化数据、重新请求网络数据的操作。</p>
<p>从规范上来说，ViewModel推荐我们将数据从界面层中拿出去：</p>
<blockquote>
<p>从界面控制器逻辑中分离出视图数据所有权的操作更容易且更高效。</p>
</blockquote>
<h3 id="ViewModel使用篇"><a href="#ViewModel使用篇" class="headerlink" title="ViewModel使用篇"></a>ViewModel使用篇</h3><p>此篇所讲述的使用篇均仅介绍ViewModel自身特性，区别于<a href="https://developer.android.google.cn/topic/libraries/architecture/viewmodel#java">官方文档</a>对于ViewModel使用与LiveData等组件混在一起讲的情景。</p>
<h4 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h4><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">&quot;androidx.lifecycle:lifecycle-viewmodel:2.3.0&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="创建案例"><a href="#创建案例" class="headerlink" title="创建案例"></a>创建案例</h4><p>首先，简单的，我们创建一个测试页面，一个计数Button以及一个输入框用以做数据的输入和变化，界面比较简单，此处不做赘述。</p>
<p>我们使操作上述控件改变响应的值并存储在Activity中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;ViewModelDemoLog&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String input = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        Button btnCounter = findViewById(R.id.button);</span><br><span class="line">        EditText etInput = findViewById(R.id.editText);</span><br><span class="line"></span><br><span class="line">        btnCounter.setText(String.format(<span class="string">&quot;UP COUNT (%s)&quot;</span>, count));</span><br><span class="line"></span><br><span class="line">        Log.i(TAG, <span class="string">&quot;当前计数值：&quot;</span> + count);</span><br><span class="line"></span><br><span class="line">        btnCounter.setOnClickListener(v -&gt; &#123;</span><br><span class="line">            count++;</span><br><span class="line">            btnCounter.setText(String.format(<span class="string">&quot;UP COUNT (%s)&quot;</span>, count));</span><br><span class="line">            Log.i(TAG, <span class="string">&quot;计数增至：&quot;</span> + count);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        etInput.addTextChangedListener(<span class="keyword">new</span> TextWatcher() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeTextChanged</span><span class="params">(CharSequence s, <span class="keyword">int</span> start, <span class="keyword">int</span> count, <span class="keyword">int</span> after)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTextChanged</span><span class="params">(CharSequence s, <span class="keyword">int</span> start, <span class="keyword">int</span> before, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterTextChanged</span><span class="params">(Editable s)</span> </span>&#123;</span><br><span class="line">                input = s.toString();</span><br><span class="line">                Log.i(TAG, <span class="string">&quot;输入框输入：&quot;</span> + s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        findViewById(R.id.button2).setOnClickListener(v -&gt; startActivity(<span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, SecActivity.class)));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种情况下运行，点击计数Button日志：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当前计数值：0</span><br><span class="line">计数增至：1</span><br><span class="line">计数增至：2</span><br><span class="line">计数增至：3</span><br></pre></td></tr></table></figure>
<p>此时，翻转屏幕后日志：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当前计数值：0</span><br><span class="line">输入框输入：</span><br></pre></td></tr></table></figure>
<p>我们观察到通过点击button改变的count值在翻转屏幕后被清除了，这里我们简单验证了翻转屏幕时屏幕重建，Activity中保存的瞬时量数据不会被保存（真的不会吗）。这里我们发现多了一行的日志，似乎EditText在屏幕重建后被填充了一次值，不如我们在翻转屏幕前为EditText输入一个值再试一下：<br>翻转屏幕前：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当前计数值：0</span><br><span class="line">计数增至：1</span><br><span class="line">计数增至：2</span><br><span class="line">输入框输入：a</span><br><span class="line">输入框输入：aa</span><br><span class="line">输入框输入：aaa</span><br></pre></td></tr></table></figure>
<p>翻转屏幕后：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当前计数值：0</span><br><span class="line">输入框输入：aaa</span><br></pre></td></tr></table></figure>
<p>我们发现输入框的数据被保存下来并在重建屏幕时被重新赋值，需要关注此部分原理请见【<a href="#edit_text_save_state">附录</a>】。</p>
<p>回到正题，那么，上述数据如果保存在ViewModel中会怎样呢？</p>
<h4 id="使用ViewModel改造案例"><a href="#使用ViewModel改造案例" class="headerlink" title="使用ViewModel改造案例"></a>使用ViewModel改造案例</h4><p>首先，创建我们的ViewModel，并把需要存储的数据放到ViewModel中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeDataViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String logText = <span class="string">&quot;==start==&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendLog</span><span class="params">(String log)</span> </span>&#123;</span><br><span class="line">        logText += <span class="string">&quot;\n&quot;</span> + log;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>为避免EditText问题影响效果观测，后续流程将会移除EditText。</em></p>
<p>代码比较简单，只需要编写一个类继承ViewModel，并将你需要存储的数据放在ViewModel中即可。</p>
<p>而使用ViewModel代码也相对简单，你只需要通过<code>ViewModelProvider(activity).get(HomeDataViewModel.class)</code>即可获取到ViewModel对象。至于为何需要使用这样一个相对复杂的方式获取ViewModel，我们稍后在原理篇中具体说明。</p>
<p>当然你可能在想，如果我的ViewModel需要使用有参构造器怎么办？<br>不用担心，它也为我们提供了解决办法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyViewModelFactory</span> <span class="keyword">implements</span> <span class="title">ViewModelProvider</span>.<span class="title">Factory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> String defaultConfig = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyViewModelFactory</span><span class="params">(String defaultConfig)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.defaultConfig = defaultConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T extends ViewModel&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="meta">@NonNull</span> Class&lt;T&gt; modelClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) <span class="keyword">new</span> HomeDataViewModel(defaultConfig);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用时</span></span><br><span class="line">viewModel = <span class="keyword">new</span> ViewModelProvider(<span class="keyword">this</span>, </span><br><span class="line">                <span class="keyword">new</span> MyViewModelFactory(<span class="string">&quot;i have default config&quot;</span>))</span><br><span class="line">                .get(HomeDataViewModel.class);</span><br></pre></td></tr></table></figure>
<p>即创建一个 ViewModelProvider.Factory 为ViewModelProvider提供ViewModel的初始化操作，将ViewModel需要的参数传值给 MyViewModelFactory ，由MyViewModelFactory在创建 ViewModel时调用对应的构造器方法即可。</p>
<p>接下来我们改造Activity代码，使其使用ViewModel作为数据存储：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;ViewModelDemoLog&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HomeDataViewModel viewModel;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_sec);</span><br><span class="line"></span><br><span class="line">        Button btnCounter = findViewById(R.id.button);</span><br><span class="line"></span><br><span class="line">        viewModel = <span class="keyword">new</span> ViewModelProvider(<span class="keyword">this</span>).get(HomeDataViewModel.class);</span><br><span class="line"></span><br><span class="line">        Log.i(TAG, <span class="string">&quot;读取viewModel.hashCode(): &quot;</span> + viewModel.hashCode());</span><br><span class="line"></span><br><span class="line">        btnCounter.setText(String.format(<span class="string">&quot;UP COUNT (%s)&quot;</span>, viewModel.count));</span><br><span class="line"></span><br><span class="line">        Log.i(TAG, <span class="string">&quot;当前计数值：&quot;</span> + viewModel.count);</span><br><span class="line"></span><br><span class="line">        btnCounter.setOnClickListener(v -&gt; &#123;</span><br><span class="line">            viewModel.count++;</span><br><span class="line">            btnCounter.setText(String.format(<span class="string">&quot;UP COUNT (%s)&quot;</span>, viewModel.count));</span><br><span class="line">            Log.i(TAG, <span class="string">&quot;计数增至：&quot;</span> + viewModel.count);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里我们直接将先前使用Activity中变量改为使用ViewModel中的变量即可，就是这么简单，那么我们来看一下其效果：</p>
<p>翻转屏幕前：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">读取viewModel.hashCode(): 210932679</span><br><span class="line">当前计数值：0</span><br><span class="line">计数增至：1</span><br><span class="line">计数增至：2</span><br><span class="line">计数增至：3</span><br></pre></td></tr></table></figure>
<p>翻转屏幕后：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">读取viewModel.hashCode(): 210932679</span><br><span class="line">当前计数值：3</span><br></pre></td></tr></table></figure>
<p>我们再点击两次计数按钮：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">计数增至：4</span><br><span class="line">计数增至：5</span><br></pre></td></tr></table></figure>
<p>我们发现，我们的count字段值被保存了下来，而且翻转屏幕前后的ViewModel是同一个对象。</p>
<p>既然翻转前后的ViewModel是同一个对象，那么，可预见地，<strong>我们放在其内部的对象都不会被改变。也就是说，你可以在其中获取网络数据、缓存网络图片等等，而不用担心在屏幕翻转等改变Activity配置时，你的操作被中断以及重新创建时被重复调用。</strong></p>
<p><a href="https://developer.android.google.cn/topic/libraries/architecture/viewmodel">关于更多ViewModel使用的案例，请点击此处参见官方文档</a></p>
<p>ViewModel的使用相对简单，其职责单一，注重生命周期，使用篇就介绍到这儿，我们来看看其源码及工作原理吧。</p>
<h4 id="ViewModel生命周期"><a href="#ViewModel生命周期" class="headerlink" title="ViewModel生命周期"></a>ViewModel生命周期</h4><p>首先，ViewModel作为一个以注重生命周期的方式存储和管理界面相关的数据的组件，它的生命周期是怎样的呢？</p>
<p>这里我们引用官网对于<a href="https://developer.android.google.cn/topic/libraries/architecture/viewmodel#lifecycle">ViewModel 的生命周期</a>介绍的一张图来说明：<br><img src="https://developer.android.google.cn/images/topic/libraries/architecture/viewmodel-lifecycle.png" alt="viewmodel_lifecycle.png"></p>
<blockquote>
<p>您通常在系统首次调用 Activity 对象的 onCreate() 方法时请求 ViewModel。系统可能会在 Activity 的整个生命周期内多次调用 onCreate()，如在旋转设备屏幕时。ViewModel 存在的时间范围是从您首次请求 ViewModel 直到 Activity 完成并销毁。</p>
</blockquote>
<p>那么，让我们看看其具体是怎么做到的吧！</p>
<p>首先我们先从ViewModel对象的获取开始看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="keyword">public</span> &lt;T extends ViewModel&gt; <span class="function">T <span class="title">get</span><span class="params">(<span class="meta">@NonNull</span> String key, <span class="meta">@NonNull</span> Class&lt;T&gt; modelClass)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 尝试ViewModelStore中取</span></span><br><span class="line">    ViewModel viewModel = mViewModelStore.get(key);</span><br><span class="line">    <span class="comment">// 类型校验</span></span><br><span class="line">    <span class="keyword">if</span> (modelClass.isInstance(viewModel)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mFactory <span class="keyword">instanceof</span> OnRequeryFactory) &#123;</span><br><span class="line">            ((OnRequeryFactory) mFactory).onRequery(viewModel);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (T) viewModel;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//noinspection StatementWithEmptyBody</span></span><br><span class="line">        <span class="keyword">if</span> (viewModel != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> log a warning.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 未取到则创建</span></span><br><span class="line">    <span class="keyword">if</span> (mFactory <span class="keyword">instanceof</span> KeyedFactory) &#123;</span><br><span class="line">        viewModel = ((KeyedFactory) mFactory).create(key, modelClass);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        viewModel = mFactory.create(modelClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 存入ViewModelStore</span></span><br><span class="line">    mViewModelStore.put(key, viewModel);</span><br><span class="line">    <span class="keyword">return</span> (T) viewModel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里主要利用ViewModelStore做了缓存（存储），缓存中有则取出，无则创建并加入缓存。</p>
<p>ViewModelStore内部维护了一个<code>HashMap<String, ViewModel></code>存储ViewModel:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewModelStore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String, ViewModel&gt; mMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, ViewModel viewModel)</span> </span>&#123;</span><br><span class="line">        ViewModel oldViewModel = mMap.put(key, viewModel);</span><br><span class="line">        <span class="keyword">if</span> (oldViewModel != <span class="keyword">null</span>) &#123;</span><br><span class="line">            oldViewModel.onCleared();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> ViewModel <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mMap.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Set&lt;String&gt; <span class="title">keys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HashSet&lt;&gt;(mMap.keySet());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  Clears internal storage and notifies ViewModels that they are no longer used.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">// 记住此处，稍后会讲</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (ViewModel vm : mMap.values()) &#123;</span><br><span class="line">            vm.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        mMap.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码比较简单,此处不做赘述，值得注意的是，我们在它的注释中发现了这样一句话：</p>
<blockquote>
<p>Use {@link ViewModelStoreOwner#getViewModelStore()} to retrieve a {@code ViewModelStore} for activities and fragments.</p>
</blockquote>
<p>我们查看一下 ViewModelStoreOwner ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ViewModelStoreOwner</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns owned &#123;<span class="doctag">@link</span> ViewModelStore&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a &#123;<span class="doctag">@code</span> ViewModelStore&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function">ViewModelStore <span class="title">getViewModelStore</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只有一个 getViewModelStore的定义，查看其实现类，找到<code>androidx.activity.ComponentActivity</code>的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ViewModelStore <span class="title">getViewModelStore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getApplication() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Your activity is not yet attached to the &quot;</span></span><br><span class="line">                + <span class="string">&quot;Application instance. You can&#x27;t request ViewModel before onCreate call.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mViewModelStore == <span class="keyword">null</span>) &#123;</span><br><span class="line">        NonConfigurationInstances nc =</span><br><span class="line">                (NonConfigurationInstances) getLastNonConfigurationInstance();</span><br><span class="line">        <span class="keyword">if</span> (nc != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Restore the ViewModelStore from NonConfigurationInstances</span></span><br><span class="line">            mViewModelStore = nc.viewModelStore;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mViewModelStore == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mViewModelStore = <span class="keyword">new</span> ViewModelStore();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mViewModelStore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现，ViewModelStore来自于 NonConfigurationInstances ，而 NonConfigurationInstances 则取自 getLastNonConfigurationInstance()，我们先看一下 NonConfigurationInstances ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ComponentActivity&#123;</span><br><span class="line">    </span><br><span class="line">    static final class NonConfigurationInstances &#123;</span><br><span class="line">        Object custom;</span><br><span class="line">        ViewModelStore viewModelStore;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Activity&#123;</span><br><span class="line">    </span><br><span class="line">    static final class NonConfigurationInstances &#123;</span><br><span class="line">        Object activity;</span><br><span class="line">        HashMap&lt;String, Object&gt; children;</span><br><span class="line">        FragmentManagerNonConfig fragments;</span><br><span class="line">        ArrayMap&lt;String, LoaderManager&gt; loaders;</span><br><span class="line">        VoiceInteractor voiceInteractor;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public Object getLastNonConfigurationInstance() &#123;</span><br><span class="line">        return mLastNonConfigurationInstances !&#x3D; null</span><br><span class="line">                ? mLastNonConfigurationInstances.activity : null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由上述两段代码可知，ViewModelStore最终会存储在 Activity.NonConfigurationInstances中的 activity字段中，我们继续追溯<code>Activity.NonConfigurationInstances mLastNonConfigurationInstances;</code>是从哪里获取和取值的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">@link&#123;Activity#attach&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Context context, ActivityThread aThread,</span></span></span><br><span class="line"><span class="function"><span class="params">        Instrumentation instr, IBinder token, <span class="keyword">int</span> ident,</span></span></span><br><span class="line"><span class="function"><span class="params">        Application application, Intent intent, ActivityInfo info,</span></span></span><br><span class="line"><span class="function"><span class="params">        CharSequence title, Activity parent, String id,</span></span></span><br><span class="line"><span class="function"><span class="params">        NonConfigurationInstances lastNonConfigurationInstances,</span></span></span><br><span class="line"><span class="function"><span class="params">        Configuration config, String referrer, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">        Window window, ActivityConfigCallback activityConfigCallback, IBinder assistToken)</span> </span>&#123;</span><br><span class="line">    attachBaseContext(context);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    mLastNonConfigurationInstances = lastNonConfigurationInstances;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了解过Activity启动流程的应该都知道 activity.attach() 会在 ActivityThread.performLaunchActivity()中被调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ... 忽略其他代码</span></span><br><span class="line">    activity.attach(appContext, <span class="keyword">this</span>, getInstrumentation(), r.token,</span><br><span class="line">                        r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">                        <span class="comment">// r.lastNonConfigurationInstances 从ActivityClientRecord中取得</span></span><br><span class="line">                        r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">                        r.referrer, r.voiceInteractor, window, r.configCallback,</span><br><span class="line">                        r.assistToken);</span><br><span class="line">    <span class="comment">// ... 忽略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不难发现，lastNonConfigurationInstances来自于ActivityClientRecord对象，我们仅关注配置变化时的Activity重建流程，继续追溯，我们一次可以向前找到一下调用：</p>
<ul>
<li>ActivityThread.handleLaunchActivity(ActivityClientRecord r ,…)</li>
<li>ActivityThread.handleRelaunchActivityInner(ActivityClientRecord r ,…)</li>
<li>ActivityThread.handleRelaunchActivity(ActivityClientRecord r ,…)</li>
<li>ClientTransactionHandler.handleRelaunchActivity(ActivityThread.ActivityClientRecord r,…)</li>
<li>ActivityRelaunchItem.excute(ClientTransactionHandler client,…)</li>
<li>ActivityConfigurationChangeItem.excute(ClientTransactionHandler client,…)</li>
</ul>
<p>我们观察Activity重建的重建流程，只是对当前Activity对应的ActivityClientRecord进行了转换, 新创建的Activity的ActivityClientRecord依旧持有原Activity的lastNonConfigurationInstances对象。</p>
<p>那么这就<strong>最终保证了NonConfigurationInstances中的ViewModelStore在配置更改Activity重建过程中不会被改变，那么存储在其中的ViewModel自然也就没有变化。</strong></p>
<p>前面我们了解了ViewModel的存储原理，其主要依赖于ActivityClientRecord的特性来存储NonConfigurationInstances对象，保证ViewModel存在，而界面销毁时ActivityClientRecord也会被销毁，那么保存在其中的NonConfigurationInstances及其包含的ViewModel自然也就会被销毁。</p>
<p>当然销毁的时候，也会通知到我们自定义的ViewModel，用以做内存及资源的回收，具体实现为重写 onCleared()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeDataViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCleared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCleared();</span><br><span class="line">        <span class="comment">// 做流的关闭，资源回收等</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>向前追溯可以看到调用此方法的实为ViewModel.clear()方法【此处懒得贴代码】，<br>在之前的ViewModelStore代码中，我们观察到有以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (ViewModel vm : mMap.values()) &#123;</span><br><span class="line">    <span class="comment">// 调用ViewModel.clear()</span></span><br><span class="line">        vm.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    mMap.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续追溯，你会发现，他会在ComponentActivity构造方法中被调用，具体代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ComponentActivity() &#123;</span><br><span class="line">    &#x2F;&#x2F; 忽略其他代码</span><br><span class="line">    getLifecycle().addObserver(new LifecycleEventObserver() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onStateChanged(@NonNull LifecycleOwner source,</span><br><span class="line">                @NonNull Lifecycle.Event event) &#123;</span><br><span class="line">            if (event &#x3D;&#x3D; Lifecycle.Event.ON_DESTROY) &#123;</span><br><span class="line">                if (!isChangingConfigurations()) &#123;</span><br><span class="line">                    getViewModelStore().clear();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"> &#x2F;&#x2F; 忽略其他代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里创建并注册了生命周期观察者，在Lifecycle.Event.ON_DESTROY事件（界面销毁）时调用ViewModelStore.clear();</p>
<p>至此，ViewModel的使用及工作原理，我们就大致梳理了一遍了~！</p>
<h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a><span id="edit_text_save_state">附录</h3><h4 id="EditText控件数据存储与恢复"><a href="#EditText控件数据存储与恢复" class="headerlink" title="EditText控件数据存储与恢复"></a>EditText控件数据存储与恢复</h4><p>在ViewModel以前，Activity重建数据恢复主要依靠Activit.onSaveInstanceState, 我们大胆猜测EditText数据在翻转屏幕时数据依旧存在与此有关，我们尝试跟进一下其保存数据的流程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected void onSaveInstanceState(@NonNull Bundle outState) &#123;</span><br><span class="line">    &#x2F;&#x2F; 获取Window层级</span><br><span class="line">    outState.putBundle(WINDOW_HIERARCHY_TAG, mWindow.saveHierarchyState());</span><br><span class="line"></span><br><span class="line">    outState.putInt(LAST_AUTOFILL_ID, mLastAutofillId);</span><br><span class="line">    Parcelable p &#x3D; mFragments.saveAllState();</span><br><span class="line">    if (p !&#x3D; null) &#123;</span><br><span class="line">        outState.putParcelable(FRAGMENTS_TAG, p);</span><br><span class="line">    &#125;</span><br><span class="line">    if (mAutoFillResetNeeded) &#123;</span><br><span class="line">        outState.putBoolean(AUTOFILL_RESET_NEEDED, true);</span><br><span class="line">        getAutofillManager().onSaveInstanceState(outState);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 分发Activity存储状态</span><br><span class="line">    dispatchActivitySaveInstanceState(outState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先EditText作为View显然是依存在Window下的，那么我们尝试从Window下手，先来看看这里调用的<code>mWindow.saveHierarchyState()</code>, 由于这里是抽象方法，所以我们去看<code>PhoneWindow.saveHierarchyState()</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Bundle <span class="title">saveHierarchyState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Bundle outState = <span class="keyword">new</span> Bundle();</span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> outState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SparseArray&lt;Parcelable&gt; states = <span class="keyword">new</span> SparseArray&lt;Parcelable&gt;();</span><br><span class="line">    <span class="comment">// 收集父容器中的层级状态</span></span><br><span class="line">    mContentParent.saveHierarchyState(states);</span><br><span class="line">    outState.putSparseParcelableArray(VIEWS_TAG, states);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从容器中取得有焦点的控件</span></span><br><span class="line">    <span class="keyword">final</span> View focusedView = mContentParent.findFocus();</span><br><span class="line">    <span class="keyword">if</span> (focusedView != <span class="keyword">null</span> &amp;&amp; focusedView.getId() != View.NO_ID) &#123;</span><br><span class="line">        <span class="comment">// 存储控件ID</span></span><br><span class="line">        outState.putInt(FOCUSED_ID_TAG, focusedView.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// save the panels</span></span><br><span class="line">    SparseArray&lt;Parcelable&gt; panelStates = <span class="keyword">new</span> SparseArray&lt;Parcelable&gt;();</span><br><span class="line">    savePanelState(panelStates);</span><br><span class="line">    <span class="keyword">if</span> (panelStates.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        outState.putSparseParcelableArray(PANELS_TAG, panelStates);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mDecorContentParent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        SparseArray&lt;Parcelable&gt; actionBarStates = <span class="keyword">new</span> SparseArray&lt;Parcelable&gt;();</span><br><span class="line">        mDecorContentParent.saveToolbarHierarchyState(actionBarStates);</span><br><span class="line">        outState.putSparseParcelableArray(ACTION_BAR_TAG, actionBarStates);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> outState;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取容器View层级及状态<code>mContentParent.saveHierarchyState(states)</code>最终会调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CallSuper</span></span><br><span class="line"><span class="meta">@Nullable</span> <span class="function"><span class="keyword">protected</span> Parcelable <span class="title">onSaveInstanceState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mPrivateFlags |= PFLAG_SAVE_STATE_CALLED;</span><br><span class="line">    <span class="keyword">if</span> (mStartActivityRequestWho != <span class="keyword">null</span> || isAutofilled()</span><br><span class="line">            || mAutofillViewId &gt; LAST_APP_AUTOFILL_ID) &#123;</span><br><span class="line">        BaseSavedState state = <span class="keyword">new</span> BaseSavedState(AbsSavedState.EMPTY_STATE);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mStartActivityRequestWho != <span class="keyword">null</span>) &#123;</span><br><span class="line">            state.mSavedData |= BaseSavedState.START_ACTIVITY_REQUESTED_WHO_SAVED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isAutofilled()) &#123;</span><br><span class="line">            state.mSavedData |= BaseSavedState.IS_AUTOFILLED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mAutofillViewId &gt; LAST_APP_AUTOFILL_ID) &#123;</span><br><span class="line">            state.mSavedData |= BaseSavedState.AUTOFILL_ID;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        state.mStartActivityRequestWhoSaved = mStartActivityRequestWho;</span><br><span class="line">        state.mIsAutofilled = isAutofilled();</span><br><span class="line">        state.mHideHighlight = hideAutofillHighlight();</span><br><span class="line">        state.mAutofillViewId = mAutofillViewId;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BaseSavedState.EMPTY_STATE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>PhoneWindow.saveHierarchyState()</code>的作用是：获取容器中所有View的层级及状态，然后筛选出面板panels和具有焦点的控件返回给Activity，EditText自然就被筛选记录，并被<code>outState.putBundle(WINDOW_HIERARCHY_TAG, mWindow.saveHierarchyState())</code>记录下来，最终被onSaveInstanceState()存储，至于onSaveInstance的具体原理此处不做讨论，有兴趣可自行深挖。</p>
]]></content>
      <categories>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>ViewModel</tag>
      </tags>
  </entry>
  <entry>
    <title>WorkManager基本使用及源码分析(一) - 使用篇</title>
    <url>/2021/02/06/WorkManager%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%B8%80)%20-%20%E4%BD%BF%E7%94%A8%E7%AF%87/</url>
    <content><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="#zero">ZERO</a></li>
<li><a href="#part_use">1. 使用篇</a><ul>
<li><a href="#dependencies">1.1 声明依赖项</a></li>
<li><a href="#how_to_use">1.2 该如何使用？</a></li>
<li><a href="#task_type">1.3 WorkRequest类型</a></li>
<li><a href="#general_operation">1.4 一般操作</a><ul>
<li><a href="#task_listener">1.4.1 任务监听</a></li>
<li><a href="#transfer_data">1.4.2 传递数据</a></li>
<li><a href="#multiple_ask">1.4.3 多任务串联</a></li>
<li><a href="#UniqueWork">1.4.4 唯一任务</a></li>
<li><a href="#task_onstraint">1.4.5 任务约束</a></li>
<li><a href="#task_delay">1.4.6 任务延时</a></li>
<li><a href="#retry_rollback">1.4.7 重试和退避政策</a></li>
<li><a href="#work_tag">1.4.8 标记工作</a></li>
<li><a href="#work_cancel">1.4.9 取消工作</a></li>
</ul>
</li>
<li><a href="#attention">1.5 注意事项</a></li>
</ul>
</li>
</ul>
<hr>
<h3 id="ZERO"><a href="#ZERO" class="headerlink" title="ZERO"></a><a href="#zero">ZERO</a></h3><p><strong>Q:</strong> 什么是WorkManager？为什么要使用它？</p>
<blockquote>
<p>WorkManager 是一个 API，可供您轻松调度那些即使在退出应用或重启设备后仍应运行的可延期异步任务。WorkManager API 是一个适合用来替换先前的 Android 后台调度 API（包括 FirebaseJobDispatcher、GcmNetworkManager 和 JobScheduler）的组件，我们也建议您这样做。WorkManager 在其现代、一致的 API 中整合了其前身的功能，该 API 支持 API 级别 14，在开发时即考虑到了对电池续航的影响。</p>
</blockquote>
<p><strong>Q:</strong> 一定要使用WorkManager吗？</p>
<blockquote>
<p>如果您的应用以 Android 10（API 级别 29）或更高版本为目标平台，那么您对 FirebaseJobDispatcher 和 GcmNetworkManager API 的调用在搭载 Android Marshmallow (6.0) 及更高版本的设备上将无法正常工作。</p>
</blockquote>
<p>由上一问题可知，WorkManager是对 FirebaseJobDispatcher 和 GcmNetworkManager API 的替换，在一定情境下，显然更推荐您使用WorkManager。</p>
<hr>
<p>本章主要内容为WorkManager基本使用及源码分析，涉及WorkManager入门使用、源码分析两个部分，可根据个人需要选择部分内容阅读。</p>
<p>本章所述WorkManager相关内容均基于<code>WorkManager:2.4.0</code>;</p>
<p>本章涉及代码内容均使用<strong>Java</strong>语言编写，Java版本1.8；</p>
<p><a href="https://github.com/TinloneX">本章演示项目地址：https://github.com/TinloneX</a></p>
<p><a href="https://developer.android.google.cn/topic/libraries/architecture/workmanager">参考官方文档请点击这里</a></p>
<a id="more"></a>

<h3 id="1-使用篇"><a href="#1-使用篇" class="headerlink" title=" 1. 使用篇"></a><span id="part_use"> 1. 使用篇</h3><blockquote>
<p>WorkManager is a library used to enqueue deferrable work that is guaranteed to execute sometime after its Constraints are met. WorkManager allows observation of work status and the ability to create complex chains of work. </p>
</blockquote>
<p>WorkManager是一个用于将可延迟的工作放入队列的库，这些工作保证在满足其约束后的某个时间内执行。WorkManager允许观察工作状态，并能够创建复杂的工作链。</p>
<p><strong>注意：WorkManager 需要 compileSdk 版本 28 或更高版本。</strong></p>
<h4 id="1-1-声明依赖项"><a href="#1-1-声明依赖项" class="headerlink" title=" 1.1 声明依赖项"></a><span id="dependencies"> 1.1 声明依赖项</h4><p>如需添加 WorkManager 的依赖项，您必须将 Google Maven 代码库添加到项目中：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 项目根目录下build.gradle</span></span><br><span class="line"><span class="keyword">allprojects</span> &#123;</span><br><span class="line">    <span class="keyword">repositories</span> &#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在应用或模块的 build.gradle 文件中添加所需工件的依赖项：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app/build.gradle</span></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">  <span class="keyword">def</span> work_version = <span class="string">&quot;2.4.0&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// (Java only) 单纯使用java可引用此依赖</span></span><br><span class="line">    implementation <span class="string">&quot;androidx.work:work-runtime:$work_version&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Kotlin + coroutines 使用kotlin+协程可引用此依赖</span></span><br><span class="line">    implementation <span class="string">&quot;androidx.work:work-runtime-ktx:$work_version&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional - RxJava2 support 意图支持RxJava2的WorkManager可引用此依赖</span></span><br><span class="line">    implementation <span class="string">&quot;androidx.work:work-rxjava2:$work_version&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional - GCMNetworkManager support   @①</span></span><br><span class="line">    implementation <span class="string">&quot;androidx.work:work-gcm:$work_version&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional - Test helpers  测试工件</span></span><br><span class="line">    androidTestImplementation <span class="string">&quot;androidx.work:work-testing:$work_version&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>以上依赖均只需引用一个即可，此文档及代码均使用<code>androidx.work:work-runtime:2.4.0</code>。</li>
<li>特别的，① <blockquote>
<p>androidx.work:work-gcm:2.2.0 是一个新的 Maven 工件，当 Google Play 服务可用于 API 级别 22 或更低级别时，该工件支持将 GCMNetworkManager 用作调度程序。这是一个可选的依赖项，有助于在较旧的 API 版本上进行更稳定且性能更高的后台处理工作。如果您的应用使用 Google Play 服务，请将此依赖项添加到 gradle 文件，以自动获得 GCMNetworkManager 支持。如果 Play 服务不可用，WorkManager 将继续在旧款设备上回退到 AlarmManager。</p>
</blockquote>
</li>
</ul>
<p>下面我们将正式进入WorkManager使用篇</p>
<h4 id="1-2-该如何使用"><a href="#1-2-该如何使用" class="headerlink" title=" 1.2 该如何使用"></a><span id="how_to_use"> 1.2 该如何使用</h4><p>在讲解任务类型及其一般使用前，我们先了解WorkManager工作的流程：</p>
<ul>
<li><strong>谁来做</strong> 定义一个负责工作的<strong>Worker</strong><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SimpleWorker extends Worker &#123;</span><br><span class="line">@NonNull</span><br><span class="line">    @Override</span><br><span class="line">    public Result doWork() &#123;</span><br><span class="line">        &#x2F;&#x2F; return Result.failure(); &#x2F;&#x2F; 执行失败</span><br><span class="line">        &#x2F;&#x2F; return Result.retry();   &#x2F;&#x2F; 重试 </span><br><span class="line">        &#x2F;&#x2F; return Result.success(); &#x2F;&#x2F; 执行成功</span><br><span class="line">        return null;                &#x2F;&#x2F; 执行结束？</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
Worker是WorkManager最终实现任务的“工人”，它不用管会在什么实际执行任务，被安排怎样执行任务，只管埋头处理任务<code>doWork</code>并根据任务执行情况反馈任务结果<code>return Result</code>。</li>
</ul>
<p>Worker执行结果Result：表示任务状态，他一般有<code>failure</code>、<code>retry</code>、<code>success</code>三个状态，且<code>failure</code>、<code>success</code>可以携带数据<code>Data</code>，此处仅做了解，<a href="#periodic_task">传递数据</a>中将做具体说明。</p>
<ul>
<li><strong>怎么做</strong> 定义制定工作方案的<strong>WorkRequest</strong></li>
</ul>
<ol>
<li><strong>非重复性工作：</strong> 工人应该一次性把工作做掉<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OneTimeWorkRequest workRequest1 = OneTimeWorkRequest.from(SimpleWorker.class);</span><br></pre></td></tr></table></figure></li>
<li><strong>周期任务：</strong> 工人应该每隔多久做一次工作</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PeriodicWorkRequest request &#x3D; new PeriodicWorkRequest</span><br><span class="line">               .Builder(SimpleWorker.class, 16, TimeUnit.MINUTES).build();</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> 关于周期任务有一个<strong>霸王条款：</strong></p>
<blockquote>
<p>注意：可以定义的最短重复间隔是 15 分钟（与 JobScheduler API 相同）。</p>
</blockquote>
<blockquote>
<p>如果您的工作的性质致使其对运行时间敏感，您可以将 PeriodicWorkRequest 配置为在每个时间间隔的灵活时间段内运行。</p>
</blockquote>
<p><a href="https://developer.android.google.cn/topic/libraries/architecture/workmanager/how-to/define-work#flexible_run_intervals">点此获取“灵活的运行间隔”说明</a></p>
<ul>
<li><strong>谁来管</strong> 工作方案谁来审批谁来管理<strong>WorkManager</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WorkManager.getInstance(myContext).enqueue(myWorkRequest);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>自此，通过Worker + WorkRequest + WorkManager就可以完成一次最简工作的调用流程，其中<strong>Worker执行工作，WorkRequest封装工作，WorkManager管理工作</strong>。</p>
<h4 id="1-3-WorkRequest类型"><a href="#1-3-WorkRequest类型" class="headerlink" title=" 1.3 WorkRequest类型"></a><span id="task_type"> 1.3 WorkRequest类型</h4><p>WorkRequest 目前有两个子类，分别为单次执行任务 <code>OneTimeWorkRequest</code>和周期执行任务 <code>PeriodicWorkRequest</code>. 他们的主要区别是任务执行方案不同导致的状态变化不同。</p>
<p><a href="https://github.com/TinloneX/WorkManagerDemo/blob/main/images/OneTimeWork_state.png">简单单次执行任务 OneTimeWorkRequest 工作状态图</a>：</p>
<p><img src="https://github.com/TinloneX/WorkManagerDemo/blob/main/images/OneTimeWork_state.png" alt="OneTimeWork_STATE"></p>
<blockquote>
<p>对于 one-time 工作请求，工作的初始状态为 ENQUEUED。</p>
</blockquote>
<blockquote>
<p>在 ENQUEUED 状态下，您的工作会在满足其 Constraints 和初始延迟计时要求后立即运行。接下来，该工作会转为 RUNNING 状态，然后可能会根据工作的结果转为 SUCCEEDED、FAILED 状态；或者，如果结果是 retry，它可能会回到 ENQUEUED 状态。在此过程中，随时都可以取消工作，取消后工作将进入 CANCELLED 状态。</p>
</blockquote>
<p><a href="https://github.com/TinloneX/WorkManagerDemo/blob/main/images/PeriodicWork_state.png">周期执行任务 PeriodicWorkRequest 工作状态图</a>：</p>
<p><img src="https://github.com/TinloneX/WorkManagerDemo/blob/main/images/PeriodicWork_state.png" alt="PeriodicWork_STATE"></p>
<p>周期性工作的初始状态为 ENQUEUED，正常执行情况下，周期性工作的状态在ENQUEUED ↔RUNNING之间交替，知道任务被取消时，状态为CANCELLED。</p>
<blockquote>
<p>成功和失败状态仅适用于一次性工作和链式工作。定期工作只有一个终止状态 CANCELLED。这是因为定期工作永远不会结束。每次运行后，无论结果如何，系统都会重新对其进行调度。</p>
</blockquote>
<p>若工作状态图无法展示，参见<a href="https://developer.android.google.cn/topic/libraries/architecture/workmanager/how-to/states-and-observation">Android-Developers/WorkManager</a>。</p>
<h4 id="1-4-一般操作"><a href="#1-4-一般操作" class="headerlink" title=" 1.4 一般操作"></a><span id="general_operation"> 1.4 一般操作</h4><p>上<a href="#how_to_use">1.2</a>中，描述了最简工作的编写，那么除了这些基本的<strong>谁来做</strong>、<strong>怎么做</strong>、<strong>谁来管</strong>外，WorkManager还有哪些可以操作的点呢？</p>
<p><strong><span id="task_listener">1.4.1 任务监听</strong> （怎么关注任务进度）</p>
<p>上面<a href="#task_type">1.3</a>中介绍了的状态，我们该如何监听这些状态呢？</p>
<p>方式1 ：</p>
<p><em>注：本文及案例未详尽的实践此方式, 此小节内容均来自<a href="https://developer.android.google.cn/topic/libraries/architecture/workmanager/how-to/managing-work#observing">官方文档</a></em></p>
<blockquote>
<p>在将工作加入队列后，您可以随时按其 name、id 或与其关联的 tag 在 WorkManager 中进行查询，以检查其状态</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; by id</span><br><span class="line">workManager.getWorkInfoById(syncWorker.id); &#x2F;&#x2F; ListenableFuture&lt;WorkInfo&gt;</span><br><span class="line">&#x2F;&#x2F; by name</span><br><span class="line">workManager.getWorkInfosForUniqueWork(&quot;sync&quot;); &#x2F;&#x2F; ListenableFuture&lt;List&lt;WorkInfo&gt;&gt;</span><br><span class="line">&#x2F;&#x2F; by tag</span><br><span class="line">workManager.getWorkInfosByTag(&quot;syncTag&quot;); &#x2F;&#x2F; ListenableFuture&lt;List&lt;WorkInfo&gt;&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 此处尝试使用此方式监听，可监听到部分状态</span><br><span class="line">WorkManager.getInstance(this).getWorkInfoById(workRequest.getId()).addListener(() -&gt; Utils.log(future), Runnable::run);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>该查询会返回 WorkInfo 对象的 ListenableFuture，该值包含工作的 id、其标记、其当前的 State 以及通过 Result.success(outputData) 设置的任何输出数据。</p>
</blockquote>
<p>方式2：</p>
<blockquote>
<p>利用每个方法的 LiveData 变种，您可以通过注册监听器来观察 WorkInfo 的变化。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WorkManager.getInstance(context)</span><br><span class="line">            .getWorkInfoByIdLiveData(workRequest.getId())</span><br><span class="line">            .observe(lifecycleOwner, new Observer&lt;WorkInfo&gt;() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void onChanged(WorkInfo workInfo) &#123;</span><br><span class="line">                    &#x2F;&#x2F; workInfo.getState() 可获取任务状态</span><br><span class="line">                    Utils.log(workInfo.getState());</span><br><span class="line">                    &#x2F;&#x2F; workInfo.getOutputData() 可获取任务传递的数据（详见1.4.2）</span><br><span class="line">                    if (workInfo.getState().isFinished()) &#123;</span><br><span class="line">                        Utils.log(workInfo.getOutputData());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure>
<p>复杂的工作查询：</p>
<p> <em><a href="https://developer.android.google.cn/topic/libraries/architecture/workmanager/how-to/managing-work#complex-queries">官方文档</a></em></p>
<blockquote>
<p>WorkManager 2.4.0 及更高版本支持使用 WorkQuery 对象对已加入队列的作业进行复杂查询。WorkQuery 支持按工作的标记、状态和唯一工作名称的组合进行查询。</p>
</blockquote>
<blockquote>
<p>以下示例说明了如何查找带有“syncTag”标记、处于 FAILED 或 CANCELLED 状态，且唯一工作名称为“preProcess”或“sync”的所有工作。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">WorkQuery workQuery = WorkQuery.Builder</span><br><span class="line">       .fromTags(Arrays.asList(<span class="string">&quot;syncTag&quot;</span>))</span><br><span class="line">       .addStates(Arrays.asList(WorkInfo.State.FAILED, WorkInfo.State.CANCELLED))</span><br><span class="line">       .addUniqueWorkNames(Arrays.asList(<span class="string">&quot;preProcess&quot;</span>, <span class="string">&quot;sync&quot;</span>)</span><br><span class="line">     )</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">ListenableFuture&lt;List&lt;WorkInfo&gt;&gt; workInfos = workManager.getWorkInfos(workQuery);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注：经实践，此方法获取的是<code>workManager.getWorkInfos(workQuery)</code>调用时任务的状态，若想使用此方法持续观察任务状态，建议使用以下方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此处应将Utils.executor()视作 ThreadPoolExecutor</span></span><br><span class="line">Utils.executor().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    ListenableFuture&lt;List&lt;WorkInfo&gt;&gt; workInfos = WorkManager.getInstance(MainActivity.<span class="keyword">this</span>)</span><br><span class="line">                            .getWorkInfos(workQuery);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        List&lt;WorkInfo&gt; infos = workInfos.get();</span><br><span class="line">                        Utils.log(infos);</span><br><span class="line">                        <span class="keyword">for</span> (WorkInfo info : infos) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (info.getState() == WorkInfo.State.SUCCEEDED ||</span><br><span class="line">                                    info.getState() == WorkInfo.State.CANCELLED) &#123;</span><br><span class="line">                                <span class="keyword">return</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        Utils.log(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<p>附：如需了解<strong>如何观察工作器的中间进度</strong>，可<a href="https://developer.android.google.cn/topic/libraries/architecture/workmanager/how-to/intermediate-progress#observing_progress">点击此处查看</a></p>
<p>特别的，我们可以借助AndroidStudio看板观察WorkManager状态。</p>
<ul>
<li>AndroidStudio白狐之前的版本可使用DataBase Inspector 观察 androidx.work.workdb数据库中WorkSpec表获取WorkRequest信息；</li>
<li>AndroidStudio白狐版则可直接使用WorkManager Inspector查看WorkRequest信息。</li>
</ul>
<p><strong><span id="transfer_data">1.4.2 传递数据</strong></p>
<p>在一些业务场景下，我们需要向任务中传递数据，可以使用<code>androidx.work.Data</code>向WorkRequest中添加数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建需传递的数据</span><br><span class="line">Data data &#x3D; new Data.Builder().putString(&quot;message&quot;, &quot;MainActivity&quot;).build();</span><br><span class="line">&#x2F;&#x2F; 单次执行任务</span><br><span class="line">OneTimeWorkRequest request1 &#x3D; new OneTimeWorkRequest.Builder(Task4DataWorker.class)</span><br><span class="line">        &#x2F;&#x2F; 向WorkRequest中添加数据</span><br><span class="line">        .setInputData(data).build();</span><br><span class="line">&#x2F;&#x2F; 将任务加入队列</span><br><span class="line">WorkManager.getInstance(this).enqueue(request1);</span><br></pre></td></tr></table></figure>
<p>需要注意的是，由Data源码可知，此处传递数据仅支持基础数据类型及其封装、String以及上述类型的数组：</p>
<blockquote>
<p>Puts an input key-value pair into the Builder. Valid types are: Boolean, Integer,  Long, Float, Double, String, and array versions of each of those types. Invalid types throw an {@link IllegalArgumentException}.</p>
</blockquote>
<p><em>当然的，有没有想使用反射向Data中的mValues注入其他类型呢？<code>Map<String, Object> mValues = new HashMap<>();</code>, 期待你的尝试！</em></p>
<p>有传递数据自然有获取数据，我们可以Worker中通过<code>getInputData()</code>获取<br>传入的Data对象，通过Data获取传入的值，也可以通过Data和Result将值传递给观察者。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Task4DataWorker extends Worker &#123;</span><br><span class="line"></span><br><span class="line">    public Task4DataWorker(@NonNull Context context, @NonNull WorkerParameters workerParams) &#123;</span><br><span class="line">        super(context, workerParams);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressLint(&quot;RestrictedApi&quot;)</span><br><span class="line">    @NonNull</span><br><span class="line">    @Override</span><br><span class="line">    public Result doWork() &#123;</span><br><span class="line">        String message &#x3D; getInputData().getString(&quot;message&quot;);</span><br><span class="line">        Data myMsg &#x3D; new Data.Builder().putString(&quot;message&quot;, &quot;message from Worker&quot;).build();</span><br><span class="line">        return new Result.Success(myMsg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而从Worker中传出的Data则可在WorkRequest的工作状态WorkInfo中取得：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WorkManager.getInstance(context)</span><br><span class="line">               .getWorkInfoByIdLiveData(workRequest.getId())</span><br><span class="line">               .observe(context, workInfo -&gt; &#123;</span><br><span class="line">                   if (workInfo!&#x3D;null)&#123;</span><br><span class="line">                       if (workInfo.getState().isFinished()) &#123;</span><br><span class="line">                           String message &#x3D; workInfo.getOutputData().getString(&quot;message&quot;);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;);</span><br></pre></td></tr></table></figure>
<p><strong><span id="multiple_ask">1.4.3 多任务串联</strong></p>
<p>除一般的单一任务的场景外，我们面对的业务往往也要处理多个任务的场景，此时我们可以串联多个任务，也可以将多个任务编组成任务链去使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WorkManager.getInstance(this).beginWith(workRequest2)</span><br><span class="line">                .then(workRequest3)</span><br><span class="line">                .then(workRequest4)</span><br><span class="line">                .enqueue();</span><br><span class="line">&#x2F;&#x2F; or</span><br><span class="line">WorkContinuation continuation &#x3D; WorkManager.getInstance(this)</span><br><span class="line">                .beginWith(workRequest2)</span><br><span class="line">                .then(workRequest3)</span><br><span class="line">                .then(workRequest4);</span><br><span class="line"></span><br><span class="line">continuation.then(workRequest).enqueue();</span><br></pre></td></tr></table></figure>
<p>特别的，如需了解<strong>任务链的高级用法及合并器</strong>相关内容，<a href="https://developer.android.google.cn/topic/libraries/architecture/workmanager/how-to/chain-work#input-mergers">请点击此处查看官方文档</a>，其中关于<a href="https://developer.android.google.cn/topic/libraries/architecture/workmanager/how-to/chain-work#work-statuses">链接和工作状态</a>的说明图文并茂，更易于理解。</p>
<p><strong><span id="UniqueWork">1.4.4 唯一任务</strong></p>
<blockquote>
<p>唯一工作是一个很实用的概念，可确保同一时刻只有一个具有特定名称的工作实例。与 ID 不同的是，唯一名称是人类可读的，由开发者指定，而不是由 WorkManager 自动生成。与标记不同，唯一名称仅与一个工作实例相关联。</p>
</blockquote>
<blockquote>
<p>唯一工作既可用于一次性工作，也可用于定期工作。您可以通过调用以下方法之一创建唯一工作序列，具体取决于您是调度重复工作还是一次性工作。WorkManager.enqueueUniqueWork()（用于一次性工作）<br>    WorkManager.enqueueUniquePeriodicWork()（用于定期工作）</p>
</blockquote>
<p>这两种方法都接受 3 个参数：</p>
<pre><code>uniqueWorkName - 用于唯一标识工作请求的 String。
existingWorkPolicy - 此 enum 可告知 WorkManager：如果已有使用该名称且尚未完成的唯一工作链，应执行什么操作。如需了解详情，请参阅冲突解决政策。
work - 要调度的 WorkRequest。
</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OneTimeWorkRequest workRequest &#x3D; new OneTimeWorkRequest.Builder(SimpleWorker2.class).build();</span><br><span class="line">OneTimeWorkRequest workRequest2 &#x3D; new OneTimeWorkRequest.Builder(SimpleWorker2.class).build();</span><br><span class="line"></span><br><span class="line">WorkManager.getInstance(this).beginUniqueWork(&quot;SimpleWorker&quot;,</span><br><span class="line">        ExistingWorkPolicy.REPLACE, workRequest)</span><br><span class="line">&#x2F;&#x2F;      ExistingWorkPolicy.APPEND, workRequest)</span><br><span class="line">&#x2F;&#x2F;      ExistingWorkPolicy.KEEP, workRequest)</span><br><span class="line">        .then(workRequest2)</span><br><span class="line">&#x2F;&#x2F;      .then(workRequest)</span><br><span class="line">        .enqueue();</span><br></pre></td></tr></table></figure>
<p>此处定义的唯一，仅在任务正在执行且出现相同<code>uniqueWorkName</code>名称时，existingWorkPolicy才生效，无法影响已结束的同名任务（此同名仅与uniqueWorkName有关）。<br>以定义两个相同<code>uniqueWorkName</code>的WorkRequest为例，来观察existingWorkPolicy值的作用及影响：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 若发现名为“SimpleWorker”的任务，则使用此链替换目标后续操作</span><br><span class="line">&#x2F;&#x2F; 任务链 A</span><br><span class="line">WorkManager.getInstance(this).beginUniqueWork(&quot;SimpleWorker&quot;,</span><br><span class="line">        ExistingWorkPolicy.REPLACE, workRequest)</span><br><span class="line">        .then(request3)</span><br><span class="line">        .enqueue();</span><br><span class="line">&#x2F;&#x2F; 若发现名为“SimpleWorker”的任务，则保留目标的原操作，此链不执行</span><br><span class="line">&#x2F;&#x2F; 任务链 B</span><br><span class="line">WorkManager.getInstance(this).beginUniqueWork(&quot;SimpleWorker&quot;,</span><br><span class="line">        ExistingWorkPolicy.KEEP, workRequest5)</span><br><span class="line">        .then(request2)</span><br><span class="line">        .enqueue();</span><br></pre></td></tr></table></figure>
<p>上述两个任务链，若先执行A再执行B，此时效果为：</p>
<pre><code>workUnique2 start   // 任务链A触发
workUnique2 end     // 任务链A触发完毕
doWork start: SimpleWorker  // 任务链A耗时任务workRequest开始执行
workUnique start    // 任务链B触发
workUnique end      // 任务链B触发完毕
doWork end: SimpleWorker // 任务链A耗时任务workRequest执行完毕
doWork: SimpleWorker3   // 任务链A执行后续任务request3
任务链B并未执行
</code></pre>
<p>上述两个任务链，若先执行B再执行A，此时效果为：</p>
<pre><code>workUnique start    // 任务链B触发
workUnique end      // 任务链B触发完毕
doWork start: SimpleWorker5 // 任务链B耗时任务workRequest5开始执行
workUnique2 start   // 任务链A触发
workUnique2 end     // 任务链A触发完毕
doWork start: SimpleWorker  // 任务链A耗时任务workRequest开始执行
doWork end: SimpleWorker5   // 任务链B耗时任务workRequest5执行完毕
doWork end: SimpleWorker    // 任务链A耗时任务workRequest执行完毕
doWork: SimpleWorker3       // 任务链A执行后续任务request3
任务链B耗时任务被执行但后续操作被同名任务链A覆盖
</code></pre>
<p>同理，我们将任务链A的冲突方案分别定义为<code>ExistingWorkPolicy.APPEND</code>、<code>ExistingWorkPolicy.APPEND_OR_REPLACE</code>，观察执行情况，得出如下结论：</p>
<ul>
<li>ExistingWorkPolicy.REPLACE 会替换正在执行的同名任务重新执行，并使用自己的任务链覆盖原任务链；</li>
<li>ExistingWorkPolicy.KEEP 会保持原任务链执行，自己不执行；</li>
<li>ExistingWorkPolicy.APPEND 会等待原任务链同名任务及后续任务执行完毕，才执行自己的任务链；</li>
<li>ExistingWorkPolicy.APPEND_OR_REPLACE 若原任务链及新任务链未被取消或中断，则<br>与APPEND性质一致, 其他情况：<blockquote>
<p>If there is existing pending (uncompleted) work with the same unique name, append the newly-specified work as the child of all the leaves of that work sequence. Otherwise, insert the newly-specified work as the start of a new sequence. Note: If there are failed or cancelled prerequisites, these prerequisites are dropped and the newly-specified work is the start of a new sequence.如果存在具有相同唯一名称的未决(未完成)工作，则将新指定的工作附加为该工作序列的所有叶节点的子节点。否则，插入新指定的工作作为新序列的开始。注意:如果有失败或取消的先决条件，这些先决条件将被删除，而新指定的工作将是一个新序列的开始。</p>
</blockquote>
</li>
</ul>
<p><strong><span id="task_onstraint">1.4.5 任务约束</strong></p>
<p><a href="https://developer.android.google.cn/topic/libraries/architecture/workmanager/how-to/define-work#work-constraints">参见文档</a></p>
<blockquote>
<p>Constraints可确保将工作延迟到满足最佳条件时运行。以下约束适用于 WorkManager。</p>
</blockquote>
<pre><code>NetworkType     约束运行工作所需的网络类型。例如 Wi-Fi (UNMETERED)。
BatteryNotLow     如果设置为 true，那么当设备处于“电量不足模式”时，工作不会运行。
RequiresCharging     如果设置为 true，那么工作只能在设备充电时运行。
DeviceIdle     如果设置为 true，则要求用户的设备必须处于空闲状态，才能运行工作。如果您要运行批量操作，否则可能会降低用户设备上正在积极运行的其他应用的性能，建议您使用此约束。
StorageNotLow     如果设置为 true，那么当用户设备上的存储空间不足时，工作不会运行
</code></pre>
<p>注意：<br>实际测试中，使用Android 6.0~11.0等一系列版本的模拟器测试发现</p>
<ul>
<li>9.0以下版本手机，不论应用是否在前台，进程是否存活，只要满足约束条件任务就会尽快执行；</li>
<li>9.0及以上版本手机，应用进程DEAD状态，在符合约束条件时任务也不一定会尽快执行，甚至即使进入App也不一定能立马得到执行，除非有新的WorkRequest入队。</li>
</ul>
<p><strong><span id="task_delay">1.4.6 任务延时</strong></p>
<p><a href="https://developer.android.google.cn/topic/libraries/architecture/workmanager/how-to/define-work#delayed_work">参见文档</a></p>
<blockquote>
<p>如果工作没有约束，或者当工作加入队列时所有约束都得到了满足，那么系统可能会选择立即运行该工作。如果您不希望工作立即运行，可以将工作指定为在经过一段最短初始延迟时间后再启动。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WorkRequest myWorkRequest &#x3D;</span><br><span class="line">      new OneTimeWorkRequest.Builder(MyWork.class)</span><br><span class="line">               .setInitialDelay(10, TimeUnit.MINUTES)</span><br><span class="line">               .build();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：执行工作器的确切时间还取决于 WorkRequest 中使用的约束和系统优化方式。WorkManager 经过设计，能够在满足这些约束的情况下提供可能的最佳行为。<br>定期工作只有首次运行时会延迟</p>
</blockquote>
<p><strong><span id="retry_rollback">1.4.7 重试和退避政策</strong></p>
<p><a href="https://developer.android.google.cn/topic/libraries/architecture/workmanager/how-to/define-work#retry_and_backoff_policy">参见文档</a></p>
<p>若Worker返回结果Result.retry()时，触发重试退避政策，即下次调度Worker应在多长时间以后，支持设置退避时间基数和基数递增方式，递增方式目前支持线性<code>LINEAR</code>和指数<code>EXPONENTIAL</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OneTimeWorkRequest workRequest &#x3D; new OneTimeWorkRequest.Builder(RetryWorker.class)</span><br><span class="line">                .setBackoffCriteria(BackoffPolicy.LINEAR,</span><br><span class="line">                        OneTimeWorkRequest.MIN_BACKOFF_MILLIS,</span><br><span class="line">                        TimeUnit.MILLISECONDS)</span><br><span class="line">                .build();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：退避延迟时间不精确，在两次重试之间可能会有几秒钟的差异，但绝不会低于配置中指定的初始退避延迟时间。</p>
</blockquote>
<p>退避时间在满足执行条件情况下也并不会完全精确，若不满足执行条件则会等待其条件满足：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 无约束</span><br><span class="line">间隔时间(ms): 10109 </span><br><span class="line">间隔时间(ms): 20094</span><br><span class="line">间隔时间(ms): 30093</span><br><span class="line">...</span><br><span class="line">&#x2F;&#x2F; 约束：计费(量)网络环境下</span><br><span class="line">间隔时间(ms): 10121</span><br><span class="line">间隔时间(ms): 20143</span><br><span class="line">间隔时间(ms): 30103</span><br><span class="line">&#x2F;&#x2F; 关闭wifi喝个茶再连接wifi</span><br><span class="line">间隔时间(ms): 146521</span><br><span class="line">间隔时间(ms): 50132</span><br></pre></td></tr></table></figure>
<p><strong><span id="work_tag">1.4.8 标记工作</strong></p>
<p><a href="https://developer.android.google.cn/topic/libraries/architecture/workmanager/how-to/define-work#tag_work">参见文档</a></p>
<p>你可以为WorkRequest添加tag，从而使得你可以通过<code>WorkManager.getWorkInfosByTag(String)</code>获取WorkRequest的工作状态WorkInfo，你也可以直接通过<code>WorkManager.cancelAllWorkByTag(String)</code>取消对应标记的所有WorkRequest.</p>
<p>由WorkRequest中关于tag的定义<code>Set<String> mTags</code>可知，你可以为WorkRequest定义多个标记，当然的，你也可以为多个WorkRequest定义同一个标记用以统一管理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WorkRequest request &#x3D;</span><br><span class="line">       new OneTimeWorkRequest.Builder(SimpleWorker.class)</span><br><span class="line">       .addTag(&quot;TAG&quot;)</span><br><span class="line">       .build();</span><br><span class="line">&#x2F;&#x2F; 根据tag取消任务</span><br><span class="line">WorkManager.getInstance(this).cancelAllWorkByTag(&quot;TAG&quot;);</span><br><span class="line">&#x2F;&#x2F; 根据tag查找任务状态</span><br><span class="line">WorkManager.getInstance(this).getWorkInfosByTag(&quot;TAG&quot;);</span><br></pre></td></tr></table></figure>
<p><strong><span id="work_cancel">1.4.9 取消工作</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; by id</span><br><span class="line">workManager.cancelWorkById(syncWorker.id);</span><br><span class="line">&#x2F;&#x2F; by name</span><br><span class="line">workManager.cancelUniqueWork(&quot;sync&quot;);</span><br><span class="line">&#x2F;&#x2F; by tag</span><br><span class="line">workManager.cancelAllWorkByTag(&quot;syncTag&quot;);</span><br></pre></td></tr></table></figure>
<p><a href="https://developer.android.google.cn/topic/libraries/architecture/workmanager/how-to/managing-work#stop-worker">点此了解“停止正在运行的工作器”的相关内容</a></p>
<h4 id="1-5-注意事项"><a href="#1-5-注意事项" class="headerlink" title=" 1.5 注意事项"></a><span id="attention"> 1.5 注意事项</h4><p>这里我们总结一下使用WorkManager的一些小Tips。</p>
<ul>
<li>PeriodicWorkRequest周期任务可以定义的最短重复间隔是 15 分钟（与 JobScheduler API 相同）</li>
<li>延迟工作：执行工作器的确切时间还取决于 WorkRequest 中使用的约束和系统优化方式。WorkManager 经过设计，能够在满足这些约束的情况下提供可能的最佳行为。</li>
<li>退避延迟时间不精确，在两次重试之间可能会有几秒钟的差异，但绝不会低于配置中指定的初始退避延迟时间。</li>
<li>cancelAllWorkByTag(String) 会取消具有给定标记的所有工作。</li>
<li>WorkRequest保证一定执行，但不保证一定在什么时间执行。</li>
</ul>
<hr>
<p>引用文献：</p>
<ol>
<li><a href="https://developer.android.google.cn/topic/libraries/architecture/workmanager">WorkManager官方文档</a></li>
</ol>
<h4 id="源码篇正在奋力码字中。。。"><a href="#源码篇正在奋力码字中。。。" class="headerlink" title="源码篇正在奋力码字中。。。"></a>源码篇正在奋力码字中。。。</h4>]]></content>
      <categories>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>WorkManager</tag>
      </tags>
  </entry>
  <entry>
    <title>WorkManager基本使用及源码分析(七) - BroadcastReceiver</title>
    <url>/2021/02/15/WorkManager%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%B8%83)%20-%20BroadcastReceiver/</url>
    <content><![CDATA[<ul>
<li><a href="#source_broadcast">源码篇 - 广播接收者</a></li>
<li><a href="#ForceStopRunnable">ForceStopRunnable</a><ul>
<li><a href="#fsr_BroadcastReceiver">BroadcastReceiver</a></li>
</ul>
</li>
<li><a href="#ConstraintProxy">ConstraintProxy</a><ul>
<li><a href="#BatteryNotLowProxy">BatteryNotLowProxy</a></li>
<li><a href="#BatteryChargingProxy">BatteryChargingProxy</a></li>
<li><a href="#StorageNotLowProxy">StorageNotLowProxy</a></li>
<li><a href="#NetworkStateProxy">NetworkStateProxy</a></li>
</ul>
</li>
<li><a href="#ConstraintProxyUpdateReceiver">ConstraintProxyUpdateReceiver</a></li>
<li><a href="#RescheduleReceiver">RescheduleReceiver</a></li>
<li><a href="#DiagnosticsReceiver">DiagnosticsReceiver</a></li>
</ul>
<h3 id="源码篇-广播接收者"><a href="#源码篇-广播接收者" class="headerlink" title=" 源码篇 - 广播接收者"></a><span id="source_broadcast"> 源码篇 - 广播接收者</h3><p>此篇将重点介绍WorkManager使用的重要组件:广播接收者,主要涉及意外停止监听广播<code>ForceStopRunnable.BroadcastReceiver</code>、约束状态监听广播<code>ConstraintProxy.*</code>、启动重新规划服务的广播<code>RescheduleReceiver</code>、代理约束更新广播<code>ConstraintProxyUpdateReceiver</code>、测试诊断广播<code>DiagnosticsReceiver</code>。此类组件为WorkManager稳定运行、重新规划、约束更新提供了支持。</p>
<a id="more"></a>

<h4 id="ForceStopRunnable"><a href="#ForceStopRunnable" class="headerlink" title=" ForceStopRunnable"></a><span id="ForceStopRunnable"> ForceStopRunnable</h4><blockquote>
<p>WorkManager is restarted after an app was force stopped. Alarms and Jobs get cancelled when an application is force-stopped. To reschedule, we create a pending alarm that will not survive force stops.</p>
</blockquote>
<p>强制停止应用程序后，<code>WorkManager</code>将重新启动。当应用被强制停止时，<code>Alarms</code>和<code>Jobs</code>将被取消。为了重新安排，我们要创建一个无法通过强制停止的<code>Alarm</code>。</p>
<p>在介绍<code>ForceStopRunnable.BroadcastReceiver</code>前,我们先简单看一下它的外部类<code>ForceStopRunnable</code>。</p>
<p><code>ForceStopRunnable</code>是一个Runnable对象，核心方法是<code>run</code>, 其在<code>WorkManager</code>初始化时调用<code>WorkManagerImpl.internalInit()</code>, 构造并调用了<code>ForceStopRunnable.run()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果需要，将数据库迁移到不备份的目录。</span></span><br><span class="line">    WorkDatabasePathHelper.migrateDatabase(mContext);</span><br><span class="line">    <span class="comment">// 清除属于WorkManager的无效作业，以及由于应用程序崩溃(运行状态)而可能被中断的作业。</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> needsScheduling = cleanUp();</span><br><span class="line">        <span class="keyword">if</span> (shouldRescheduleWorkers()) &#123;</span><br><span class="line">            mWorkManager.rescheduleEligibleWork();</span><br><span class="line">            <span class="comment">// 将WorkManager标记为已迁移。</span></span><br><span class="line">            mWorkManager.getPreferenceUtils().setNeedsReschedule(<span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isForceStopped()) &#123;</span><br><span class="line">            <span class="comment">// 异常退出，重新规划任务</span></span><br><span class="line">            mWorkManager.rescheduleEligibleWork();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (needsScheduling) &#123;</span><br><span class="line">           <span class="comment">// 发现未完成任务，规划它们</span></span><br><span class="line">            Schedulers.schedule(</span><br><span class="line">                    mWorkManager.getConfiguration(),</span><br><span class="line">                    mWorkManager.getWorkDatabase(),</span><br><span class="line">                    mWorkManager.getSchedulers());</span><br><span class="line">        &#125;</span><br><span class="line">        mWorkManager.onForceStopRunnableCompleted();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLiteCantOpenDatabaseException</span><br><span class="line">            | SQLiteDatabaseCorruptException</span><br><span class="line">            | SQLiteAccessPermException exception) &#123;</span><br><span class="line">        <span class="comment">// ForceStopRunnable通常是访问数据库(或应用程序的内部数据目录)的第一件事。</span></span><br><span class="line">        <span class="comment">// 这意味着奇怪的PackageManager错误被归咎于ForceStopRunnable，这是不幸的。</span></span><br><span class="line">        <span class="comment">// 这为开发人员提供了更好的错误消息。</span></span><br><span class="line">        String message =</span><br><span class="line">                <span class="string">&quot;The file system on the device is in a bad state. WorkManager cannot access &quot;</span></span><br><span class="line">                        + <span class="string">&quot;the app&#x27;s internal data store.&quot;</span>;</span><br><span class="line">        Logger.get().error(TAG, message, exception);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(message, exception);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们发现<code>ForceStopRunable</code>主要职责是处理异常中断后对WorkManager中任务进行清理和重新规划,<code>run()</code>主要干了3件事:</p>
<ul>
<li>如果需要，将数据库迁移到不备份的目录</li>
<li>取消无效的JobScheduler作业/重新调度以前正在运行的作业</li>
<li>针对异常中断时WorkManager的状态进行不同的调度操作</li>
</ul>
<p>那么他是如何判断是否是强制中断的呢，我们可以看下强制中断判断代码<code>isForceStopped()</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@VisibleForTesting</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isForceStopped</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当应用程序在Eclair MR1强制停止启动时，Alarm被取消。</span></span><br><span class="line">    <span class="comment">// 在N-MR1中引入了强制停止作业的取消(SDK 25)。</span></span><br><span class="line">    <span class="comment">// 尽管API 23、24可能是安全的，但oem可能会选择采用不同的方法。</span></span><br><span class="line">    PendingIntent pendingIntent = getPendingIntent(mContext, FLAG_NO_CREATE);</span><br><span class="line">    <span class="keyword">if</span> (pendingIntent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        setAlarm(mContext);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过判断闹钟广播是否存在来确定应用是否被强行停止，若不存在即闹钟Alarm被取消即是强制中断，此时将重新设置一个闹钟Alarm;</p>
<p>让我们来看看上文中的<code>ForceStopRunnable.BroadcastReceiver</code>闹钟广播。</p>
<h5 id="BroadcastReceiver"><a href="#BroadcastReceiver" class="headerlink" title=" BroadcastReceiver"></a><span id="BroadcastReceiver"> BroadcastReceiver</h5><blockquote>
<p>A {@link android.content.BroadcastReceiver} which takes care of recreating the long lived alarm which helps track force stops for an application.  This is the target of the alarm set by ForceStopRunnable in {@link #setAlarm(Context)}. 一个{@link android.content.BroadcastReceiver}负责重新创建长寿命的Alarm，这有助于跟踪应用程序的强制停止。这是在{@link #setAlarm(Context)}中由forceoprunnable设置的Alarm目标。</p>
</blockquote>
<p>从描述可知，此广播的主要目的是负责创建长期存活的闹钟，用以追踪应用程序的强制停止。</p>
<p>其代码相对简单，若收到action为<code>ACTION_FORCE_STOP_RESCHEDULE</code>的广播，则设置一个长达十年的可唤醒设备的闹钟，然后再来一次（发送action为<code>ACTION_FORCE_STOP_RESCHEDULE</code>的广播）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ForceStopRunnable</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> PendingIntent <span class="title">getPendingIntent</span><span class="params">(Context context, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    Intent intent = getIntent(context);</span><br><span class="line">    <span class="comment">// 发送广播的PendingIntent</span></span><br><span class="line">    <span class="keyword">return</span> PendingIntent.getBroadcast(context, ALARM_ID, intent, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@VisibleForTesting</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Intent <span class="title">getIntent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">    intent.setComponent(<span class="keyword">new</span> ComponentName(context, ForceStopRunnable.BroadcastReceiver.class));</span><br><span class="line">    <span class="comment">// 广播intent</span></span><br><span class="line">    intent.setAction(ACTION_FORCE_STOP_RESCHEDULE);</span><br><span class="line">    <span class="keyword">return</span> intent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setAlarm</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    AlarmManager alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);</span><br><span class="line">    <span class="comment">//使用FLAG_UPDATE_CURRENT，因为我们只需要这个Alarm的一次实例</span></span><br><span class="line">    PendingIntent pendingIntent = getPendingIntent(context, FLAG_UPDATE_CURRENT);</span><br><span class="line">    <span class="comment">// 设置执行时间为十年</span></span><br><span class="line">    <span class="keyword">long</span> triggerAt = System.currentTimeMillis() + TEN_YEARS;</span><br><span class="line">    <span class="keyword">if</span> (alarmManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">19</span>) &#123;</span><br><span class="line">            <span class="comment">// RTC_WAKEUP：绝对时间可唤醒类型，十年后，干啥</span></span><br><span class="line">            alarmManager.setExact(RTC_WAKEUP, triggerAt, pendingIntent);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            alarmManager.set(RTC_WAKEUP, triggerAt, pendingIntent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BroadcastReceiver</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">content</span>.<span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Our alarm somehow got triggered, so make sure we reschedule it.  This should really never happen because we set it so far in the future.</span></span><br><span class="line">        <span class="comment">// 我们的闹钟不知怎么被触发了，所以一定要重新安排时间。这是不应该发生的，因为我们将它设置在遥远的未来（嘿，十年后再见）。</span></span><br><span class="line">        <span class="keyword">if</span> (intent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            String action = intent.getAction();</span><br><span class="line">            <span class="keyword">if</span> (ACTION_FORCE_STOP_RESCHEDULE.equals(action)) &#123;</span><br><span class="line">                Logger.get().verbose(</span><br><span class="line">                        TAG,</span><br><span class="line">                        <span class="string">&quot;Rescheduling alarm that keeps track of force-stops.&quot;</span>);</span><br><span class="line">                ForceStopRunnable.setAlarm(context);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有前文可知，应用启动时会初始化WorkManager，WorkManager初始化则会执行<code>ForceStopRunnable.run()</code>, 此时一般会调用setAlarm(), 创建Alarm，极端情况下会存在应用存活十年的情况，此<code>BroadcastReceiver</code>即是用于处理这种情况的，当十年后又收到了这个广播，那么我们在创建一个十年期的闹钟Alarm，哦，天呐。</p>
<h4 id="ConstraintProxy"><a href="#ConstraintProxy" class="headerlink" title=" ConstraintProxy"></a><span id="ConstraintProxy"> ConstraintProxy</h4><h5 id="BatteryNotLowProxy"><a href="#BatteryNotLowProxy" class="headerlink" title=" BatteryNotLowProxy"></a><span id="BatteryNotLowProxy"> BatteryNotLowProxy</h5><h5 id="BatteryChargingProxy"><a href="#BatteryChargingProxy" class="headerlink" title=" BatteryChargingProxy"></a><span id="BatteryChargingProxy"> BatteryChargingProxy</h5><h5 id="StorageNotLowProxy"><a href="#StorageNotLowProxy" class="headerlink" title=" StorageNotLowProxy"></a><span id="StorageNotLowProxy"> StorageNotLowProxy</h5><h5 id="NetworkStateProxy"><a href="#NetworkStateProxy" class="headerlink" title=" NetworkStateProxy"></a><span id="NetworkStateProxy"> NetworkStateProxy</h5><p>上述<code>BatteryNotLowProxy</code>、<code>BatteryChargingProxy</code>、<code>StorageNotLowProxy</code>、<code>NetworkStateProxy</code>均是<code>ConstraintProxy</code>的子类,实现均一致,仅有注册action不同,用以针对不同action的系统广播更新约束状态, 此处一并分析之。</p>
<p>以<code>NetworkStateProxy</code>为例，当网络状态变化，应用收到<code>"android.net.conn.CONNECTIVITY_CHANGE"</code>广播，触发<code>NetworkStateProxy.onReceive()</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">    Logger.get().debug(TAG, String.format(<span class="string">&quot;onReceive : %s&quot;</span>, intent));</span><br><span class="line">    Intent constraintChangedIntent = CommandHandler.createConstraintsChangedIntent(context);</span><br><span class="line">    context.startService(constraintChangedIntent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用<code>CommandHandler.createConstraintsChangedIntent(context)</code>调起<code>SystemAlarmService</code>, 其intent的action为<code>"ACTION_CONSTRAINTS_CHANGED"</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Intent <span class="title">createConstraintsChangedIntent</span><span class="params">(<span class="meta">@NonNull</span> Context context)</span> </span>&#123;</span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent(context, SystemAlarmService.class);</span><br><span class="line">    intent.setAction(ACTION_CONSTRAINTS_CHANGED);</span><br><span class="line">    <span class="keyword">return</span> intent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由<a href="#https://tinlone.com/2021/02/06/WorkManager%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%B8%89)%20-%20SystemAlarmService/">WorkManager基本使用及源码分析(三) - SystemAlarmService</a>讲述流程可知，最终会调用到<code>CommandHandler.onHandleIntent()</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void onHandleIntent(@NonNull Intent intent, int startId, @NonNull SystemAlarmDispatcher dispatcher) &#123;</span><br><span class="line">        String action &#x3D; intent.getAction();</span><br><span class="line"></span><br><span class="line">        if (ACTION_CONSTRAINTS_CHANGED.equals(action)) &#123;</span><br><span class="line">            handleConstraintsChanged(intent, startId, dispatcher);</span><br><span class="line">        &#125; </span><br><span class="line">        &#x2F;&#x2F; 其他</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void handleConstraintsChanged(</span><br><span class="line">        @NonNull Intent intent, int startId,</span><br><span class="line">        @NonNull SystemAlarmDispatcher dispatcher) &#123;</span><br><span class="line">    ConstraintsCommandHandler changedCommandHandler &#x3D;</span><br><span class="line">            new ConstraintsCommandHandler(mContext, startId, dispatcher);</span><br><span class="line">    changedCommandHandler.handleConstraintsChanged();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时intent的action为<code>"ACTION_CONSTRAINTS_CHANGED"</code>，最终会调用到<code>ConstraintsCommandHandler.handleConstraintsChanged()</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void handleConstraintsChanged() &#123;</span><br><span class="line">    List&lt;WorkSpec&gt; candidates &#x3D; mDispatcher.getWorkManager().getWorkDatabase()</span><br><span class="line">            .workSpecDao()</span><br><span class="line">            .getScheduledWork();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;更新约束代理以潜在地禁用先前完成的WorkSpecs的代理。</span><br><span class="line">    ConstraintProxy.updateAll(mContext, candidates);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 这需要在每个约束控制器中填充匹配的WorkSpec id。标记正在更新这些工作的状态</span><br><span class="line">    mWorkConstraintsTracker.replace(candidates);</span><br><span class="line"></span><br><span class="line">    List&lt;WorkSpec&gt; eligibleWorkSpecs &#x3D; new ArrayList&lt;&gt;(candidates.size());</span><br><span class="line">    &#x2F;&#x2F; 筛选候选人应该已经规划好了。</span><br><span class="line">    long now &#x3D; System.currentTimeMillis();</span><br><span class="line">    for (WorkSpec workSpec : candidates) &#123;</span><br><span class="line">        String workSpecId &#x3D; workSpec.id;</span><br><span class="line">        long triggerAt &#x3D; workSpec.calculateNextRunTime();</span><br><span class="line">        &#x2F;&#x2F; 时间条件符合且无约束或约束已符合，则加入符合条件集合</span><br><span class="line">        if (now &gt;&#x3D; triggerAt &amp;&amp; (!workSpec.hasConstraints()</span><br><span class="line">                || mWorkConstraintsTracker.areAllConstraintsMet(workSpecId))) &#123;</span><br><span class="line">            eligibleWorkSpecs.add(workSpec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (WorkSpec workSpec : eligibleWorkSpecs) &#123;</span><br><span class="line">        String workSpecId &#x3D; workSpec.id;</span><br><span class="line">        Intent intent &#x3D; CommandHandler.createDelayMetIntent(mContext, workSpecId);</span><br><span class="line">        &#x2F;&#x2F; 告诉SystemAlarmDispatcher这个工作已经符合条件了，请给安排上</span><br><span class="line">        mDispatcher.postOnMainThread(</span><br><span class="line">                new SystemAlarmDispatcher.AddRunnable(mDispatcher, intent, mStartId));</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 重置正在更新这些工作状态的标记</span><br><span class="line">    mWorkConstraintsTracker.reset();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此方法先获取了规划中的工作生成集合，调用了<code>ConstraintProxy.updateAll()</code>方法更新约束代理以潜在地禁用先前完成的WorkSpecs的代理，遍历判断每个WorkSpec是否符合条件，遍历符合约束条件的列表，告诉<code>SystemAlarmDispatcher</code>添加任务，若<code>SystemAlarmDispatcher</code>中无任务则分发执行任务（还记得processCommand()是一个环状的轮询吗？）。</p>
<p><code>SystemAlarmDispatcher.AddRunnable()</code>后续调用<code>SystemAlarmDispatcher.add()</code>在<a href="#https://tinlone.com/2021/02/06/WorkManager%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%B8%89)%20-%20SystemAlarmService/">WorkManager基本使用及源码分析(三) - SystemAlarmService</a>中有详细说明，此处仅摘要流程。<br><code>SystemAlarmDispatcher.AddRunnable()</code> -&gt; <code>SystemAlarmDispatcher.add()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SystemAlarmDispatcher</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(<span class="meta">@NonNull</span> <span class="keyword">final</span> Intent intent, <span class="keyword">final</span> <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String action = intent.getAction();</span><br><span class="line">    <span class="keyword">if</span> (TextUtils.isEmpty(action)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (CommandHandler.ACTION_CONSTRAINTS_CHANGED.equals(action)</span><br><span class="line">            &amp;&amp; hasIntentWithAction(CommandHandler.ACTION_CONSTRAINTS_CHANGED)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    intent.putExtra(KEY_START_ID, startId);</span><br><span class="line">    <span class="keyword">synchronized</span> (mIntents) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> hasCommands = !mIntents.isEmpty();</span><br><span class="line">        mIntents.add(intent);</span><br><span class="line">        <span class="keyword">if</span> (!hasCommands) &#123;</span><br><span class="line">            processCommand();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AddRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mDispatcher.add(mIntent, mStartId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ConstraintProxyUpdateReceiver"><a href="#ConstraintProxyUpdateReceiver" class="headerlink" title=" ConstraintProxyUpdateReceiver"></a><span id="ConstraintProxyUpdateReceiver"> ConstraintProxyUpdateReceiver</h4><p>上面讲到<code>ConstraintsCommandHandler.handleConstraintsChanged()</code>第一步会调用<code>ConstraintProxy.updateAll(mContext, candidates)</code>最终会发送广播给<code>ConstraintProxyUpdateReceiver</code>更新约束代理以潜在地禁用先前完成的WorkSpecs的代理,我们简单过一下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void updateAll(Context context, List&lt;WorkSpec&gt; workSpecs) &#123;</span><br><span class="line">    boolean batteryNotLowProxyEnabled &#x3D; false;</span><br><span class="line">    boolean batteryChargingProxyEnabled &#x3D; false;</span><br><span class="line">    boolean storageNotLowProxyEnabled &#x3D; false;</span><br><span class="line">    boolean networkStateProxyEnabled &#x3D; false;</span><br><span class="line">&#x2F;&#x2F; 查找每个WorkSpec（是否有）约束条件状态</span><br><span class="line">    for (WorkSpec workSpec : workSpecs) &#123;</span><br><span class="line">        Constraints constraints &#x3D; workSpec.constraints;</span><br><span class="line">        batteryNotLowProxyEnabled |&#x3D; constraints.requiresBatteryNotLow();</span><br><span class="line">        batteryChargingProxyEnabled |&#x3D; constraints.requiresCharging();</span><br><span class="line">        storageNotLowProxyEnabled |&#x3D; constraints.requiresStorageNotLow();</span><br><span class="line">        networkStateProxyEnabled |&#x3D; constraints.getRequiredNetworkType() !&#x3D; NOT_REQUIRED;</span><br><span class="line">&#x2F;&#x2F; 知道需要全部广播接收者，就不用判断了</span><br><span class="line">        if (batteryNotLowProxyEnabled &amp;&amp; batteryChargingProxyEnabled</span><br><span class="line">                &amp;&amp; storageNotLowProxyEnabled &amp;&amp; networkStateProxyEnabled) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Intent updateProxyIntent &#x3D;</span><br><span class="line">            ConstraintProxyUpdateReceiver.newConstraintProxyUpdateIntent(</span><br><span class="line">                    context,</span><br><span class="line">                    batteryNotLowProxyEnabled,</span><br><span class="line">                    batteryChargingProxyEnabled,</span><br><span class="line">                    storageNotLowProxyEnabled,</span><br><span class="line">                    networkStateProxyEnabled);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ConstraintProxies are being updated via a separate broadcast receiver.</span><br><span class="line">    &#x2F;&#x2F; For more information on why we do this look at b&#x2F;73549299</span><br><span class="line">    context.sendBroadcast(updateProxyIntent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里先是判断需要哪些广播接收者，会发送广播给ConstraintProxyUpdateReceiver，最终会调用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onReceive(@NonNull final Context context, @Nullable final Intent intent) &#123;</span><br><span class="line">    String action &#x3D; intent !&#x3D; null ? intent.getAction() : null;</span><br><span class="line">    if (!ACTION.equals(action)) &#123;</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        final PendingResult pendingResult &#x3D; goAsync();</span><br><span class="line">        WorkManagerImpl workManager &#x3D; WorkManagerImpl.getInstance(context);</span><br><span class="line">        TaskExecutor taskExecutor &#x3D; workManager.getWorkTaskExecutor();</span><br><span class="line">        taskExecutor.executeOnBackgroundThread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    &#x2F;&#x2F; 在后台线程上执行此操作，因为使用PackageManager来启用或禁用代理涉及到对文件系统的写操作。</span><br><span class="line">                    boolean batteryNotLowProxyEnabled &#x3D; intent.getBooleanExtra(</span><br><span class="line">                            KEY_BATTERY_NOT_LOW_PROXY_ENABLED, false);</span><br><span class="line">                    boolean batteryChargingProxyEnabled &#x3D; intent.getBooleanExtra(</span><br><span class="line">                            KEY_BATTERY_CHARGING_PROXY_ENABLED, false);</span><br><span class="line">                    boolean storageNotLowProxyEnabled &#x3D; intent.getBooleanExtra(</span><br><span class="line">                            KEY_STORAGE_NOT_LOW_PROXY_ENABLED, false);</span><br><span class="line">                    boolean networkStateProxyEnabled &#x3D; intent.getBooleanExtra(</span><br><span class="line">                            KEY_NETWORK_STATE_PROXY_ENABLED, false);</span><br><span class="line"></span><br><span class="line">                    Logger.get().debug(</span><br><span class="line">                            TAG,</span><br><span class="line">                            String.format(&quot;Updating proxies: BatteryNotLowProxy enabled (%s), &quot;</span><br><span class="line">                                            + &quot;BatteryChargingProxy enabled (%s), &quot;</span><br><span class="line">                                            + &quot;StorageNotLowProxy (%s), &quot;</span><br><span class="line">                                            + &quot;NetworkStateProxy enabled (%s)&quot;,</span><br><span class="line">                                    batteryNotLowProxyEnabled,</span><br><span class="line">                                    batteryChargingProxyEnabled,</span><br><span class="line">                                    storageNotLowProxyEnabled,</span><br><span class="line">                                    networkStateProxyEnabled));</span><br><span class="line"></span><br><span class="line">                    PackageManagerHelper.setComponentEnabled(context, BatteryNotLowProxy.class,</span><br><span class="line">                            batteryNotLowProxyEnabled);</span><br><span class="line">                    PackageManagerHelper.setComponentEnabled(context,</span><br><span class="line">                            BatteryChargingProxy.class,</span><br><span class="line">                            batteryChargingProxyEnabled);</span><br><span class="line">                    PackageManagerHelper.setComponentEnabled(context, StorageNotLowProxy.class,</span><br><span class="line">                            storageNotLowProxyEnabled);</span><br><span class="line">                    PackageManagerHelper.setComponentEnabled(context, NetworkStateProxy.class,</span><br><span class="line">                            networkStateProxyEnabled);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    pendingResult.finish();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要执行了获取前文提供的需要哪些约束广播接收器，调用<code>PackageManagerHelper.setComponentEnabled(context, StorageNotLowProxy.class, storageNotLowProxyEnabled)</code>更改广播接收者注册信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 使用&#123;@link PackageManager&#125; 去开&#x2F;关manifest声明的组件</span><br><span class="line"> *</span><br><span class="line"> * @param context &#123;@link Context&#125;</span><br><span class="line"> * @param klazz The class of component</span><br><span class="line"> * @param enabled &#123;@code true&#125; 开关组件</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static void setComponentEnabled(</span><br><span class="line">        @NonNull Context context,</span><br><span class="line">        @NonNull Class&lt;?&gt; klazz,</span><br><span class="line">        boolean enabled) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        PackageManager packageManager &#x3D; context.getPackageManager();</span><br><span class="line">        ComponentName componentName &#x3D; new ComponentName(context, klazz.getName());</span><br><span class="line">        packageManager.setComponentEnabledSetting(componentName,</span><br><span class="line">                enabled</span><br><span class="line">                        ? PackageManager.COMPONENT_ENABLED_STATE_ENABLED</span><br><span class="line">                        : PackageManager.COMPONENT_ENABLED_STATE_DISABLED,</span><br><span class="line">                PackageManager.DONT_KILL_APP);</span><br><span class="line"></span><br><span class="line">    &#125; catch (Exception exception) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="RescheduleReceiver"><a href="#RescheduleReceiver" class="headerlink" title=" RescheduleReceiver"></a><span id="RescheduleReceiver"> RescheduleReceiver</h4><blockquote>
<p>Reschedules alarms on BOOT_COMPLETED and other similar scenarios.</p>
</blockquote>
<p>在BOOT_COMPLETED和其他类似场景下重新调度Alarm。</p>
<h4 id="DiagnosticsReceiver"><a href="#DiagnosticsReceiver" class="headerlink" title=" DiagnosticsReceiver"></a><span id="DiagnosticsReceiver"> DiagnosticsReceiver</h4><blockquote>
<p>The {@link android.content.BroadcastReceiver} which dumps out useful diagnostics information. 输出有用的诊断信息</p>
</blockquote>
]]></content>
      <categories>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>WorkManager</tag>
      </tags>
  </entry>
  <entry>
    <title>白话说Handler-MessageQueue-Looper</title>
    <url>/2021/03/08/%E7%99%BD%E8%AF%9D%E8%AF%B4Handler-MessageQueue-Looper/</url>
    <content><![CDATA[<p><em>若无明示源码版本，全文以Android API23为准分析</em></p>
<h3 id="从何开始"><a href="#从何开始" class="headerlink" title="从何开始"></a>从何开始</h3><p>如何解释：我写的Java代码是如何在手机上一直运行着的？</p>
<p>首先，显而易见的，作为一个Java程序，一定有一个程序入口main(String[] args), 那么Android程序的入口main()在哪里呢，我们用 <a href="https://www.baidu.com/s?wd=Source_Insight%E4%B8%8B%E8%BD%BD%E5%92%8C%E4%BD%BF%E7%94%A8">Source Insight</a>查找一下，最终我们在<a href="https://www.androidos.net.cn/android/6.0.1_r16/xref/frameworks/base/core/java/android/app/ActivityThread.java">android.app.ActivityThread</a>中找到了它的身影。</p>
<p><span id="code_main">让我们来看一下ActivityThread.main()到底干了些啥:</span></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//&#123;@link android.app.ActivityThread&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//  ... something for environment &amp; log</span></span><br><span class="line">        </span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// init ActivityThread; ActivityManager.attachApplication</span></span><br><span class="line">        <span class="comment">// init Instrumentation; ContextImpl.createAppContext</span></span><br><span class="line">        <span class="comment">// context.mPackageInfo.makeApplication; application.onCreate</span></span><br><span class="line">        <span class="comment">// and so on ...</span></span><br><span class="line">        </span><br><span class="line">        Looper.loop();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Main thread loop unexpectedly exited&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>且先不看程序是如何初始化环境以及是如何从ActivityThread开始一步步启动application的，我们都知道Java程序终有执行完的一刻，那么app是如何保证在手机不爆炸的情况下一直运行不退出的？手痒用Java JFrame、JPanel的做过小游戏的朋友应该就想到了：无限循环刷新！</p>
<p>可是肉眼看过去，这里别说死循环，连个for都没有，怎么肥四？</p>
<p>所幸，我们发现了一组特别的单词 <strong>【Looper】</strong>（翻译：打环装置）和 <strong>【loop】</strong>(翻译：循环电影胶片；重复指令)，显然Looper应该就是维持程序一直运行的关键。</p>
<a id="more"></a>

<h3 id="何为Looper"><a href="#何为Looper" class="headerlink" title="何为Looper"></a>何为Looper</h3><p>从<a href="#code_main">ActivityThread.main()</a>代码不难看出，<strong>Looper.prepare()与Looper.loop()成对出现</strong>(prepareMainLooper()最终也是调用prepare()) ，要使用loop()保持循环，那么就必须先prepare()，我们且看一下<span id="code_prepare">Looper.prepare()</span>做了哪些准备工作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &#123;@link android.os.Looper#prepare()&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Only one Looper may be created per thread&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</span><br><span class="line">    mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里一共干了两件事情：</p>
<ul>
<li>从ThreadLocal中查询当前线程的Looper对象，有查到，说明已被prepare过，则抛错，由于一个线程只有一个ThreadLocal，从而保证一个线程仅会持有一个Looper</li>
<li>否则，为当前线程配备一个Looper，而初始化Looper时，同时创建了一个MessageQueue。</li>
</ul>
<p>那让我们看看 <strong><span id="code_loop">Looper.loop()</span></strong> 是不是就是我们要找的 <strong>让程序像放电影一样一直跑下去的原因</strong>！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> MessageQueue mQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;@link android.os.Looper#loop()&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">    <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;No Looper; Looper.prepare() wasn&#x27;t called on this thread.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// something for Binder</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ... something for log</span></span><br><span class="line">        <span class="comment">// 执行Handler.Callback.handleMessage</span></span><br><span class="line">        msg.target.dispatchMessage(msg);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// something for log</span></span><br><span class="line">        </span><br><span class="line">        msg.recycleUnchecked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>不负众望，Looper.loop()确实保持着一个死循环，<strong>只要给马儿(Looper)草(Message)，马儿就能一直跑！</strong> Looper.loop()的循环中主要干了三件事：</p>
<ul>
<li>从MessageQueue中取出一条Message，若Message为空则退出循环</li>
<li>Message不为空，则处理消息</li>
<li>回收Message</li>
</ul>
<p>至此，我们知道了Looper实现了程序的持续运行，而我们发现了一个控制Looper执行和中断的重要角色：<strong>MessageQueue和Message</strong></p>
<h3 id="MessageQueue和Message"><a href="#MessageQueue和Message" class="headerlink" title="MessageQueue和Message"></a>MessageQueue和Message</h3><p><a href="#code_loop">Looper.loop()</a>中循环通过MessageQueue.next()取出Message，MessageQueue看起来是Message的容器，MessageQueue真的仅仅是Message的容器吗？</p>
<p>我们先来看一下<span id="code_message">Message</span>的数据结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Message &#123;</span><br><span class="line">    &#x2F;&#x2F; 出队时机</span><br><span class="line">    public long when;</span><br><span class="line">    &#x2F;&#x2F; 发送&#x2F;处理消息的Handler对象</span><br><span class="line">    Handler target;</span><br><span class="line">    &#x2F;&#x2F; 下一个消息</span><br><span class="line">    Message next;</span><br><span class="line">    &#x2F;&#x2F; 消息缓存池</span><br><span class="line">    private static Message sPool;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; ... other</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，数据结构上 Message对象自身持有下一个Message的引用，形成单链表结构或者队列，从代码不难看出Message本身仅实现了单链表结构、缓存机制、持有消费自身的Handler。</p>
<p>试设想，若仅视MessageQueue为Message的容器，以Message现有的条件参与Looper的轮询以供Handler消费，Message仅能实现先入先出，若某一个Message的执行时机为一年后，那么这个Message后续的next将仅能在1年后获得被消费的机会，显然不合理，而实际情况也并非如此。那么是谁帮助Message正确的被消费呢？显然就是MessageQueue！</p>
<p>我们来看看MessageQueue是如何处理Message的插入和取出以及Message的分配的。</p>
<p>首先，我们先找寻一下MessageQueue是如何插入Message或者说获取到Message对象的，从前面<a href="#code_message">Message</a>代码可以看到，Message持有Handler对象，有用过<strong>android.os.Handler</strong>的不难联想出这行代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">myHandler.sendMessage(message);</span><br></pre></td></tr></table></figure>
<p>Message对象由我们生产，由Handler发送，最终在合适的时机被Handler消费。那么，Handler是怎么把Message交给MessageQueue的，MessageQueue又是在什么时机把Message交给Looper转运给Handler处理的呢？</p>
<p>追踪代码发现，Handler.sendMessage(message)最终是调用<span id="code_enqueueMessage">Handler.enqueueMessage</span>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; &#123;@link android.os.Handler#enqueueMessage&#125;</span><br><span class="line">private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123;</span><br><span class="line">    msg.target &#x3D; this;</span><br><span class="line">    if (mAsynchronous) &#123;</span><br><span class="line">        msg.setAsynchronous(true);</span><br><span class="line">    &#125;</span><br><span class="line">    return queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Handler将自己设置为Message的target，并将Message和Message执行时机传递给MessageQueue，而MessageQueue的来源则是从<span id="code_handler">Handler</span>构造方法参数Looper中取得:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Handler(Callback callback, boolean async) &#123;</span><br><span class="line">       &#x2F;&#x2F;... doSomething</span><br><span class="line"></span><br><span class="line">       mLooper &#x3D; Looper.myLooper();</span><br><span class="line">       if (mLooper &#x3D;&#x3D; null) &#123;</span><br><span class="line">           throw new RuntimeException(</span><br><span class="line">               &quot;Can&#39;t create handler inside thread that has not called Looper.prepare()&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       mQueue &#x3D; mLooper.mQueue;</span><br><span class="line">       mCallback &#x3D; callback;</span><br><span class="line">       mAsynchronous &#x3D; async;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>搞清楚Message的来源后，我们来看看MessageQueue是如何处理收到的这个Message对象的，首先我们跟着<a href="#code_enqueueMessage">Handler.enqueueMessage</a>找到了MessageQueue的<span id="code_mq_eqMsg">enqueueMessage</span>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boolean enqueueMessage(Message msg, long when) &#123;</span><br><span class="line">   &#x2F;&#x2F; ...  如果Message正在被使用或target为空则抛错</span><br><span class="line"></span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">        if (mQuitting) &#123;</span><br><span class="line">            msg.recycle();</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when &#x3D; when;</span><br><span class="line">        Message p &#x3D; mMessages;</span><br><span class="line">        boolean needWake;</span><br><span class="line">        if (p &#x3D;&#x3D; null || when &#x3D;&#x3D; 0 || when &lt; p.when) &#123;</span><br><span class="line">            &#x2F;&#x2F; New head, wake up the event queue if blocked.</span><br><span class="line">            msg.next &#x3D; p;</span><br><span class="line">            mMessages &#x3D; msg;</span><br><span class="line">            needWake &#x3D; mBlocked;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            needWake &#x3D; mBlocked &amp;&amp; p.target &#x3D;&#x3D; null &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            Message prev;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                prev &#x3D; p;</span><br><span class="line">                p &#x3D; p.next;</span><br><span class="line">                if (p &#x3D;&#x3D; null || when &lt; p.when) &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                if (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake &#x3D; false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next &#x3D; p; &#x2F;&#x2F; invariant: p &#x3D;&#x3D; prev.next</span><br><span class="line">            prev.next &#x3D; msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; We can assume mPtr !&#x3D; 0 because mQuitting is false.</span><br><span class="line">        if (needWake) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>简单分析代码，得知MessageQueue执行了如下操作：</p>
<ul>
<li>检查新Message是否有消费者或是否正在被使用，若无消费者或正被使用，则抛错</li>
<li>锁定MessageQueue，保证Message对象不被重复或错误操作</li>
<li>检查如果MessageQueue被标记为退出，则不需处理本次插入</li>
<li>将Message标记为正在被使用</li>
<li>找寻新Message位置<ul>
<li>若当前为<strong>第一次添加（p == null）</strong> 或 <strong>最优执行（when == 0）</strong> 或 <strong>新Message执行时机先于头部Message（when &lt; p.when）</strong>，则将新Message记录为MessageQueue中的头部Message（<strong>mMessages</strong>），并将旧的头部Message设置为新Message的Next</li>
<li>若新Message不满足与头部Message竞争的条件，则依次递进比较新Message与MessageQueue中头部Message.next的执行时机when，直到Message队列的最尾端（p == null）或者合适的位置(when &lt; p.when)，将新Message插入到该位置</li>
</ul>
</li>
<li>若当前头部Message需要被执行，则唤醒MessageQueue以向Looper提供Message对象</li>
</ul>
<p>从上述逻辑可看出，当新的Message被传入MessageQueue时，MessageQueue会等待过往操作执行完毕并锁定其他操作（<strong>synchronized (this)<strong>），</strong>根据优先级执行插入排序</strong>逻辑将新Message放置到队列的合适位置，记录并持有队列优先级最高的头部Message对象，若头部Message需要被消费，则取消消息队列阻塞（阻塞由Message为空时无限等待产生）</p>
<p>把视野放回到<a href="#code_loop">Looper.loop()</a>,MessageQueue中的Message是如何被取走的呢？让我们来看下<span id="code_next">MessageQueue.next()&lt;&gt;做了哪些操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">               Binder.flushPendingCommands();</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">               Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">               Message msg = mMessages;</span><br><span class="line">               <span class="comment">// msg.target == null 源自&#123;@link #postSyncBarrier&#125;</span></span><br><span class="line">               <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">do</span> &#123;</span><br><span class="line">                       prevMsg = msg;</span><br><span class="line">                       msg = msg.next;</span><br><span class="line">                       <span class="comment">// 若消息不为空且消息为非异步消息，则继续轮询，直到找到异步消息</span></span><br><span class="line">                   &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                       nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       mBlocked = <span class="keyword">false</span>;</span><br><span class="line">                       <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           prevMsg.next = msg.next;</span><br><span class="line">                       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                           mMessages = msg.next;</span><br><span class="line">                       &#125;</span><br><span class="line">                       msg.next = <span class="keyword">null</span>;</span><br><span class="line">                       msg.markInUse();</span><br><span class="line">                       <span class="keyword">return</span> msg;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">// No more messages.</span></span><br><span class="line">                   nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                   dispose();</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// ... 队列为空或无可消费对象时相关逻辑</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// ... 队列为空或无可消费对象时，状态重置、调用闲置回调</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>在Looper循环从MessageQueue取Message时，MessageQueue做了如下操作：</p>
<ul>
<li>若头部Massage需等待，则等待一定时间 （nativePollOnce(ptr, nextPollTimeoutMillis);）</li>
<li>遍历队列，锁定MessageQueue对象</li>
<li>若头部消息消费者为null，则消息为同步屏障，说明有立即执行的消息，则遍历直到找到一个需要立即执行的异步消息</li>
<li>查找合适的可被消费的Message，若Message不为空：<ul>
<li>如果Message仍需等待，则计算需要等待的时间nextPollTimeoutMillis </li>
<li>若Message不需要等待，则传递当前可消费Message的后续元素：<ul>
<li>若有队列前不可被消费的对象，则将next-Message作为其next</li>
<li>若当前可消费Message为头部，则将next记录为新头部</li>
</ul>
</li>
<li>切断可消费Message与后续元素的联系，将其置为使用状态并返回</li>
</ul>
</li>
<li>查询到Message为空，若需退出则销毁MessageQueue，否则执行闲置回调、重置相关状态属性执行下次轮询，设置无限等待（当有新事件如enqueueMessage时执行唤醒）</li>
</ul>
<p>综合MessageQueue对Message存取的操作不难总结出，MessageQueue以Message的优先级when为依据管理着Message优先级队列，并始终持有Message队列头部元素，MessageQueue既是Message队列的容器也管理着Message的入队出队顺序，保证Message稳定有序的被传递。</p>
<h3 id="Handler扮演了什么角色"><a href="#Handler扮演了什么角色" class="headerlink" title="Handler扮演了什么角色"></a>Handler扮演了什么角色</h3><p>纵观Message的一生，生于new或缓存队列，起于Handler，存于MessageQueue，行于Looper，兜兜转转又回到了Handler，归于缓存队列，那么Handler到底扮演了什么角色呢？<br>让我们来看一段简单代码，帮我们理解Handler的角色：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;HandlerTest&quot;</span>;</span><br><span class="line">    ScheduledExecutorService executorService = <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">5</span>,</span><br><span class="line">            <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">                    Thread thread = <span class="keyword">new</span> Thread(r);</span><br><span class="line">                    thread.setName(<span class="string">&quot;test-Thread&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> thread;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">    Handler myHandler = <span class="keyword">new</span> MyHandler(Looper.getMainLooper());</span><br><span class="line"></span><br><span class="line">    Runnable taskRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            myHandler.sendEmptyMessage(<span class="number">1</span>);</span><br><span class="line">            MyHandler handler = <span class="keyword">new</span> MyHandler(subThread.getLooper());</span><br><span class="line">            handler.sendEmptyMessage(<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    HandlerThread subThread = <span class="keyword">new</span> HandlerThread(<span class="string">&quot;test-Thread2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        subThread.start();</span><br><span class="line">        executorService.schedule(taskRunnable, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        myHandler.postDelayed(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                MyHandler handler = <span class="keyword">new</span> MyHandler(subThread.getLooper());</span><br><span class="line">                handler.sendEmptyMessage(<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyHandler</span><span class="params">(<span class="meta">@NonNull</span> Looper looper)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(looper);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(<span class="meta">@NonNull</span> Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// doSomething</span></span><br><span class="line">            Log.i(TAG, String.format(<span class="string">&quot;ThreadName: %s, msg.what = %s&quot;</span>,</span><br><span class="line">                    Thread.currentThread().getName(), msg.what));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码比较简单，既：</p>
<ul>
<li>主线程初始化myHandler，在子线程中发送Message [1]，最终myHandler打印出工作线程信息</li>
<li>主线程中使用子线程的Looper初始化handler，在主线程中发送Message [2]，最终handler打印出工作线程信息</li>
<li>子线程初始化Handler，在子线程中发送Message [3]，最终subHandler打印出工作线程信息</li>
</ul>
<p>最终执行的结果是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">08-23 13:37:26.579 12969-12983&#x2F;a.b.c I&#x2F;HandlerTest: ThreadName: test-Thread2, msg.what &#x3D; 2</span><br><span class="line">08-23 13:37:28.578 12969-12969&#x2F;a.b.c I&#x2F;HandlerTest: ThreadName: main, msg.what &#x3D; 1</span><br><span class="line">08-23 13:37:28.578 12969-12983&#x2F;a.b.c I&#x2F;HandlerTest: ThreadName: test-Thread2, msg.what &#x3D; 3</span><br></pre></td></tr></table></figure>
<p>结果分析：</p>
<ul>
<li>子线程taskRunner中使用myHandler发送的消息1最终在主线程中被处理</li>
<li>子线程taskRunner中使用subyHandler发送的消息3最终在子线程中被处理</li>
<li>而主线程(<em>myHandler.postDelayed</em>) 中使用subHandler发送的消息2最终在子线程中被处理；</li>
</ul>
<p>由此可见，Handler.handleMessage()执行的线程是Handler初始化所传递的Looper的工作线程，而不是执行sendMessage()的所在线程。那么，想要实现跨线程通信，只需要在响应线程中初始化Handler传入对应线程的Looper，将Handler对象交给任意工作线程都可与之实现数据交换。</p>
<p>以<strong>Looper为动力</strong>，以<strong>MessageQueue为分拣器</strong>，<strong>Handler作为跟着Message产品走的工人</strong>，将一个个Message产品，搬运至MessageQueue以品质好坏(优先级)分拣排序、动力Looper督促分拣器MessageQueue工作，优先的Message产品被送出，再由操作工Handler搬离流水线，最终完成Message产品按品质从上游运送到下游。</p>
]]></content>
      <categories>
        <category>Framework</category>
      </categories>
      <tags>
        <tag>Handler</tag>
      </tags>
  </entry>
  <entry>
    <title>Jetpack之生命周期感知组件-Lifecycle原理篇</title>
    <url>/2021/02/28/Jetpack%E4%B9%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%84%9F%E7%9F%A5%E7%BB%84%E4%BB%B6-Lifecycle%E5%8E%9F%E7%90%86%E7%AF%87/</url>
    <content><![CDATA[<p>上一篇文章中我们讲了<a href="https://tinlone.com/2021/02/25/Jetpack%E4%B9%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%84%9F%E7%9F%A5%E7%BB%84%E4%BB%B6-Lifecycle%E4%BD%BF%E7%94%A8%E7%AF%87/">Jetpack之生命周期感知组件-Lifecycle使用篇</a>，接下来我们来看一下他是如何工作的吧。</p>
<p>在了解其工作原理前，我们需要先简单了解以下ActivityThread对Activity生命周期的分发流程，以便理解Lifecycle的工作原理。</p>
<p>此篇前半部分将讲述API26及API30生命周期分发流程，后半部分依照前半部分对照讲述Lifecycle生命周期分发时机，最后将介绍Lifecycle源码执行流程及ProcessLifecycleOwner是如何实现应用前后台监听的。</p>
<a id="more"></a>

<h3 id="生命周期的产生及分发"><a href="#生命周期的产生及分发" class="headerlink" title="生命周期的产生及分发"></a>生命周期的产生及分发</h3><p>此部分源码取自<code>Android SDK api26 & api30</code>, 获取方式为使用Android Studio 的 SDK Manager 下载 api26 及 api30 源代码，源代码目录为<code> %AndroidSDK%/source/android-版本号</code>，你可以使用SublimeText等工具打开源码对照阅读。</p>
<p>Lifecycle以Api29为分界点有不同的处理方式，这是先讲述此节内容的原因，此处以Api26及Api30为代表讲述。</p>
<h4 id="API-26"><a href="#API-26" class="headerlink" title="API 26"></a>API 26</h4><p>我们知道，Activity是由ActivityThread生成及管理的。此处以<code>ActivityThread.performLaunchActivity()</code>为起点，分析Activity onCreate()/onStart()事件的产生及分发。</p>
<p>我们先看简化版的performLaunchActivity()代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@link</span>&#123;ActivityThread&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do something create Activity</span></span><br><span class="line">    activity = mInstrumentation.newActivity(</span><br><span class="line">                cl, component.getClassName(), r.intent);</span><br><span class="line">    <span class="comment">// ... init Activity</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Application app = r.packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</span><br><span class="line">        <span class="comment">// logs </span></span><br><span class="line">        <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// activity attach &amp; setTheme ...</span></span><br><span class="line">            activity.mCalled = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (r.isPersistable()) &#123;</span><br><span class="line">                <span class="comment">// onCreate()</span></span><br><span class="line">                mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// some log</span></span><br><span class="line">            r.activity = activity;</span><br><span class="line">            r.stopped = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (!r.activity.mFinished) &#123;</span><br><span class="line">                <span class="comment">// onStart()</span></span><br><span class="line">                activity.performStart();</span><br><span class="line">                r.stopped = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="comment">// do something</span></span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">// do something</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (SuperNotCalledException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">       <span class="comment">// log error</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> activity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到，在完成了Activity启动条件后调用了<code>mInstrumentation.callActivityOnCreate(</code>及<code>activity.performStart()</code>( 即生命周期onCreate()和onStart()）, 为了一并了解Fragment生命周期的分发，我们以onStart()为例，onStart()事件产生于此，我们继续跟进 <code>activity.performStart()</code> :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@link</span>&#123;Activity&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="comment">// 注意此处，会回调到activity.onStart();</span></span><br><span class="line">    mInstrumentation.callActivityOnStart(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// logs</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意此处mFragments是 FragmentController，</span></span><br><span class="line">    <span class="comment">// 后续会调用FragmentManager.dispatchStart()、fragment.performStart()</span></span><br><span class="line">    <span class="comment">// 最终执行到 fragment.onStart()</span></span><br><span class="line">    mFragments.dispatchStart();</span><br><span class="line">    mFragments.reportLoaderStart();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// do Something others</span></span><br><span class="line"></span><br><span class="line">    mActivityTransitionState.enterReady(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@link</span>&#123;Instrumentation&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callActivityOnStart</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">    activity.onStart();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由上面代码代码我们了解了<strong>API26</strong>时 Activity的onStart()事件的产生到传递，以及传递给Fragment的方式【此处代码跟进省略，但应了解这个流程，后续在讲述Lifecycle时将会用到】。</p>
<h4 id="API-30-（API-lvl-≥-29）"><a href="#API-30-（API-lvl-≥-29）" class="headerlink" title="API 30 （API lvl ≥ 29）"></a>API 30 （API lvl ≥ 29）</h4><p>同样的，此处以<code>ActivityThread.performLaunchActivity()</code>为起点，分析Activity onCreate()/onStart()事件的产生及分发：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@link</span>&#123;ActivityThread&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// create Activity</span></span><br><span class="line">    activity = mInstrumentation.newActivity(</span><br><span class="line">            cl, component.getClassName(), r.intent);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Application app = r.packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</span><br><span class="line">        <span class="comment">// init Activity &amp; setTheme</span></span><br><span class="line">        activity.mCalled = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (r.isPersistable()) &#123;</span><br><span class="line">            <span class="comment">// onCreate()</span></span><br><span class="line">            mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// some log</span></span><br><span class="line">        r.activity = activity;</span><br><span class="line">        mLastReportedWindowingMode.put(activity.getActivityToken(),</span><br><span class="line">                config.windowConfiguration.getWindowingMode());</span><br><span class="line">        <span class="comment">// 设置生命周期</span></span><br><span class="line">        r.setState(ON_CREATE);</span><br><span class="line">        <span class="comment">// something</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (SuperNotCalledException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// log error</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> activity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码与 API 26 基本一致，但是此时onCreate事件与onStart事件的产生已不是耦合相关，同样的关注onStart()生命周期，此处已不包含onStart()相关的代码及调用，我们发现有新的代码<code>r.setState(ON_CREATE);</code>可能与生命周期有关，猜测是否onStart()事件也会有类似方法，果然，在相邻的下一个方法<code>handleStartActivity</code>中我们发现类似代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@link</span>&#123;ActivityThread&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleStartActivity</span><span class="params">(IBinder token, PendingTransactionActions pendingActions)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="comment">// Start</span></span><br><span class="line">    activity.performStart(<span class="string">&quot;handleStartActivity&quot;</span>);</span><br><span class="line">    r.setState(ON_START);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// something Restore instance state</span></span><br><span class="line">   </span><br><span class="line">    updateVisibility(r, <span class="keyword">true</span> <span class="comment">/* show */</span>);</span><br><span class="line">    mSomeActivitiesChanged = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似的，这里调用了<code>activity.performStart("handleStartActivity");</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@link</span>&#123;Activity&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performStart</span><span class="params">(String reason)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注意注意</span></span><br><span class="line">    <span class="comment">// 注意此处有新代码，用以通知注册在Application及Activity中的ActivityLifecycleCallbacks当前的生命周期状态，由这些回调方法分发生命周期事件</span></span><br><span class="line">    dispatchActivityPreStarted();</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="comment">// 最终调用onStart()</span></span><br><span class="line">    mInstrumentation.callActivityOnStart(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// something</span></span><br><span class="line">    <span class="comment">// 注意此处mFragments是 FragmentController，</span></span><br><span class="line">    <span class="comment">// 后续会调用FragmentManager.dispatchStart()、fragment.performStart()</span></span><br><span class="line">    <span class="comment">// 最终执行到 fragment.onStart()</span></span><br><span class="line">    mFragments.dispatchStart();</span><br><span class="line">    mFragments.reportLoaderStart();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do something debug</span></span><br><span class="line"></span><br><span class="line">    mActivityTransitionState.enterReady(<span class="keyword">this</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意注意</span></span><br><span class="line">    <span class="comment">// 注意此处有新代码，用以通知注册在Application及Activity中的ActivityLifecycleCallbacks当前的生命周期状态，由这些回调方法分发生命周期事件</span></span><br><span class="line">    dispatchActivityPostStarted();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@link</span>&#123;Instrumentation&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callActivityOnStart</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">    activity.onStart();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处主体逻辑与API 26一致，均是调用Activity onStart()回调和分发事件给Fragment，我们注意到此处多了两个 “dispatchActivityXXX()” 方法，跟进这两个 “dispatchActivityXXX()” 方法，均为执行以下类似代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@link</span>&#123;Activity&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchActivityPreStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    getApplication().dispatchActivityPreStarted(<span class="keyword">this</span>);</span><br><span class="line">    Object[] callbacks = collectActivityLifecycleCallbacks();</span><br><span class="line">    <span class="keyword">if</span> (callbacks != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; callbacks.length; i++) &#123;</span><br><span class="line">            ((Application.ActivityLifecycleCallbacks) callbacks[i]).onActivityPreStarted(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@link</span>&#123;Application&#125;</span><br><span class="line"><span class="comment">/* package */</span> <span class="function"><span class="keyword">void</span> <span class="title">dispatchActivityPreStarted</span><span class="params">(<span class="meta">@NonNull</span> Activity activity)</span> </span>&#123;</span><br><span class="line">    Object[] callbacks = collectActivityLifecycleCallbacks();</span><br><span class="line">    <span class="keyword">if</span> (callbacks != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; callbacks.length; i++) &#123;</span><br><span class="line">            ((ActivityLifecycleCallbacks) callbacks[i]).onActivityPreStarted(activity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单分析代码，可以发现，其主要功能是将不同的生命周期事件上报给Applicaiton进行回调分发以及通知注册在Activity中的回调分发【记住此处，与Lifecycle在Api29前后不同处理方式有关】。</p>
<p>而相比于 API26，通过跟进<code>collectActivityLifecycleCallbacks()</code>发现， Activity在API29之后新增了生命周期注册功能，即维护了一个 <code> ActivityLifecycleCallbacks</code>集合，而生命周期在Activity中的最后使命就是通过 dispatchActivityXXX() 向注册在Activity/Application中的 ActivityLifecycleCallbacks 分发事件。</p>
<h3 id="Lifecycle源码解析"><a href="#Lifecycle源码解析" class="headerlink" title="Lifecycle源码解析"></a>Lifecycle源码解析</h3><p>前半部分，我们讲述了Activity生命周期事件的产生和分发，接下来我们来看一下Lifecycle是如何订阅和消费这些事件的吧。</p>
<h4 id="Lifecycle"><a href="#Lifecycle" class="headerlink" title="Lifecycle"></a>Lifecycle</h4><p>首先我们来看一下Lifecycle的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Lifecycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(<span class="meta">@NonNull</span> LifecycleObserver observer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(<span class="meta">@NonNull</span> LifecycleObserver observer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> State <span class="title">getCurrentState</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;WeakerAccess&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Event</span> </span>&#123;</span><br><span class="line">        ON_CREATE,</span><br><span class="line">        ON_START,</span><br><span class="line">        ON_RESUME,</span><br><span class="line">        ON_PAUSE,</span><br><span class="line">        ON_STOP,</span><br><span class="line">        ON_DESTROY,</span><br><span class="line">        ON_ANY;</span><br><span class="line">       <span class="comment">// some apis</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;WeakerAccess&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">        DESTROYED,</span><br><span class="line">        INITIALIZED,</span><br><span class="line">        CREATED,</span><br><span class="line">        STARTED,</span><br><span class="line">        RESUMED;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAtLeast</span><span class="params">(<span class="meta">@NonNull</span> State state)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> compareTo(state) &gt;= <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Lifecycle 是一个类，用于存储有关组件（如 Activity 或 Fragment）的生命周期状态的信息，并允许其他对象观察此状态。<br>Lifecycle 使用两种主要枚举跟踪其关联组件的生命周期状态：</p>
<ul>
<li>事件<pre><code> 从框架和 Lifecycle 类分派的生命周期事件。这些事件映射到 Activity 和 Fragment 中的回调事件。
</code></pre>
</li>
<li>状态<pre><code> 由 Lifecycle 对象跟踪的组件的当前状态。 
</code></pre>
</li>
</ul>
</blockquote>
<p><img src="https://developer.android.google.cn/images/topic/libraries/architecture/lifecycle-states.svg" alt="Lifecycle.png"></p>
<p>Lifecycle的主要子类是LifecycleRegistry，主要用于最终处理和分发事件给对应的Observer，由于其在调用流程的最尾端，故我们放到后面流程中一起讲解。</p>
<h4 id="ComponentActivity"><a href="#ComponentActivity" class="headerlink" title="ComponentActivity"></a>ComponentActivity</h4><blockquote>
<p>支持库 26.1.0 及更高版本中的 Fragment 和 Activity 已实现 LifecycleOwner 接口。</p>
</blockquote>
<p>官方文档有指出支持库 26.1.0以上的Fragment和Activity中已实现LifecycleOwner 接口，我们从<code>androidx.appcompat.app.AppCompatActivity</code>向上找寻LifecycleOwner的身影，<code>androidx.activity.ComponentActivity</code>及<code>androidx.core.app.ComponentActivity</code>均有对 LifecycleOwner的实现，我们先看下父类<code>androidx.core.app.ComponentActivity</code>中的处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComponentActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class">        <span class="title">LifecycleOwner</span>,</span></span><br><span class="line"><span class="class">        <span class="title">KeyEventDispatcher</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LifecycleRegistry mLifecycleRegistry = <span class="keyword">new</span> LifecycleRegistry(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressLint(&quot;RestrictedApi&quot;)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(<span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        ReportFragment.injectIfNeededIn(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CallSuper</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(<span class="meta">@NonNull</span> Bundle outState)</span> </span>&#123;</span><br><span class="line">        mLifecycleRegistry.markState(Lifecycle.State.CREATED);</span><br><span class="line">        <span class="keyword">super</span>.onSaveInstanceState(outState);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// others</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现，其代码不多，与生命周期相关的核心代码仅实现了onCreate及onSaveInstanceState，其中onCreate()中中仅有一句特别的代码<code>ReportFragment.injectIfNeededIn(this);</code>我们有理由相信他与生命周期管理有关，我们尝试跟进一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@link</span>&#123;ReportFragment&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">injectIfNeededIn</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">29</span>) &#123;</span><br><span class="line">        <span class="comment">// 在API 29+上，我们可以直接注册正确的生命周期回调</span></span><br><span class="line">        LifecycleCallbacks.registerIn(activity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 之前的API 29和保持与旧版本的兼容性</span></span><br><span class="line">    <span class="comment">// ProcessLifecycleOwner(当生命周期运行时更新时可能不会更新，</span></span><br><span class="line">    <span class="comment">// 并且需要支持不从支持库的FragmentActivity扩展的活动)，</span></span><br><span class="line">    <span class="comment">// 使用框架片段来获得生命周期事件的正确时间</span></span><br><span class="line">    android.app.FragmentManager manager = activity.getFragmentManager();</span><br><span class="line">    <span class="keyword">if</span> (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        manager.beginTransaction().add(<span class="keyword">new</span> ReportFragment(), REPORT_FRAGMENT_TAG).commit();</span><br><span class="line">        <span class="comment">// 希望我们是第一个达成交易的。</span></span><br><span class="line">        manager.executePendingTransactions();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>果不其然，我们发现这里有<code>LifecycleCallbacks</code>关键字，还记得前面讲到的生命周期分发流程中提到的API不同版本对于生命周期处理方式的不同吗，主要区别在于API29 Activity中新增了<code>ActivityLifecycleCallbacks</code>的注册和分发，而API 29之前生命周期均会传递给Fragment。 此处我们发现这里的 ReportFragment 本质是一个Fragment，在Activity创建（onCreate）的时候：</p>
<ul>
<li>对于API ≥ 29 将会注册生命周期回调，并将ReportFragment添加到Activity中</li>
<li>对于API &lt; 29 将ReportFragment添加到Activity中.</li>
</ul>
<p>那么这样做的意义是什么呢，我们来看一下这里injectIfNeededIn具体干了什么。<br>首先 <code>LifecycleCallbacks.registerIn(activity)</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequiresApi(29)</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LifecycleCallbacks</span> <span class="keyword">implements</span> <span class="title">Application</span>.<span class="title">ActivityLifecycleCallbacks</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerIn</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">        activity.registerActivityLifecycleCallbacks(<span class="keyword">new</span> LifecycleCallbacks());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityPostCreated</span><span class="params">(<span class="meta">@NonNull</span> Activity activity,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        dispatch(activity, Lifecycle.Event.ON_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityPostStarted</span><span class="params">(<span class="meta">@NonNull</span> Activity activity)</span> </span>&#123;</span><br><span class="line">        dispatch(activity, Lifecycle.Event.ON_START);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityPostResumed</span><span class="params">(<span class="meta">@NonNull</span> Activity activity)</span> </span>&#123;</span><br><span class="line">        dispatch(activity, Lifecycle.Event.ON_RESUME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityPrePaused</span><span class="params">(<span class="meta">@NonNull</span> Activity activity)</span> </span>&#123;</span><br><span class="line">        dispatch(activity, Lifecycle.Event.ON_PAUSE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityPreStopped</span><span class="params">(<span class="meta">@NonNull</span> Activity activity)</span> </span>&#123;</span><br><span class="line">        dispatch(activity, Lifecycle.Event.ON_STOP);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityPreDestroyed</span><span class="params">(<span class="meta">@NonNull</span> Activity activity)</span> </span>&#123;</span><br><span class="line">        dispatch(activity, Lifecycle.Event.ON_DESTROY);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ignore empty function</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里将会把一个 Application.ActivityLifecycleCallbacks 注册到当前Activity中，还记得前面讲到的，生命周期在Activity中的最后使命就是通过 dispatchActivityXXX() 向注册在Activity/Application中的 ActivityLifecycleCallbacks 分发事件。<br>对应此处，即是生命周期事件会反馈到 <code> ReportFragment.LifecycleCallbacks</code> 并最终调用<code>dispatch(activity, Lifecycle.Event.ON_XXXX);</code>分发。</p>
<p>那么在API29以前呢？？</p>
<p>前面有要求注意过 在生命周期分发过程中 均会调用<code> FragmentController.dispatchXXX();</code> 方法，最终会调用Fragment的 onXXXX()方法，我们有理由相信在ReportFragment中会存在对这些生命周期的实现及分发，让我们来验证下我们的猜测：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP_PREFIX)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReportFragment</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">app</span>.<span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String REPORT_FRAGMENT_TAG = <span class="string">&quot;androidx.lifecycle&quot;</span></span><br><span class="line">            + <span class="string">&quot;.LifecycleDispatcher.report_fragment_tag&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">injectIfNeededIn</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 见上一codepod</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;deprecation&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(<span class="meta">@NonNull</span> Activity activity, <span class="meta">@NonNull</span> Lifecycle.Event event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (activity <span class="keyword">instanceof</span> LifecycleRegistryOwner) &#123;</span><br><span class="line">            ((LifecycleRegistryOwner) activity).getLifecycle().handleLifecycleEvent(event);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (activity <span class="keyword">instanceof</span> LifecycleOwner) &#123;</span><br><span class="line">            Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle();</span><br><span class="line">            <span class="keyword">if</span> (lifecycle <span class="keyword">instanceof</span> LifecycleRegistry) &#123;</span><br><span class="line">                ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// private ActivityInitializationListener mProcessListener;</span></span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityCreated</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onActivityCreated(savedInstanceState);</span><br><span class="line">        dispatchCreate(mProcessListener);</span><br><span class="line">        dispatch(Lifecycle.Event.ON_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">        dispatchStart(mProcessListener);</span><br><span class="line">        dispatch(Lifecycle.Event.ON_START);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onResume();</span><br><span class="line">        dispatchResume(mProcessListener);</span><br><span class="line">        dispatch(Lifecycle.Event.ON_RESUME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onPause();</span><br><span class="line">        dispatch(Lifecycle.Event.ON_PAUSE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop();</span><br><span class="line">        dispatch(Lifecycle.Event.ON_STOP);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        dispatch(Lifecycle.Event.ON_DESTROY);</span><br><span class="line">        <span class="comment">// just want to be sure that we won&#x27;t leak reference to an activity</span></span><br><span class="line">        mProcessListener = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(<span class="meta">@NonNull</span> Lifecycle.Event event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &lt; <span class="number">29</span>) &#123;</span><br><span class="line">            <span class="comment">//只在API 29之前的API级别上从ReportFragment分派事件。在API 29+中，</span></span><br><span class="line">            <span class="comment">//这是由reportfragment . injectifneeddin中添加的ActivityLifecycleCallbacks处理的</span></span><br><span class="line">            dispatch(getActivity(), event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>果然，验证了我们的猜想，并从 dispatch() 中的代码注释我们可知:</p>
<blockquote>
<p>只在API 29之前的API级别上从ReportFragment分派事件。在API 29+中，这是由reportfragment . injectifneeddin中添加的ActivityLifecycleCallbacks处理的</p>
</blockquote>
<p>这句话基本总结了ReportFragment在生命周期事件分发过程中的扮演的角色，结合前面讲的生命周期事件分发，我们对于生命周期事件传递到分发给具体的Lifecycle们的流程基本已经清晰了：</p>
<ul>
<li>ActivityThread产生生命周期事件并通过Instrumentation和Activity传递或调用 Activity.onXXX()</li>
<li>Activity创建时(onCreate)会被注入ReportFragment，而ReportFragment负责将生命周期事件分发给对应的Lifecycle</li>
<li>API29及以上时，Activity在处理生命周期时会通知 Application 处理生命周期回调且自身也同样处理生命周期回调，API29以上这些回调将会被ReportFragment接收，而API29以下则由FragmentController直接分发给ReportFragment。</li>
</ul>
<p>那么我们就剩下一个问题了，ReportFragment分发事件是如何到达我们注册的LifecycleObserver的？</p>
<h4 id="dispatch-Activity-Lifecycle-Event"><a href="#dispatch-Activity-Lifecycle-Event" class="headerlink" title="dispatch(Activity, Lifecycle.Event);"></a>dispatch(Activity, Lifecycle.Event);</h4><p>我们继续跟进ReportFragment中最终分发的方法<code>dispatch(Activity, Lifecycle.Event)</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@link</span>&#123;ReportFragment&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(<span class="meta">@NonNull</span> Activity activity, <span class="meta">@NonNull</span> Lifecycle.Event event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (activity <span class="keyword">instanceof</span> LifecycleRegistryOwner) &#123;</span><br><span class="line">        ((LifecycleRegistryOwner) activity).getLifecycle().handleLifecycleEvent(event);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (activity <span class="keyword">instanceof</span> LifecycleOwner) &#123;</span><br><span class="line">        Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle();</span><br><span class="line">        <span class="keyword">if</span> (lifecycle <span class="keyword">instanceof</span> LifecycleRegistry) &#123;</span><br><span class="line">            ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里都会调用<code>LifecycleRegistry.handleLifecycleEvent(Lifecycle.Event event)</code>方法，我们继续跟进：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleLifecycleEvent</span><span class="params">(<span class="meta">@NonNull</span> Lifecycle.Event event)</span> </span>&#123;</span><br><span class="line">    enforceMainThreadIfNeeded(<span class="string">&quot;handleLifecycleEvent&quot;</span>);</span><br><span class="line">    moveToState(event.getTargetState());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveToState</span><span class="params">(State next)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// something。。。 </span></span><br><span class="line">    sync();</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// something</span></span><br><span class="line">    <span class="keyword">if</span> (mState.compareTo(mObserverMap.eldest().getValue().mState) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        backwardPass(lifecycleOwner);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// something</span></span><br><span class="line">    <span class="keyword">if</span> (!mNewEventOccurred &amp;&amp; newest != <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; mState.compareTo(newest.getValue().mState) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        forwardPass(lifecycleOwner);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backwardPass</span><span class="params">(LifecycleOwner lifecycleOwner)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// // something</span></span><br><span class="line">    observer.dispatchEvent(lifecycleOwner, event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">forwardPass</span><span class="params">(LifecycleOwner lifecycleOwner)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// something</span></span><br><span class="line">    observer.dispatchEvent(lifecycleOwner, event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverWithState</span> </span>&#123;</span><br><span class="line">    State mState;</span><br><span class="line">    LifecycleEventObserver mLifecycleObserver;</span><br><span class="line"></span><br><span class="line">    ObserverWithState(LifecycleObserver observer, State initialState) &#123;</span><br><span class="line">        <span class="comment">// 注意此处，此处在初始化时，会调用此方法，读取LifecycleObserver中的运行时</span></span><br><span class="line">        <span class="comment">// 注解@OnLifecycleEvent，为后续反射方法做准备</span></span><br><span class="line">        mLifecycleObserver = Lifecycling.lifecycleEventObserver(observer);</span><br><span class="line">        mState = initialState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dispatchEvent</span><span class="params">(LifecycleOwner owner, Event event)</span> </span>&#123;</span><br><span class="line">        State newState = event.getTargetState();</span><br><span class="line">        mState = min(mState, newState);</span><br><span class="line">        mLifecycleObserver.onStateChanged(owner, event);</span><br><span class="line">        mState = newState;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>我们发现，无论如何，最终都会走到<code>(ObserverWithState)observer.dispatchEvent(lifecycleOwner, event)</code>, 即最终调用<code>LifecycleObserver.onStateChanged(owner, event)</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LifecycleEventObserver</span> <span class="keyword">extends</span> <span class="title">LifecycleObserver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onStateChanged</span><span class="params">(<span class="meta">@NonNull</span> LifecycleOwner source, <span class="meta">@NonNull</span> Lifecycle.Event event)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们 通过<code>Go to implementation(s)</code> 快捷键 <strong>【如有不清楚快捷键的，请打开 File -&gt; Settings -&gt; Keymap 搜索 Go to implementation(s)】</strong> 查看其实现以跟进其流程。<br>我们以 反射通用生命周期观察器 <code>ReflectiveGenericLifecycleObserver</code> 为例继续跟进：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 命名直译为 反射通用生命周期观察器</span><br><span class="line">class ReflectiveGenericLifecycleObserver implements LifecycleEventObserver &#123;</span><br><span class="line">    private final Object mWrapped;</span><br><span class="line">    private final CallbackInfo mInfo;</span><br><span class="line"></span><br><span class="line">    ReflectiveGenericLifecycleObserver(Object wrapped) &#123;</span><br><span class="line">        mWrapped &#x3D; wrapped;</span><br><span class="line">        mInfo &#x3D; ClassesInfoCache.sInstance.getInfo(mWrapped.getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onStateChanged(@NonNull LifecycleOwner source, @NonNull Event event) &#123;</span><br><span class="line">        mInfo.invokeCallbacks(source, event, mWrapped);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里通过委托 CallbackInfo 去执行Callback ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static class CallbackInfo &#123;</span><br><span class="line">    &#x2F;&#x2F; something</span><br><span class="line"></span><br><span class="line">    @SuppressWarnings(&quot;ConstantConditions&quot;)</span><br><span class="line">    void invokeCallbacks(LifecycleOwner source, Lifecycle.Event event, Object target) &#123;</span><br><span class="line">        invokeMethodsForEvent(mEventToHandlers.get(event), source, event, target);</span><br><span class="line">        invokeMethodsForEvent(mEventToHandlers.get(Lifecycle.Event.ON_ANY), source, event,</span><br><span class="line">                target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void invokeMethodsForEvent(List&lt;MethodReference&gt; handlers,</span><br><span class="line">            LifecycleOwner source, Lifecycle.Event event, Object mWrapped) &#123;</span><br><span class="line">        if (handlers !&#x3D; null) &#123;</span><br><span class="line">            for (int i &#x3D; handlers.size() - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">                handlers.get(i).invokeCallback(source, event, mWrapped);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static final class MethodReference &#123;</span><br><span class="line">   &#x2F;&#x2F; something</span><br><span class="line"></span><br><span class="line">    void invokeCallback(LifecycleOwner source, Lifecycle.Event event, Object target) &#123;</span><br><span class="line">        &#x2F;&#x2F;noinspection TryWithIdenticalCatches</span><br><span class="line">        try &#123;</span><br><span class="line">            switch (mCallType) &#123;</span><br><span class="line">                case CALL_TYPE_NO_ARG:</span><br><span class="line">                    mMethod.invoke(target);</span><br><span class="line">                    break;</span><br><span class="line">                case CALL_TYPE_PROVIDER:</span><br><span class="line">                    mMethod.invoke(target, source);</span><br><span class="line">                    break;</span><br><span class="line">                case CALL_TYPE_PROVIDER_WITH_EVENT:</span><br><span class="line">                    mMethod.invoke(target, source, event);</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">            throw new RuntimeException(&quot;Failed to call observer method&quot;, e.getCause());</span><br><span class="line">        &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F; something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面代码我们可以了解到，CallbackInfo.invokeCallbacks 最终调用 MethodReference.invokeCallback() 通过反射完成最终调用，其实至此，整个流程就以完结。</p>
<p>但是！！！</p>
<p>此时有一个疑问，这些这里反射使用的方法是哪里获取的，为什么他能找到我们添加了@OnLifecycleEvent注解的方法？？？</p>
<p>来，让我们反向查找一下， 既然他用了CallbackInfo，我们来找找从哪里创建了CallbackInfo，我们仔细寻找一下 CallbackInfo所在的class文件，嘿，就在内部类 CallbackInfo定义的上面一行~：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> CallbackInfo <span class="title">createInfo</span><span class="params">(Class&lt;?&gt; klass, <span class="meta">@Nullable</span> Method[] declaredMethods)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; superclass = klass.getSuperclass();</span><br><span class="line">    Map&lt;MethodReference, Lifecycle.Event&gt; handlerToEvent = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (superclass != <span class="keyword">null</span>) &#123;</span><br><span class="line">        CallbackInfo superInfo = getInfo(superclass);</span><br><span class="line">        <span class="keyword">if</span> (superInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">            handlerToEvent.putAll(superInfo.mHandlerToEvent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] interfaces = klass.getInterfaces();</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; intrfc : interfaces) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;MethodReference, Lifecycle.Event&gt; entry : getInfo(</span><br><span class="line">                intrfc).mHandlerToEvent.entrySet()) &#123;</span><br><span class="line">            verifyAndPutHandler(handlerToEvent, entry.getKey(), entry.getValue(), klass);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取class中的方法</span></span><br><span class="line">    Method[] methods = declaredMethods != <span class="keyword">null</span> ? declaredMethods : getDeclaredMethods(klass);</span><br><span class="line">    <span class="keyword">boolean</span> hasLifecycleMethods = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 遍历方法</span></span><br><span class="line">    <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">        <span class="comment">// 拿到方法的OnLifecycleEvent注解</span></span><br><span class="line">        OnLifecycleEvent annotation = method.getAnnotation(OnLifecycleEvent.class);</span><br><span class="line">        <span class="keyword">if</span> (annotation == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        hasLifecycleMethods = <span class="keyword">true</span>;</span><br><span class="line">        Class&lt;?&gt;[] params = method.getParameterTypes();</span><br><span class="line">        <span class="keyword">int</span> callType = CALL_TYPE_NO_ARG;</span><br><span class="line">        <span class="keyword">if</span> (params.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            callType = CALL_TYPE_PROVIDER;</span><br><span class="line">            <span class="keyword">if</span> (!params[<span class="number">0</span>].isAssignableFrom(LifecycleOwner.class)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                        <span class="string">&quot;invalid parameter type. Must be one and instanceof LifecycleOwner&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取关注的生命周期事件</span></span><br><span class="line">        Lifecycle.Event event = annotation.value();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (params.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            callType = CALL_TYPE_PROVIDER_WITH_EVENT;</span><br><span class="line">            <span class="keyword">if</span> (!params[<span class="number">1</span>].isAssignableFrom(Lifecycle.Event.class)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                        <span class="string">&quot;invalid parameter type. second arg must be an event&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (event != Lifecycle.Event.ON_ANY) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                        <span class="string">&quot;Second arg is supported only for ON_ANY value&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (params.length &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;cannot have more than 2 params&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 封装成MethodReference以待使用</span></span><br><span class="line">        MethodReference methodReference = <span class="keyword">new</span> MethodReference(callType, method);</span><br><span class="line">        <span class="comment">// 校验及存储 MethodReference</span></span><br><span class="line">        verifyAndPutHandler(handlerToEvent, methodReference, event, klass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 封装成 CallbackInfo 以待使用</span></span><br><span class="line">    CallbackInfo info = <span class="keyword">new</span> CallbackInfo(handlerToEvent);</span><br><span class="line">    <span class="comment">// 存储 CallbackInfo</span></span><br><span class="line">    mCallbackMap.put(klass, info);</span><br><span class="line">    mHasLifecycleMethods.put(klass, hasLifecycleMethods);</span><br><span class="line">    <span class="keyword">return</span> info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码一箩筐，看起来吓人，实际几句话，我们简单解释一下步骤：</p>
<ul>
<li>获取class中的方法 【此处class实为我们定义的LifecycleObserver，来自于addObserver】</li>
<li>遍历方法<ul>
<li>拿到方法的OnLifecycleEvent注解</li>
<li>获取关注的生命周期事件</li>
<li>封装成MethodReference以待使用</li>
<li>校验及存储 MethodReference</li>
</ul>
</li>
<li>封装成 CallbackInfo 以待使用</li>
<li>存储 CallbackInfo</li>
</ul>
<p>我们继续关注，是哪里调用他的呢？？</p>
<p>向前向前：ClassesInfoCache.hasLifecycleMethods()<br>继续向前：Lifecycling.resolveObserverCallbackType()<br>         -&gt; Lifecycling.getObserverConstructorType()<br>         -&gt; Lifecycling.lifecycleEventObserver()</p>
<p>嘿，似乎有点眼熟，没错，在前面流程中调用 LifecycleRegistry.ObserverWithState.dispatchEvent()时，它的构造方法中我们见过这段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@link</span>&#123;LifecycleRegistry.ObserverWithState&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverWithState</span> </span>&#123;</span><br><span class="line">    State mState;</span><br><span class="line">    LifecycleEventObserver mLifecycleObserver;</span><br><span class="line"></span><br><span class="line">    ObserverWithState(LifecycleObserver observer, State initialState) &#123;</span><br><span class="line">        <span class="comment">// 这里这里</span></span><br><span class="line">        mLifecycleObserver = Lifecycling.lifecycleEventObserver(observer);</span><br><span class="line">        mState = initialState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dispatchEvent</span><span class="params">(LifecycleOwner owner, Event event)</span> </span>&#123;</span><br><span class="line">        State newState = event.getTargetState();</span><br><span class="line">        mState = min(mState, newState);</span><br><span class="line">        mLifecycleObserver.onStateChanged(owner, event);</span><br><span class="line">        mState = newState;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们查找它的调用时机发现，在 addObserver中有调用其初始化：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(<span class="meta">@NonNull</span> LifecycleObserver observer)</span> </span>&#123;</span><br><span class="line">    enforceMainThreadIfNeeded(<span class="string">&quot;addObserver&quot;</span>);</span><br><span class="line">    State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED;</span><br><span class="line">    <span class="comment">// 创建 ObserverWithState</span></span><br><span class="line">    ObserverWithState statefulObserver = <span class="keyword">new</span> ObserverWithState(observer, initialState);</span><br><span class="line">    ObserverWithState previous = mObserverMap.putIfAbsent(observer, statefulObserver);</span><br><span class="line">   <span class="comment">// something</span></span><br><span class="line">        statefulObserver.dispatchEvent(lifecycleOwner, event);</span><br><span class="line">    <span class="comment">// something</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isReentrance) &#123;</span><br><span class="line">        <span class="comment">// we do sync only on the top level.</span></span><br><span class="line">        sync();</span><br><span class="line">    &#125;</span><br><span class="line">    mAddingObserverCounter--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，我们的整个流程算是完全走通了：</p>
<p><strong>注册时addObserver</strong></p>
<ul>
<li>编写LifecycleObserver并通过 Lifecycle.addObserver方法将观察者注册到LifecycleRegistry</li>
<li>LifecycleRegistry通过 ObserverWithState 调用 Lifecycling 最终通过反射获取LifecycleObserver中关注生命周期的方法和关注的生命周期，封装成MethodReference和CallbackInfo并缓存</li>
<li>ObserverWithState.dispatchEvent() 分发当前生命周期事件</li>
</ul>
<p><strong>生命周期变化时</strong></p>
<ul>
<li>ActivityThread通知Activity，Activity（无论何种方式）通知 ReportFragment</li>
<li>ReportFragment调用 LifecycleRegistry.handleLifecycleEvent(event)</li>
<li>LifecycleRegistry经过 moveToState() -&gt; sync() -&gt; backwardPass()/forwardPass() 最终调用ObserverWithState.dispatchEvent()</li>
<li>ObserverWithState.dispatchEvent() 调用LifecycleObserver.onStateChanged() 通知 CallbackInfo 通过反射执行对应方法</li>
<li>CallbackInfo.invokeCallbacks()查找到对应生命周期的 MethodReference 缓存，通过Method.invoke()调用，最终执行LifecycleObserver中关注对应生命周期的方法。</li>
</ul>
<p>我们整理一下画一个时序图：</p>
<p><img src="https://s3.ax1x.com/2021/03/01/6i7Ubj.png" alt="Lifecycle时序图.png"></p>
<h3 id="附-ProcessLifecycleOwner是如何实现应用前后台监听"><a href="#附-ProcessLifecycleOwner是如何实现应用前后台监听" class="headerlink" title="附 - ProcessLifecycleOwner是如何实现应用前后台监听"></a>附 - ProcessLifecycleOwner是如何实现应用前后台监听</h3><p>在 lifecycle-process.aar中存在AndroidManifest.xml文件，其中注册了一个provider组件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span>&gt;</span></span><br><span class="line">    &lt;provider</span><br><span class="line">        android:name=&quot;androidx.lifecycle.ProcessLifecycleOwnerInitializer&quot;</span><br><span class="line">        android:authorities=&quot;$&#123;applicationId&#125;.lifecycle-process&quot;</span><br><span class="line">        android:exported=&quot;false&quot;</span><br><span class="line">        android:multiprocess=&quot;true&quot; /&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP_PREFIX)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessLifecycleOwnerInitializer</span> <span class="keyword">extends</span> <span class="title">ContentProvider</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LifecycleDispatcher.init(getContext());</span><br><span class="line">        ProcessLifecycleOwner.init(getContext());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// others</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个组件在创建时机在应用启动时，其onCreate中做了两件事：</p>
<ul>
<li>LifecycleDispatcher.init(getContext()) 向Application中注册生命周期事件监听</li>
<li>ProcessLifecycleOwner.init(getContext()) 向ProcessLifecycleOwner中绑定Application，且为ReportFragment添加ActivityInitializationListener。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">attach</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    mHandler = <span class="keyword">new</span> Handler();</span><br><span class="line">    mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_CREATE);</span><br><span class="line">    Application app = (Application) context.getApplicationContext();</span><br><span class="line">    app.registerActivityLifecycleCallbacks(<span class="keyword">new</span> EmptyActivityLifecycleCallbacks() &#123;</span><br><span class="line">        <span class="meta">@RequiresApi(29)</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityPreCreated</span><span class="params">(<span class="meta">@NonNull</span> Activity activity,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="meta">@Nullable</span> Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// log</span></span><br><span class="line">            activity.registerActivityLifecycleCallbacks(<span class="keyword">new</span> EmptyActivityLifecycleCallbacks() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityPostStarted</span><span class="params">(<span class="meta">@NonNull</span> Activity activity)</span> </span>&#123;</span><br><span class="line">                    activityStarted();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityPostResumed</span><span class="params">(<span class="meta">@NonNull</span> Activity activity)</span> </span>&#123;</span><br><span class="line">                    activityResumed();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityCreated</span><span class="params">(Activity activity, Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// log</span></span><br><span class="line">            <span class="keyword">if</span> (Build.VERSION.SDK_INT &lt; <span class="number">29</span>) &#123;</span><br><span class="line">                <span class="comment">// 注意此处，为ReportFragment添加ActivityInitializationListener</span></span><br><span class="line">                ReportFragment.get(activity).setProcessListener(mInitializationListener);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityPaused</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 注意此处</span></span><br><span class="line">            activityPaused();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityStopped</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">             <span class="comment">// 注意此处</span></span><br><span class="line">            activityStopped();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现这里为Application添加了生命周期监听，此监听分为两个部分：</p>
<ul>
<li>创建部分分别为 api29以下和API29及以上 注册了监听</li>
<li>停止部分调用了内部方法activityPaused和activityStopped</li>
</ul>
<p>由前文可知，生命周期变化是会通知回调，最终会通知ReportFragment，在前面介绍生命周期分发过程中ReportFragment中有一部分关于ActivityInitializationListener 我没有介绍：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReportFragment</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">app</span>.<span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ActivityInitializationListener mProcessListener;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchCreate</span><span class="params">(ActivityInitializationListener listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">            listener.onCreate();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchStart</span><span class="params">(ActivityInitializationListener listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">            listener.onStart();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchResume</span><span class="params">(ActivityInitializationListener listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">            listener.onResume();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityCreated</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onActivityCreated(savedInstanceState);</span><br><span class="line">        <span class="comment">// 会通知监听器，其他生命周期也是如此</span></span><br><span class="line">        dispatchCreate(mProcessListener);</span><br><span class="line">        dispatch(Lifecycle.Event.ON_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// others</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述ProcessLifecycleOwner为ReportFragment添加 ActivityInitializationListener，在生命周期变化是会通知ProcessLifecycleOwner中的ActivityInitializationListener对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ActivityInitializationListener mInitializationListener &#x3D;</span><br><span class="line">            new ActivityInitializationListener() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void onCreate() &#123;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                public void onStart() &#123;</span><br><span class="line">                    activityStarted();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                public void onResume() &#123;</span><br><span class="line">                    activityResumed();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            </span><br><span class="line"> void activityStarted() &#123;</span><br><span class="line">        mStartedCounter++;</span><br><span class="line">        if (mStartedCounter &#x3D;&#x3D; 1 &amp;&amp; mStopSent) &#123;</span><br><span class="line">            mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_START);</span><br><span class="line">            mStopSent &#x3D; false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void activityResumed() &#123;</span><br><span class="line">        mResumedCounter++;</span><br><span class="line">        if (mResumedCounter &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            if (mPauseSent) &#123;</span><br><span class="line">                mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_RESUME);</span><br><span class="line">                mPauseSent &#x3D; false;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                mHandler.removeCallbacks(mDelayedPauseRunnable);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void activityPaused() &#123;</span><br><span class="line">        mResumedCounter--;</span><br><span class="line">        if (mResumedCounter &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            mHandler.postDelayed(mDelayedPauseRunnable, TIMEOUT_MS);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void activityStopped() &#123;</span><br><span class="line">        mStartedCounter--;</span><br><span class="line">        dispatchStopIfNeeded();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void dispatchPauseIfNeeded() &#123;</span><br><span class="line">        if (mResumedCounter &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            mPauseSent &#x3D; true;</span><br><span class="line">            mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_PAUSE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void dispatchStopIfNeeded() &#123;</span><br><span class="line">        if (mStartedCounter &#x3D;&#x3D; 0 &amp;&amp; mPauseSent) &#123;</span><br><span class="line">            mRegistry.handleLifecycleEvent(Lifecycle.Event.ON_STOP);</span><br><span class="line">            mStopSent &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>由代码可知，在展示时调用 activityStarted 和 activityResumed 并作计数递增，在停止时调用 activityPaused 和 activityStopped 做计数递减，并判断计数是否为0， 为零则执行 LifecycleRegistry.handleLifecycleEvent 通知到我们注册的 LifecycleObserver， 其通知流程与Activity生命周期分发到LifecycleObserver一致。</p>
<p>至此，整个流程结束。</p>
]]></content>
      <categories>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>Lifecycle</tag>
      </tags>
  </entry>
  <entry>
    <title>Jetpack之可观察的数据存储器-LiveData使用篇</title>
    <url>/2021/03/10/Jetpack%E4%B9%8B%E5%8F%AF%E8%A7%82%E5%AF%9F%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E5%99%A8-LiveData%E4%BD%BF%E7%94%A8%E7%AF%87/</url>
    <content><![CDATA[<blockquote>
<p>LiveData 是一种可观察的数据存储器类。与常规的可观察类不同，LiveData 具有生命周期感知能力，意指它遵循其他应用组件（如 Activity、Fragment 或 Service）的生命周期。这种感知能力可确保 LiveData 仅更新处于活跃生命周期状态的应用组件观察者。</p>
</blockquote>
<p><a href="https://github.com/TinloneX/ArchitecturalComponentExample">【本系列文章(JAVA/KOTLIN)演示案例均存储在github存储库ArchitecturalComponentExample中】</a></p>
<p><a href="https://developer.android.google.cn/topic/libraries/architecture/livedata#create_livedata_objects">【如需参考LiveData官方文档请移步此处】</a></p>
<a id="more"></a>

<h4 id="LiveData的优势"><a href="#LiveData的优势" class="headerlink" title="LiveData的优势"></a>LiveData的优势</h4><p>在正式使用之前，我们先来了解下其优势（即我们为什么要使用它），以下引用取自官方文档：</p>
<p><strong>确保界面符合数据状态</strong></p>
<blockquote>
<p>LiveData 遵循观察者模式。当底层数据发生变化时，LiveData 会通知 Observer 对象。您可以整合代码以在这些 Observer 对象中更新界面。这样一来，您无需在每次应用数据发生变化时更新界面，因为观察者会替您完成更新。</p>
</blockquote>
<p><strong>不会发生内存泄漏</strong></p>
<blockquote>
<p>观察者会绑定到 Lifecycle 对象，并在其关联的生命周期遭到销毁后进行自我清理。</p>
</blockquote>
<p><strong>不会因 Activity 停止而导致崩溃</strong></p>
<blockquote>
<p>如果观察者的生命周期处于非活跃状态（如返回栈中的 Activity），则它不会接收任何 LiveData 事件。</p>
</blockquote>
<p><strong>不再需要手动处理生命周期</strong></p>
<blockquote>
<p>界面组件只是观察相关数据，不会停止或恢复观察。LiveData 将自动管理所有这些操作，因为它在观察时可以感知相关的生命周期状态变化。</p>
</blockquote>
<p><strong>数据始终保持最新状态</strong></p>
<blockquote>
<p>如果生命周期变为非活跃状态，它会在再次变为活跃状态时接收最新的数据。例如，曾经在后台的 Activity 会在返回前台后立即接收最新的数据。</p>
</blockquote>
<p><strong>适当的配置更改</strong></p>
<blockquote>
<p>如果由于配置更改（如设备旋转）而重新创建了 Activity 或 Fragment，它会立即接收最新的可用数据。</p>
</blockquote>
<p><strong>共享资源</strong></p>
<blockquote>
<p>您可以使用单例模式扩展 LiveData 对象以封装系统服务，以便在应用中共享它们。LiveData 对象连接到系统服务一次，然后需要相应资源的任何观察者只需观察 LiveData 对象。如需了解详情，请参阅扩展 LiveData。 </p>
</blockquote>
<h4 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h4><p>LiveData作为生命周期感知组件，它的依赖包也是 lifecycle族系，通常的，我们常常将LiveData配合ViewModel使用，当然你也可以单独使用LiveData依赖。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def lifecycle_version &#x3D; &quot;2.3.0&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果你需要配合ViewModel使用，请加上</span><br><span class="line">implementation &quot;androidx.lifecycle:lifecycle-viewmodel-ktx:$lifecycle_version&quot;</span><br><span class="line">&#x2F;&#x2F; LiveData</span><br><span class="line">implementation &quot;androidx.lifecycle:lifecycle-livedata-ktx:$lifecycle_version&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>此文演示项目为ViewModel+LiveData，如有对ViewModel不了解的可以通过<a href="https://developer.android.google.cn/topic/libraries/architecture/viewmodel">【官方文档】</a>或<a href="https://tinlone.com/2021/03/07/Jetpack%E4%B9%8B%E7%95%8C%E9%9D%A2%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%84%E4%BB%B6-ViewModel/">【Jetpack之界面数据存储组件-ViewModel】</a>具体了解。</p>
<blockquote>
<p>请按照以下步骤使用 LiveData 对象：</p>
<ul>
<li>创建 LiveData 的实例以存储某种类型的数据。这通常在 ViewModel 类中完成。</li>
<li>创建可定义 onChanged() 方法的 Observer 对象，该方法可以控制当 LiveData 对象存储的数据更改时会发生什么。通常情况下，您可以在界面控制器（如 Activity 或 Fragment）中创建 Observer 对象。</li>
<li>使用 observe() 方法将 Observer 对象附加到 LiveData 对象。observe() 方法会采用 LifecycleOwner 对象。这样会使 Observer 对象订阅 LiveData 对象，以使其收到有关更改的通知。通常情况下，您可以在界面控制器（如 Activity 或 Fragment）中附加 Observer 对象。</li>
</ul>
</blockquote>
<h4 id="创建LiveData"><a href="#创建LiveData" class="headerlink" title="创建LiveData"></a>创建LiveData</h4><p>创建LiveData的方式非常简单，你只需要直接new出他的子类并传入你想要观察的数据类型泛型即可，LiveData提供<code>setValue(T t) & postValue(T t)</code>用以更新值, 可以使用<code>T getValue()</code>获取值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MutableLiveData&lt;Integer&gt; price = <span class="keyword">new</span> MutableLiveData&lt;&gt;();</span><br><span class="line"><span class="comment">// 当然你也可以这样</span></span><br><span class="line">MutableLiveData&lt;Seller&gt; mSeller = <span class="keyword">new</span> MutableLiveData&lt;&gt;();</span><br><span class="line"><span class="comment">// 定义更新LiveData值的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 注意，在初始时LiveData中包含的数据可能为空，你需要为它设置值</span></span><br><span class="line">    price.setValue(price.getValue() == <span class="keyword">null</span> ? <span class="number">0</span> : price.getValue() + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="观察LiveData"><a href="#观察LiveData" class="headerlink" title="观察LiveData"></a>观察LiveData</h4><p>在大多数情况下，应用组件的 onCreate() 方法是开始观察 LiveData 对象的正确着手点，原因如下：</p>
<ul>
<li>确保系统不会从 Activity 或 Fragment 的 onResume() 方法进行冗余调用。</li>
<li>确保 Activity 或 Fragment 变为活跃状态后具有可以立即显示的数据。一旦应用组件处于 STARTED 状态，就会从它正在观察的 LiveData 对象接收最新值。只有在设置了要观察的 LiveData 对象时，才会发生这种情况。</li>
</ul>
<p>LiveData订阅<code>observe(@NonNull LifecycleOwner owner, @NonNull Observer<? super T> observer)</code>需要两个参数，生命周期拥有者LifecycleOwner和观察者Observer。</p>
<p>一般的，继承自AndroidX包中的Activity/Fragment组件(api &gt;= 26)已自行实现LifecycleOwner。</p>
<p><em>在未强调说明的情况下，本文代码块均保持使用Java8特性。</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 建立订阅关系</span></span><br><span class="line">viewModel.price.observe(<span class="keyword">this</span>, <span class="keyword">this</span>::updatePriceButton);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义Observer.onChanged(T t)回调执行的函数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updatePriceButton</span><span class="params">(<span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 在未强调时，此处均为日志打印，详细代码见Demo</span></span><br><span class="line">   <span class="comment">// 后续代码块中将简化或不写类似实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个onClick触发LiveData值的更新</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countUp</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">    viewModel.countUp();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看一下执行效果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">订阅数据变化👉 0</span><br><span class="line">订阅数据变化👉 1</span><br><span class="line">订阅数据变化👉 2</span><br></pre></td></tr></table></figure>
<p>当我们改变被观察的值时，我们的观察者也如预期被通知到了，这样便实现了最简LiveData数据观察流程（详细代码<a href="https://github.com/TinloneX/ArchitecturalComponentExample/tree/main/LiveDataExample/LiveDataExampleJava/app/src/main/java/com/tinlone/livedataexamplejava">【Java示例请参见此处】</a>、<a href="https://github.com/TinloneX/ArchitecturalComponentExample/tree/main/LiveDataExample/LiveDataExampleKotlin/app/src/main/java/com/tinlone/livedataexamplekotlin">【Kotlin示例请参见此处】</a>）。</p>
<h4 id="扩展LiveData"><a href="#扩展LiveData" class="headerlink" title="扩展LiveData"></a>扩展LiveData</h4><p>你可以继承LiveData自行实现LiveData的数据变更状态的分发，已演示项目为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPriceLiveData</span> <span class="keyword">extends</span> <span class="title">LiveData</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">&quot;LiveDataExampleLog&quot;</span>;</span><br><span class="line">    <span class="comment">// 此处定义监听，监听触发时调用 setValue(T t)方法</span></span><br><span class="line">    PriceManager.PriceListener listener = <span class="keyword">this</span>::setValue;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 同样的你可以将LiveData设置成单例，此处不做实现</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 此处定义生命周期处于 STARTED 或 RESUMED 状态时的操作</span></span><br><span class="line">        Log.i(TAG, <span class="string">&quot;MyPriceLiveData.onActive&quot;</span>);</span><br><span class="line">        PriceManager.getInstance().requestPriceUpdate(listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onInactive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.i(TAG, <span class="string">&quot;MyPriceLiveData.onInactive&quot;</span>);</span><br><span class="line">        <span class="comment">// 此处定义没有任何活跃观察者时，解除对PriceManager的关联</span></span><br><span class="line">        PriceManager.getInstance().removeUpdateListener(listener);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们像先前一样使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; ViewModel中</span><br><span class="line">private final PriceManager priceManager &#x3D; PriceManager.getInstance();</span><br><span class="line">MyPriceLiveData extensionData &#x3D; new MyPriceLiveData();</span><br><span class="line"></span><br><span class="line">public void updatePriceForExtension() &#123;</span><br><span class="line">    priceManager.updatePrice(priceManager.price + 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Activity&#x2F;Fragment中</span><br><span class="line">&#x2F;&#x2F; 订阅LiveData扩展</span><br><span class="line">viewModel.extensionData.observe(this, this::updateExtensionButton);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 点击事件触发值更新</span><br><span class="line">public void extensionData(View view) &#123;</span><br><span class="line">    viewModel.updatePriceForExtension();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们运行查看结果，并做息屏亮屏操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 点击按钮</span><br><span class="line">测试扩展LiveData👉 1</span><br><span class="line">测试扩展LiveData👉 2</span><br><span class="line">&#x2F;&#x2F; 息屏</span><br><span class="line">MyPriceLiveData.onInactive</span><br><span class="line">&#x2F;&#x2F; 亮屏</span><br><span class="line">MyPriceLiveData.onActive</span><br><span class="line">&#x2F;&#x2F; 此处PriceManager未做值未改变时不更新的限制，故会重新分发值变化</span><br><span class="line">测试扩展LiveData👉 2</span><br></pre></td></tr></table></figure>
<p>我们的扩展LiveData会在息屏/亮屏时触发<code> onInactive()/ onActive()</code>回调，从而执行我们的自定义实现代码。</p>
<h4 id="转换-LiveData"><a href="#转换-LiveData" class="headerlink" title="转换 LiveData"></a>转换 LiveData</h4><p>LiveData为我们提供了数据转换功能，包含<code>Transformations.map()</code>、<code>Transformations.switchMap()</code>两种方式，其调用方式一致，区别在于 map() 的第二个参数（可理解为转换器）需返回泛型T，而switchMap() 的第二个参数（可理解为转换器）需返回LiveData<T>。</p>
<p>map()转换：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ViewModel中</span></span><br><span class="line">MutableLiveData&lt;Integer&gt; priceForMap = <span class="keyword">new</span> MutableLiveData&lt;&gt;();</span><br><span class="line"><span class="comment">// 观察price并转换为字符串的可观察对象</span></span><br><span class="line">LiveData&lt;String&gt; userThink = Transformations.map(priceForMap,</span><br><span class="line">        price -&gt; price + (price % <span class="number">2</span> == <span class="number">0</span> ? <span class="string">&quot;块刚刚好&quot;</span> : <span class="string">&quot;块贵了&quot;</span>));</span><br><span class="line"><span class="comment">// 更新price值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPriceForMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    priceForMap.setValue(priceForMap.getValue() == <span class="keyword">null</span> ? <span class="number">0</span> : priceForMap.getValue() + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Activity/Fragment中使用</span></span><br><span class="line"><span class="comment">// 数据转换 订阅价格的转换 =&gt; 用户价格感知</span></span><br><span class="line">viewModel.userThink.observe(<span class="keyword">this</span>, <span class="keyword">this</span>::updateUserThinkButton);</span><br></pre></td></tr></table></figure>
<p>我们执行观察结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">转换数据(map)👉 0块刚刚好</span><br><span class="line">转换数据(map)👉 1块贵了</span><br><span class="line">转换数据(map)👉 2块刚刚好</span><br></pre></td></tr></table></figure>
<p>switchMap()转换：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 转换前的LiveData</span></span><br><span class="line">MutableLiveData&lt;Integer&gt; priceForSwitch = <span class="keyword">new</span> MutableLiveData&lt;&gt;();</span><br><span class="line"><span class="comment">// 转换后的目标LiveData</span></span><br><span class="line">MutableLiveData&lt;String&gt; sellerThink = <span class="keyword">new</span> MutableLiveData&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> MutableLiveData&lt;String&gt; <span class="title">getSellerThink</span><span class="params">(<span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line">    String think = price + (price &lt;= <span class="number">3</span> ? <span class="string">&quot;穷鬼&quot;</span> : <span class="string">&quot;冤大头&quot;</span>);</span><br><span class="line">    sellerThink.setValue(think);</span><br><span class="line">    <span class="keyword">return</span> sellerThink;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更新price值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPriceForSeller</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    priceForSwitch.setValue(priceForSwitch.getValue() == <span class="keyword">null</span> ? <span class="number">0</span> : priceForSwitch.getValue() + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 转换结果LiveData</span></span><br><span class="line">LiveData&lt;String&gt; switchToUserLook = Transformations.switchMap(priceForSwitch, <span class="keyword">this</span>::getSellerThink);</span><br></pre></td></tr></table></figure>
<p>调用方式与map()一致，你可以对转换后的LiveData观测，也可以对转换结果LiveData观测，此处省略，我们来观察其执行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我是商家想法的订阅：0穷鬼</span><br><span class="line">转换数据(switchMap)👉 0穷鬼</span><br><span class="line">我是商家想法的订阅：1穷鬼</span><br><span class="line">转换数据(switchMap)👉 1穷鬼</span><br></pre></td></tr></table></figure>
<p>对转换后的LiveData观测及以对转换结果LiveData观测均能收到响应。为判断2个LiveData是否观察的是同一个对象，我们将转换后的目标及结果改造为对象，观察其hashCode是否相等：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 转换后的目标LiveData</span></span><br><span class="line">MutableLiveData&lt;Seller&gt; mSeller = <span class="keyword">new</span> MutableLiveData&lt;&gt;();</span><br><span class="line"><span class="comment">// 转换结果LiveData</span></span><br><span class="line">LiveData&lt;Seller&gt; switchToSeller = Transformations.switchMap(priceForSeller, <span class="keyword">this</span>::getSeller);</span><br></pre></td></tr></table></figure>
<p>执行观察结果打印：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">订阅的Seller.hashCode() &#x3D; 84056966</span><br><span class="line">viewModel.mSeller.getValue().hashCode() &#x3D; 84056966</span><br><span class="line">viewModel.switchToSeller.getValue().hashCode() &#x3D; 84056966</span><br></pre></td></tr></table></figure>
<p>我们发现，转换后的目标LiveData及转换结果LiveData实际观察对象为同一个，不会为数据创建副本。</p>
<h4 id="合并LiveData"><a href="#合并LiveData" class="headerlink" title="合并LiveData"></a>合并LiveData</h4><blockquote>
<p>MediatorLiveData 是 LiveData 的子类，允许您合并多个 LiveData 源。只要任何原始的 LiveData 源对象发生更改，就会触发 MediatorLiveData 对象的观察者。</p>
</blockquote>
<p>首先我们需要定义一个合并LiveData源：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MediatorLiveData&lt;Object&gt; mediatorLiveData = <span class="keyword">new</span> MediatorLiveData&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>并在使用时，为其添加观察的LiveData源：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 合并观察1</span></span><br><span class="line">viewModel.mediatorLiveData.addSource(viewModel.switchToSeller, <span class="keyword">this</span>::onMediatorData);</span><br><span class="line"><span class="comment">// 合并观察2</span></span><br><span class="line">viewModel.mediatorLiveData.addSource(viewModel.userThink, <span class="keyword">this</span>::onMediatorData);</span><br><span class="line"><span class="comment">// 观察数据合并</span></span><br><span class="line">viewModel.mediatorLiveData.observe(<span class="keyword">this</span>,<span class="keyword">this</span>::onMediatorData);</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> mediatorFlag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发不同的数据更新</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mediatorData</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mediatorFlag) &#123;</span><br><span class="line">        viewModel.setPriceForSeller();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        viewModel.setPriceForMap();</span><br><span class="line">    &#125;</span><br><span class="line">    mediatorFlag = !mediatorFlag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们观察其执行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 第一次触发</span><br><span class="line">转换数据(map)👉 0块刚刚好</span><br><span class="line">合并数据👉 0块刚刚好</span><br><span class="line">&#x2F;&#x2F; 第二次触发</span><br><span class="line">我是商家想法的订阅：0穷鬼</span><br><span class="line">合并数据👉 0穷鬼</span><br><span class="line">转换数据(switchMap)👉 0穷鬼</span><br></pre></td></tr></table></figure>
<p>我们发现，在触发单个LiveData值变化时除了其本身LiveData的观察者被触发，合并数据的观察者也会被触发。</p>
<p>对于此API的应用场景，官方有提出以下场景：</p>
<blockquote>
<p>例如，如果界面中有可以从本地数据库或网络更新的 LiveData 对象，则可以向 MediatorLiveData 对象添加以下源：</p>
<ul>
<li>与存储在数据库中的数据关联的 LiveData 对象。</li>
<li>与从网络访问的数据关联的 LiveData 对象。</li>
</ul>
</blockquote>
<blockquote>
<p>您的 Activity 只需观察 MediatorLiveData 对象即可从这两个源接收更新。</p>
</blockquote>
<h3 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h3><p>LiveData 是生命周期相关的数据观察者，你可以通过自定义LiveData、使用map()及switchMap()转换LiveData源为你需要的LiveData源、你也可以合并观察不同的LiveData源的变化，这些方式基本能满足对一般数据观察的需求。</p>
]]></content>
      <categories>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>LiveData</tag>
      </tags>
  </entry>
  <entry>
    <title>性能优化之内存优化</title>
    <url>/2021/04/04/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>JAVA是在JVM所虚拟出的内存环境中运行的，JVM的内存可分为三个区：</p>
<p>堆(heap)、栈(stack)和方法区(method)。</p>
<p>栈(stack)</p>
<p>是简单的数据结构，但在计算机中使用广泛。栈最显著的特征是：LIFO(Last In, First Out, 后进先出),栈中只存放基本类型和对象的引用</p>
<p>堆(heap)</p>
<p>堆内存用于存放由new创建的对象和数组。在堆中分配的内存，由java虚拟机自动垃圾回收器来管理。JVM只有一个堆区(heap)被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本身。</p>
<p>方法区(method)</p>
<p>又叫静态区，跟堆一样，被所有的线程共享。方法区包含所有的class和static变量</p>
<a id="more"></a>

<h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，导致一直占据该内存单元，直至程序结束，都无法再使用该内存单元。</p>
<h4 id="内存泄漏常见原因"><a href="#内存泄漏常见原因" class="headerlink" title="内存泄漏常见原因"></a>内存泄漏常见原因</h4><p><strong>1. Context的不当引用</strong></p>
<p>当持有Context的对象生命周期较长时，持有的Context即使被销毁也不会被回收掉。</p>
<ul>
<li>单例对象直接或间接持有Context：</li>
</ul>
<pre><code>单例直接持有Activity对象，或通过持有Fragment、View等间接持有Context对象。
</code></pre>
<ul>
<li><p>Activity/Fragment中的非静态内部类、匿名内部类</p>
<p>  Activity中使用非静态内部类/匿名内部类，如Handler及各类事件监听。当内部类生命周期较长(耗时)时，若Activity被销毁，易造成内存泄漏或崩溃。</p>
</li>
<li><p>多线程异步回调（崩溃）</p>
<p>  子线程执行后回调主线程方法，若持有主线程Handler或Context，当Activity销毁，此时易出现内存泄漏或崩溃。 </p>
</li>
</ul>
<p>解决办法：</p>
<ul>
<li>非必要情况下，不建议这样编程；</li>
<li>单例生命周期敏感且不持有生命周期较短的Context对象强引用：若需使用Activity对象，应对Activity做弱引用封装，且应提供解除引用的方法，在Activity销毁时解除引用；必须持有context的，能使用ApplicationContext则尽量使用Application；</li>
<li>对于Handler，建议不使用匿名声明的方式创建，在Activity销毁时调用Handler.removeCallback，解除对Activity的引用；</li>
<li>使用内部类的情况，可使用静态内部类，需持有Activity的应对Activity做弱引用封装</li>
<li>对于内部类或线程操作耗时/异步的情况，在Activity销毁时应通知对应内部类解除对Activity的引用，清理未执行完毕的线程。</li>
</ul>
<p><strong>2. 资源未回收</strong></p>
<ul>
<li><p>bind/unbind、register/unregister、start/stop、run/cancel </p>
<p>  在一些组件使用过程中，应注意其绑定和解绑、执行和取消等操作应成对存在，否则若其持有Activity的引用，将会在Activity被销毁时产生内存泄漏或崩溃，如属性动画、广播、bind服务等。</p>
</li>
<li><p>Closeable对象未调用close()</p>
<p>  IO流/数据库游标cursor应在使用完毕后调用close()方法，即使它执行失败/错误也应调用关闭，否则将造成内存泄漏甚至崩溃。</p>
</li>
<li><p>bitmap</p>
<p>  bitmap资源在使用完成后，未主动调用recycle()并置空，在系统未主动回收时会造成大量内存占用。</p>
</li>
</ul>
<p>解决办法：</p>
<ul>
<li>对于组件的使用，应注意规范，Activity销毁时及时释放资源：例如EventBus.getDefault().register()/unregister()；   ButterKnife.bind(this)/unbind()； bindService()/unbindService()等；</li>
<li>Closeable对象在使用完毕后应及时调用close()；可使用 <code>try(IO对象)</code>的方式避免遗忘；特别的对于具有缓存(Flushable)功能的流，应注意调用flush()保证数据完整性；</li>
<li>bitmap资源在使用完成后，主动调用recycle()并置空</li>
</ul>
<p><strong>3. 创建/保存大量对象</strong></p>
<ul>
<li><p>频繁调用的方法中创建对象，例如onDraw()、onResume()</p>
<p>  在频繁调用的方法中创建对象（即使是局部变量），会导致一定时间内，内存堆积，若GC回收不及时会占用大量内存空间，若GC频繁回收则会产生内存抖动，导致卡顿。</p>
</li>
<li><p>声明的全局List或Map（只进不出/未及时清理）</p>
<p>  全局声明的List或Map，若存放大量对象且对象不常使用，将占用大量内存且无法回收。    </p>
</li>
<li><p>未及时清理的缓存对象</p>
<p>  在用户体验优化上我们常常使用缓存提升加载速度，若缓存并非经常使用的情况下，将会白白占用内存空间。</p>
</li>
</ul>
<p>解决办法：</p>
<ul>
<li>尽量避免在频繁调用的方法中创建对象，必要情况下使用享元模式，控制对象生成数量；</li>
<li>全局List和Map等集合容器，不使用的元素应及时移除；</li>
<li>缓存应根据设备内存状况设置最大存储容量，并建立LRU等缓存机制，在保证体验的情况下最大程度优化内存；</li>
</ul>
<p><strong>4. WebView、MapView</strong></p>
<p>原生WebView存在已知的内存泄漏风险，针对这类性能消耗较大的组件（控件），若未处理好其内存问题，将会是应用内存管理的灾难。</p>
<p>解决办法：</p>
<ul>
<li>对于WebView、MapView等，应主动管理其创建/销毁/回收流程，让内存尽快的释放出来；</li>
<li>有条件的，可以为其申请单独的进程，提升主进程的稳定性，减小主进程的内存压力；</li>
</ul>
<h3 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h3><p>系统会给每个APP分配内存也就是Heap Size值。当APP占用的内存加上我们申请的内存资源超过了Dalvik虚拟机的最大内存时就会抛出的Out Of Memory异常。</p>
<ul>
<li>java.lang.OutOfMemoryError:Javaheapspace：堆内存不够或程序中有死循环</li>
<li>java.lang.OutOfMemoryError:GCoverheadlimitexceeded：当GC为释放很小空间占用大量时间时抛出；堆太小，没有足够的内存</li>
<li>java.lang.OutOfMemoryError:PermGenspace：P区内存不够</li>
<li>java.lang.OutOfMemoryError:Directbuffermemory：Directbuffer内存不足</li>
<li>java.lang.OutOfMemoryError:unabletocreatenewnativethread：Stack空间不足以创建额外的线程，创建的线程过多或Stack空间太小</li>
<li>java.lang.StackOverflowError：线程栈的溢出，方法调用层次过多或线程栈太小。</li>
</ul>
<p>解决办法：</p>
<ul>
<li>对于启动参数内存值设定的过小的情况，可以使用修改启动参数的方法解决：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-Xms3062m &#x2F;&#x2F; 提升堆内存</span><br><span class="line">-XX:-UseGCOverheadLimit &#x2F;&#x2F; 限制使用内存</span><br><span class="line">&#x2F;&#x2F; JVM的Perm区主要用于存放Class和Meta信息的,Class在被Loader时就会被放到PermGenspace，这个区域成为年老代，GC在主程序运行期间不会对年老区进行清理，</span><br><span class="line">&#x2F;&#x2F; 默认是64M大小，当程序需要加载的对象比较多时，超过64M就会报这部分内存溢出了，需要加大内存分配，一般128m足够</span><br><span class="line">-XX:MaxPermSize&#x3D;128m</span><br><span class="line">-XXermSize&#x3D;128m</span><br><span class="line">-XX:MaxDirectMemorySize&#x3D;128m  &#x2F;&#x2F; 调整Directbuffer内存大小</span><br></pre></td></tr></table></figure>
<ul>
<li>检查代码中是否存在死循环或递归层次较深的场景，修复或优化此类代码；</li>
<li>优化内存，减少内存泄漏，使内存保持在健康良好的状态。</li>
</ul>
<h3 id="内存优化"><a href="#内存优化" class="headerlink" title="内存优化"></a>内存优化</h3><p>内存优化主要从减少内存占用、杜绝内存泄漏、提升应用内存限制这几个方面考量，内存优化是个没有止境的话题，当然不是最优就是最好的，它需要在内存和体验上找寻一个平衡点，当然，内存泄漏是越少越好。</p>
<h4 id="减少内存占用"><a href="#减少内存占用" class="headerlink" title="减少内存占用"></a>减少内存占用</h4><ul>
<li><p><strong>对象</strong></p>
<ul>
<li>避免重复创建对象，能使用对象池的尽量使用对象池，如Message.obtain()；</li>
<li>避免频繁创建对象，对于频繁调用的方法，尽量不在其中创建大量对象；</li>
<li>及时回收对象，对于不使用或不频繁使用的对象应主动释放</li>
</ul>
</li>
<li><p><strong>资源</strong></p>
<ul>
<li>对于Bitmap，加载前应针对场景对其进行尺寸和数据长度压缩，使用后应及时释放；</li>
<li>对于icon资源，应使用对应分辨率的切图，避免icon加载时系统缩放占用额外的内存空间；</li>
<li>对于文件流和游标，使用完毕后应及时关闭，避免IO占用额外的内存空间；</li>
<li>珍惜线程资源，使用线程池管理线程，减少线程的创建</li>
</ul>
</li>
<li><p><strong>缓存</strong></p>
<ul>
<li>对于内存消耗较大且不常使用的数据避免存储在内存中</li>
<li>缓存应考虑设备及应用的内存限制，设定合理的缓存容量及缓存策略</li>
</ul>
</li>
</ul>
<h4 id="杜绝内存泄漏"><a href="#杜绝内存泄漏" class="headerlink" title="杜绝内存泄漏"></a>杜绝内存泄漏</h4><ul>
<li><p><strong>编码规范</strong></p>
<ul>
<li>依照前文内存泄漏相关说明，检查代码，减少内存泄漏</li>
</ul>
</li>
<li><p><strong>检查工具</strong></p>
<ul>
<li>dumpsys meminfo package_name|pid<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">adb shell dumpsys meminfo com.company.project</span><br></pre></td></tr></table></figure></li>
<li>%AndroidSDK%\platform-tools\systrace\systrace.py</li>
</ul>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 指定版本python2.7</span><br><span class="line">&#x2F;&#x2F; -o： 指定文件输出位置和文件名</span><br><span class="line">&#x2F;&#x2F; -t： 抓取systrace的时间长度</span><br><span class="line">&#x2F;&#x2F; -a： 指定特殊进程包名 </span><br><span class="line">python %AndroidSDK%\platform-tools\systrace\systrace.py -a com.company.project -t 10 -o trace.html</span><br></pre></td></tr></table></figure>
<ul>
<li>LeakCanary</li>
<li>MAT（Memory Analyzer Tool）</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>内存优化</tag>
      </tags>
  </entry>
</search>
