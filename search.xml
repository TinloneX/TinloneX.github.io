<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>WorkManager基本使用及源码分析(三) - SystemAlarmService</title>
    <url>/2021/02/06/WorkManager%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%B8%89)%20-%20SystemAlarmService/</url>
    <content><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="#part_source">源码篇</a><ul>
<li><a href="#SystemAlarmService">2.1.1 SystemAlarmService</a><ul>
<li><a href="#processCommand">如何处置命令 (processCommand)</a></li>
<li><a href="#CommandHandler">如何分发命令 (CommandHandler)</a><ul>
<li><a href="#startWork">是怎么调用到Worker.doWork()的？</a></li>
</ul>
</li>
<li><a href="#DequeueAndCheckForCompletion">如何完成回调 (DequeueAndCheckForCompletion)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="源码篇"><a href="#源码篇" class="headerlink" title=" 源码篇"></a><span id="part_source"> 源码篇</h3><p>上一篇中我们了解了WorkManager使用的的主要组件，猜测了各个组件的作用，并简单介绍了WorkManager是如何初始化的。本篇将延续前文，介绍WorkManager中Service组件之一的SystemAlarmService。</p>
<p><strong><span id="SystemAlarmService"> SystemAlarmService</strong></p>
<blockquote>
<p>Service invoked by {@link android.app.AlarmManager} to run work tasks.</p>
</blockquote>
<p>服务将被AlarmManager调用来执行工作任务.</p>
<a id="more"></a>

<p>注: 此节中凡 描述中的 <strong>“命令”</strong> 及 <strong>“intent”</strong> 均指代包括 <strong>[规划任务、重新规划任务、约束条件改变、执行完毕、延时执行、停止执行…]</strong> 的事件，可视作状态模式。</p>
<p><strong><span id="processCommand"> 如何处置命令 (processCommand)</strong></p>
<p>SystemAlarmService 主要逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemAlarmService</span> <span class="keyword">extends</span> <span class="title">LifecycleService</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">SystemAlarmDispatcher</span>.<span class="title">CommandsCompletedListener</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">        <span class="comment">// onCreate时执行initializeDispatcher()初始化并绑定闹钟事件调度器</span></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStartCommand(intent, flags, startId);</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">        <span class="comment">// 添加调度事件,若当前无任务则立即调度</span></span><br><span class="line">        <span class="keyword">if</span> (intent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mDispatcher.add(intent, startId);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果服务崩溃，我们希望所有未确认的意图都得到重新交付。</span></span><br><span class="line">        <span class="keyword">return</span> Service.START_REDELIVER_INTENT;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到, 此服务在创建时初始化并绑定闹钟事件调度器,当服务被start时,若有intent事件,则将intent传递给调度器. 调度器收到intent后执行以下操作:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(<span class="meta">@NonNull</span> <span class="keyword">final</span> Intent intent, <span class="keyword">final</span> <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">    assertMainThread();</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    <span class="comment">// 保证命令列表安全,只进或只出</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mIntents) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> hasCommands = !mIntents.isEmpty();</span><br><span class="line">        mIntents.add(intent);</span><br><span class="line">        <span class="keyword">if</span> (!hasCommands) &#123;</span><br><span class="line">            <span class="comment">// 如果是第一个命令则执行</span></span><br><span class="line">            <span class="comment">// 一般情况下,若上一个命令执行完毕会被移除</span></span><br><span class="line">            processCommand();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当闹钟调度器收到新命令,会将新命令放入命令集合，若新命令为集合中第一个命令则直接进入执行命令逻辑中，否则不处理，前一命令执行完毕后再次调用执行命令：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processCommand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    mWorkManager.getWorkTaskExecutor().executeOnBackgroundThread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">     <span class="keyword">try</span> &#123;   </span><br><span class="line">        <span class="comment">// 若当前命令不为空，则将命令交给状态机执行</span></span><br><span class="line">        mCommandHandler.onHandleIntent(mCurrentIntent, startId, SystemAlarmDispatcher.<span class="keyword">this</span>);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;&#125;</span><br><span class="line">     <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 当前命令执行完毕，回调SystemAlarmDispatcher处理命令集以及后续操作</span></span><br><span class="line">        postOnMainThread( <span class="keyword">new</span> DequeueAndCheckForCompletion(SystemAlarmDispatcher.<span class="keyword">this</span>));</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当<code>processCommand</code>被调用，将开启新的线程处理命令，主要干了两件事：</p>
<ul>
<li>将命令交给CommandHandler分发[规划任务、重新规划任务、约束条件改变、执行完毕…]事件</li>
<li>将事件处理完毕回调到闹钟事件调度器，由调度器处理后续事宜。</li>
</ul>
<p>我们来依次跟进这两件事：</p>
<p><strong><span id="CommandHandler"> CommandHandler如何分发命令</strong></p>
<p>我们前面看到<code>processCommand</code>中调用<code>CommandHandler</code>分发命令，其代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WorkerThread</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onHandleIntent</span><span class="params">(<span class="meta">@NonNull</span> Intent intent,<span class="keyword">int</span> startId, <span class="meta">@NonNull</span> SystemAlarmDispatcher dispatcher)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String action = intent.getAction();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ACTION_CONSTRAINTS_CHANGED.equals(action)) &#123;</span><br><span class="line">        <span class="comment">// 约束条件改变</span></span><br><span class="line">        handleConstraintsChanged(intent, startId, dispatcher);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ACTION_RESCHEDULE.equals(action)) &#123;</span><br><span class="line">        <span class="comment">// 异常中断，需重新规划</span></span><br><span class="line">        handleReschedule(intent, startId, dispatcher);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Bundle extras = intent.getExtras();</span><br><span class="line">        <span class="keyword">if</span> (!hasKeys(extras, KEY_WORKSPEC_ID)) &#123;</span><br><span class="line">            <span class="comment">// log error</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ACTION_SCHEDULE_WORK.equals(action)) &#123;</span><br><span class="line">                <span class="comment">// 规划任务</span></span><br><span class="line">                handleScheduleWorkIntent(intent, startId, dispatcher);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ACTION_DELAY_MET.equals(action)) &#123;</span><br><span class="line">                <span class="comment">// 时延到点</span></span><br><span class="line">                handleDelayMet(intent, startId, dispatcher);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ACTION_STOP_WORK.equals(action)) &#123;</span><br><span class="line">                <span class="comment">// 取消任务</span></span><br><span class="line">                handleStopWork(intent, dispatcher);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ACTION_EXECUTION_COMPLETED.equals(action)) &#123;</span><br><span class="line">                <span class="comment">// 完成任务</span></span><br><span class="line">                handleExecutionCompleted(intent, startId);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// log error</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到这里主要依据命令(intent)的action执行命令分发操作，此处我们主要关注<code>handleDelayMet</code> 时延结束后，处理任务的主线：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleDelayMet</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@NonNull</span> Intent intent,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> startId,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@NonNull</span> SystemAlarmDispatcher dispatcher)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Bundle extras = intent.getExtras();</span><br><span class="line">    <span class="comment">// 保证任务处理线程安全</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        String workSpecId = extras.getString(KEY_WORKSPEC_ID);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check to see if we are already handling an ACTION_DELAY_MET for the WorkSpec.</span></span><br><span class="line">        <span class="comment">// If we are, then there is nothing for us to do.</span></span><br><span class="line">        <span class="comment">// 检查该任务是否已经在即将执行队伍(map)中，如果是则不再重复操作</span></span><br><span class="line">        <span class="keyword">if</span> (!mPendingDelayMet.containsKey(workSpecId)) &#123;</span><br><span class="line">            DelayMetCommandHandler delayMetCommandHandler = <span class="keyword">new</span> DelayMetCommandHandler(mContext, startId, workSpecId, dispatcher);</span><br><span class="line">            <span class="comment">// 将任务放入即将执行队伍(map)中</span></span><br><span class="line">            mPendingDelayMet.put(workSpecId, delayMetCommandHandler);</span><br><span class="line">            <span class="comment">// 处理任务</span></span><br><span class="line">            delayMetCommandHandler.handleProcessWork();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// log error</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，<code>CommandHandler</code>中维护了一个 mPendingDelayMet的Map来保证单次任务不被多次处理，若命令未被处理过，则将其加入到队伍中，然后调用<code>delayMetCommandHandler.handleProcessWork()</code>去处理任务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WorkerThread</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleProcessWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建WakeLocks</span></span><br><span class="line">    mWakeLock = WakeLocks.newWakeLock(...);</span><br><span class="line">    <span class="comment">// 获取WorkSpec</span></span><br><span class="line">    WorkSpec workSpec = mDispatcher.getWorkManager().getWorkDatabase().workSpecDao().getWorkSpec(mWorkSpecId);</span><br><span class="line">    <span class="comment">// 处理通常不会发生的情况 - 未获取到WorkSpec。</span></span><br><span class="line">    <span class="comment">// 取消工作应该删除alarm，但是如果alarm已经触发，那么就触发一个stop work请求来删除挂起的delay met命令处理程序。</span></span><br><span class="line">    <span class="keyword">if</span> (workSpec == <span class="keyword">null</span>) &#123;</span><br><span class="line">        stopWork();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 跟踪工作任务是否有约束</span></span><br><span class="line">    mHasConstraints = workSpec.hasConstraints();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mHasConstraints) &#123;</span><br><span class="line">        <span class="comment">// 若无约束</span></span><br><span class="line">        onAllConstraintsMet(Collections.singletonList(mWorkSpecId));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 允许跟踪器报告约束更改</span></span><br><span class="line">        <span class="comment">// 此处可见，我们可以将时延视作一种特殊的约束</span></span><br><span class="line">        mWorkConstraintsTracker.replace(Collections.singletonList(workSpec));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里判断了任务状态及约束状态，依据约束状态执行任务或更新任务状态，<br>执行任务时：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onAllConstraintsMet(@NonNull List&lt;String&gt; workSpecIds) &#123;</span><br><span class="line">    &#x2F;&#x2F; 保证任务正确    </span><br><span class="line">    if (!workSpecIds.contains(mWorkSpecId)) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 保证执行安全</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        if (mCurrentState &#x3D;&#x3D; STATE_INITIAL) &#123;</span><br><span class="line">            &#x2F;&#x2F; 更改状态</span><br><span class="line">            mCurrentState &#x3D; STATE_START_REQUESTED;</span><br><span class="line">            &#x2F;&#x2F; startWork &#x3D;&gt; doWork</span><br><span class="line">            &#x2F;&#x2F;这里没有使用WorkManagerImpl#startWork()，因为我们需要知道处理器是否在这里将工作排队</span><br><span class="line">            boolean isEnqueued &#x3D; mDispatcher.getProcessor().startWork(mWorkSpecId);</span><br><span class="line">            &#x2F;&#x2F; 若任务状态是轮询</span><br><span class="line">            if (isEnqueued) &#123;</span><br><span class="line">               &#x2F;&#x2F; 设置计时器以强制已进入队列的任务配额</span><br><span class="line">                mDispatcher.getWorkTimer()</span><br><span class="line">                        .startTimer(mWorkSpecId, WORK_PROCESSING_TIME_IN_MS, this);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; 执行完毕或取消，则清除状态</span><br><span class="line">                cleanUp();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Logger.get().debug(TAG, String.format(&quot;Already started work for %s&quot;, mWorkSpecId));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里最终改变任务状态并调用<code>Processor.startWork()</code>执行任务，我们将关注<code>Processor.startWork()</code>，这个方法最终执行到我们定义的Worker中<code>doWork()</code>方法，并且前面说到的WorkManager中负责任务执行的Service们最终都会调用到<code>Processor.startWork()</code>。</p>
<p>由于内容流程较长且属于公共流程，关于<code>Processor.startWork()</code>将单独整理未一小节，<a href="https://tinlone.com/2021/02/06/WorkManager%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%BA%94)%20-%20Processor/">点击此处查看</a>。</p>
<p><strong><span id="DequeueAndCheckForCompletion"> DequeueAndCheckForCompletion如何完成回调</strong></p>
<p><code>DequeueAndCheckForCompletion</code> 是一个Runnable对象，<code>postOnMainThread</code>时调用run：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mDispatcher.dequeueAndCheckForCompletion();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终回调到<code>dequeueAndCheckForCompletion</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void dequeueAndCheckForCompletion() &#123;</span><br><span class="line">   &#x2F;&#x2F; 保证mIntents命令集只进或只出</span><br><span class="line">    synchronized (mIntents) &#123;</span><br><span class="line">        if (mCurrentIntent !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F; 从命令集中移除已完成（第一个）命令</span><br><span class="line">            if (!mIntents.remove(0).equals(mCurrentIntent)) &#123;</span><br><span class="line">                throw new IllegalStateException(&quot;something&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            mCurrentIntent &#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line">        SerialExecutor serialExecutor &#x3D; mTaskExecutor.getBackgroundExecutor();</span><br><span class="line">        &#x2F;&#x2F; 若无预计执行和待执行命令，则通知SystemAlarmService执行完毕</span><br><span class="line">        if (!mCommandHandler.hasPendingCommands()</span><br><span class="line">                &amp;&amp; mIntents.isEmpty()</span><br><span class="line">                &amp;&amp; !serialExecutor.hasPendingTasks()) &#123;</span><br><span class="line">            if (mCompletedListener !&#x3D; null) &#123;</span><br><span class="line">                mCompletedListener.onAllCommandsCompleted();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (!mIntents.isEmpty()) &#123;</span><br><span class="line">           &#x2F;&#x2F; 若命令集中还有未执行的命令，则继续执行</span><br><span class="line">            processCommand();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，若当前命令存在，则从命令集中移除当前命令。若无预计执行和待执行命令，则调用<code>mCompletedListener.onAllCommandsCompleted()</code>通知SystemAlarmService执行完毕；若命令集合中还有未执行命令，则调用<code>processCommand()</code>继续执行。</p>
<p>而<code>SystemAlarmService.onAllCommandsCompleted()</code>最终会执行<code>stopSelf()</code>停止服务</p>
<p>假装下面是时序图：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SystemAlarmService.java</span><br><span class="line">|- initializeDispatcher(); <span class="comment">// 初始化并绑定闹钟调度器</span></span><br><span class="line">|- SystemAlarmService.onStartCommand()  <span class="comment">// 通过startService添加命令</span></span><br><span class="line">    |- SystemAlarmDispatcher.add()				<span class="comment">// 委托调度器添加命令</span></span><br><span class="line">        |- mIntents.add(intent);    <span class="comment">// 添加命令进入命令集</span></span><br><span class="line">        |- SystemAlarmDispatcher.processCommand()			<span class="comment">// 若是第一个则,执行命令, 若不是第一个,将在后续流程中继续执行</span></span><br><span class="line">            |- <span class="keyword">try</span> CommandHandler.onHandleIntent()</span><br><span class="line">                |- ACTION_CONSTRAINTS_CHANGED</span><br><span class="line">                |- ...</span><br><span class="line">                |- ACTION_DELAY_MET</span><br><span class="line">                    |- delayMetCommandHandler.handleProcessWork()</span><br><span class="line">                        |- onAllConstraintsMet()</span><br><span class="line">                            |- mDispatcher.getProcessor().startWork()</span><br><span class="line">            |- <span class="function"><span class="keyword">finally</span> <span class="title">postOnMainThread</span><span class="params">( new DequeueAndCheckForCompletion(SystemAlarmDispatcher.<span class="keyword">this</span>)</span>)<span class="comment">// 分发完成命令事件</span></span></span><br><span class="line"><span class="function">				|- SystemAlarmDispatcher.<span class="title">dequeueAndCheckForCompletion</span><span class="params">()</span>  <span class="comment">// 回调</span></span></span><br><span class="line"><span class="function">					|- mIntents.<span class="title">remove</span><span class="params">(<span class="number">0</span>)</span></span>;					   <span class="comment">// 从命令集移出(当前)第一个命令</span></span><br><span class="line">					|- CommandsCompletedListener.onAllCommandsCompleted() </span><br><span class="line">					    OR SystemAlarmDispatcher.processCommand()  <span class="comment">// 命令集执行完毕 或 执行下一个命令</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>WorkManager</tag>
      </tags>
  </entry>
  <entry>
    <title>WorkManager基本使用及源码分析(二) - WorkManagerInitializer</title>
    <url>/2021/02/06/WorkManager%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%BA%8C)%20-%20WorkManagerInitializer/</url>
    <content><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="#part_source">源码篇</a><ul>
<li><a href="#AndroidManifest">2.1 AndroidManifest</a><ul>
<li><a href="#WorkManagerInitializer">2.1.1 WorkManagerInitializer</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="源码篇"><a href="#源码篇" class="headerlink" title=" 源码篇"></a><span id="part_source"> 源码篇</h3><p>上一篇中我们简单使用了WorkManager的一般功能，基础使用还是比较简单的。<strong>“WorkManager 是一个 API，可供您轻松调度那些即使在退出应用或重启设备后仍应运行的可延期异步任务”</strong>。那么我们来了解一下他到底是怎么工作的吧。</p>
<a id="more"></a>

<h4 id="2-1-AndroidManifest"><a href="#2-1-AndroidManifest" class="headerlink" title=" 2.1 AndroidManifest"></a><span id="AndroidManifest"> 2.1 AndroidManifest</h4><p>秉承看三方库源码的一般习惯，先从AndroidManifest.xml文件看起，我们知道一般的，想要了解一个库的主要组成就要想了解一个App一样首先要了解它有哪些组件构成，而<strong>库的AndroidManifest文件一般都会合并至应用AndroidManifest.xml中</strong>，且一般的需要初始化的库，常规的初始化方案是<strong>使用ContentProvider尽早地初始化且减少代码侵入</strong>，对这种方式不了解的，请参见<a href="https://blog.csdn.net/a1018875550/article/details/102760643">Android-使用ContentProvider来初始化你的sdk</a>系列文章。</p>
<p>废话不多说，让我们来看看work-runtime库的AndroidManifest.xml有哪些玄机。</p>
<p>work-runtime库的AndroidManifest.xml我们可以在AndroidStudio的 <strong>Project窗口中External Libraries</strong>栏目中查找”work-runtime”即可看到WorkManager的aar包结构和内容。打开AndroidManefest.xml我们发现以下重要组件：</p>
<ul>
<li><strong><provider></strong> <code>androidx.work.impl.WorkManagerInitializer</code></li>
<li><strong><service></strong> <code>androidx.work.impl.background.systemalarm.SystemAlarmService</code></li>
<li><strong><service></strong> <code>androidx.work.impl.background.systemjob.SystemJobService</code></li>
<li><strong><service></strong> <code>androidx.work.impl.foreground.SystemForegroundService</code></li>
<li><strong><receiver></strong> <code>androidx.work.impl.utils.ForceStopRunnable$BroadcastReceiver</code></li>
<li><strong><receiver></strong> <code>androidx.work.impl.background.systemalarm.ConstraintProxy$BatteryChargingProxy</code></li>
<li><strong><receiver></strong> <code>androidx.work.impl.background.systemalarm.ConstraintProxy$BatteryNotLowProxy</code></li>
<li><strong><receiver></strong> <code>androidx.work.impl.background.systemalarm.ConstraintProxy$StorageNotLowProxy</code></li>
<li><strong><receiver></strong> <code>androidx.work.impl.background.systemalarm.ConstraintProxy$NetworkStateProxy</code></li>
<li><strong><receiver></strong> <code>androidx.work.impl.background.systemalarm.RescheduleReceiver</code></li>
<li><strong><receiver></strong> <code>androidx.work.impl.background.systemalarm.ConstraintProxyUpdateReceiver</code></li>
<li><strong><receiver></strong> <code>androidx.work.impl.diagnostics.DiagnosticsReceiver</code></li>
</ul>
<p>我们可以大胆猜测： <em>WorkManager使用ContentProvider <code>WorkManagerInitializer</code>执行初始化操作, 通过Service管理任务执行及状态，通过BroadcastReceiver掌握任务执行时机和条件。</em></p>
<p><strong><span id="WorkManagerInitializer"> WorkManagerInitializer</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The &#123;<span class="doctag">@link</span> ContentProvider&#125; responsible for initializing &#123;<span class="doctag">@link</span> WorkManagerImpl&#125;.</span></span><br><span class="line"><span class="comment"> * // 机翻：负责初始化&#123;<span class="doctag">@link</span> WorkManagerImpl&#125;的&#123;<span class="doctag">@link</span> ContentProvider&#125;。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@hide</span>  // 隐藏API，对调用者不可见</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkManagerInitializer</span> <span class="keyword">extends</span> <span class="title">ContentProvider</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Initialize WorkManager with the default configuration.</span></span><br><span class="line">        <span class="comment">// 机翻：使用默认配置初始化WorkManager。</span></span><br><span class="line">        WorkManager.initialize(getContext(), <span class="keyword">new</span> Configuration.Builder().build());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... 省略其他无关代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>WorkManager.initialize -&gt; WorkManagerImpl.initialize</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &#123;@link WorkManagerImpl#initialize&#125;</span></span><br><span class="line"><span class="meta">@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(<span class="meta">@NonNull</span> Context context, <span class="meta">@NonNull</span> Configuration configuration)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (sLock) &#123;</span><br><span class="line">     <span class="comment">// ... 重复创建检查，若被多次调用此创建方法则抛错WorkManager is already initialized.</span></span><br><span class="line">        <span class="keyword">if</span> (sDelegatedInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            context = context.getApplicationContext();</span><br><span class="line">            <span class="keyword">if</span> (sDefaultInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                sDefaultInstance = <span class="keyword">new</span> WorkManagerImpl(</span><br><span class="line">                        context, configuration,</span><br><span class="line">                        <span class="keyword">new</span> WorkManagerTaskExecutor(configuration.getTaskExecutor()));</span><br><span class="line">            &#125;</span><br><span class="line">            sDelegatedInstance = sDefaultInstance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中<code>configuration.getTaskExecutor()</code>最终调用方法为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="meta">@NonNull</span> <span class="function">Executor <span class="title">createDefaultExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Executors.newFixedThreadPool(</span><br><span class="line">            <span class="comment">// This value is the same as the core pool size for AsyncTask#THREAD_POOL_EXECUTOR.</span></span><br><span class="line">            <span class="comment">// 机翻：这个值与AsyncTask#THREAD_POOL_EXECUTOR的核心池大小相同。</span></span><br><span class="line">            Math.max(<span class="number">2</span>, Math.min(Runtime.getRuntime().availableProcessors() - <span class="number">1</span>, <span class="number">4</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>备注：一般地，AsyncTask里线程池核心线程数为CPU + 1，最大线程数为CPU * 2 + 1</p>
<p>纵观代码，我们发现WorkManagerInitializer就是一个负责初始化WorkManager的ContentProvider，职责单一，简单明了。<br><code>WorkManager.initialize()</code>最终使用ContentProvider上下文对象context、默认configuration及线程池容量与AsyncTask核心线程数一致的Executor创建了WorkManagerImpl单例实例。</p>
]]></content>
      <categories>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>WorkManager</tag>
      </tags>
  </entry>
  <entry>
    <title>WorkManager基本使用及源码分析(五) - Processor</title>
    <url>/2021/02/06/WorkManager%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%BA%94)%20-%20Processor/</url>
    <content><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="#part_source">源码篇</a><ul>
<li><a href="#Processor">Processor</a></li>
</ul>
</li>
</ul>
<hr>
<h3 id="源码篇"><a href="#源码篇" class="headerlink" title=" 源码篇"></a><span id="part_source"> 源码篇</h3><p>前面从work-runtime库的AndroidManifest.xml中了解到，WorkManager工作主要通过ContentProvider、Service、BroadcastReceiver协同工作，而关注几个主要Service工作流程发现，最终都会执行到<code>Processor.startWork()</code>方法，此篇将重点关注<code>Processor.startWork()</code>是何方神圣。</p>
<a id="more"></a>
<p>首先我们简单过一下<code> mWorkManagerImpl.getProcessor().startWork(mWorkSpecId, mRuntimeExtras)</code>的代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean startWork(@NonNull String id,  @Nullable WorkerParameters.RuntimeExtras runtimeExtras) &#123;</span><br><span class="line">    WorkerWrapper workWrapper;</span><br><span class="line">    &#x2F;&#x2F; 保证任务队列(MAP)只进或只出</span><br><span class="line">    synchronized (mLock) &#123;</span><br><span class="line">        &#x2F;&#x2F; doing 验证id不在队列中</span><br><span class="line">        &#x2F;&#x2F; 初始化WorkerWrapper</span><br><span class="line">        workWrapper &#x3D; new WorkerWrapper.Builder(...).build();</span><br><span class="line">        ListenableFuture&lt;Boolean&gt; future &#x3D; workWrapper.getFuture();</span><br><span class="line">        &#x2F;&#x2F; 为执行结果添加监听，注意这里监听回调何时调用后面会说明</span><br><span class="line">        &#x2F;&#x2F; 特别注意：future.addListener中 FutureListener 是一个Runnable对象</span><br><span class="line">        &#x2F;&#x2F; 特别注意： FutureListener 是一个Runnable对象</span><br><span class="line">        future.addListener(</span><br><span class="line">                new FutureListener(this, id, future),</span><br><span class="line">                mWorkTaskExecutor.getMainThreadExecutor());</span><br><span class="line">        &#x2F;&#x2F; 将此任务加入队列</span><br><span class="line">        mEnqueuedWorkMap.put(id, workWrapper);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 使用工作线程执行任务</span><br><span class="line">    mWorkTaskExecutor.getBackgroundExecutor().execute(workWrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code> mWorkManagerImpl.getProcessor().startWork(mWorkSpecId, mRuntimeExtras)</code>主要做了三个操作：</p>
<ul>
<li>将任务要素封装为WorkerWrapper并为其执行期望添加监听</li>
<li>任务要素入队</li>
<li>工作线程执行处理任务</li>
</ul>
<p>相对主要的，我们继续跟进工作线程处理任务流程<code>execute(Runnable)</code>, excute将WorkerWrapper继续封装为Task并加入任务队列，若当前无活跃Task则安排任务执行，任务执行完毕后继续检查任务队列，直到任务队列空置为止：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="meta">@NonNull</span> Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 保证任务队列只进或只出</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="comment">// 封装任务并入队</span></span><br><span class="line">        mTasks.add(<span class="keyword">new</span> Task(<span class="keyword">this</span>, command));</span><br><span class="line">        <span class="comment">// 若无活跃任务，则尝试安排任务</span></span><br><span class="line">        <span class="keyword">if</span> (mActive == <span class="keyword">null</span>) &#123;</span><br><span class="line">            scheduleNext();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Synthetic access</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 保证任务队列只进或只出</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="comment">// 有任务且任务出队</span></span><br><span class="line">        <span class="keyword">if</span> ((mActive = mTasks.poll()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 执行任务</span></span><br><span class="line">            mExecutor.execute(mActive);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>mExecutor.execute(mActive)</code>会通过Task执行<code>execute(Runnable)</code>传入的Runnable，即执行<code>WorkerWrapper</code>（这里有点绕，可以多看两遍~），Task不论WorkerWrapper执行结果最终会继续轮询任务队列（此处不赘述）。此时，我们将目光移到<code>WorkerWrapper.run()</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@WorkerThread</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">    mTags &#x3D; mWorkTagDao.getTagsForWorkSpecId(mWorkSpecId);</span><br><span class="line">    mWorkDescription &#x3D; createWorkDescription(mTags);</span><br><span class="line">    runWorker();</span><br><span class="line">&#125;</span><br><span class="line">private void runWorker() &#123;</span><br><span class="line">&#x2F;&#x2F; 各个状态判断最终调用到resolve(false);</span><br><span class="line">resolve(true); &#x2F;&#x2F; OR resolve(false);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 尝试将工作设置为运行状态。注意，这可能会失败，因为自从上次在这个函数的顶部检查之后，另一个线程可能已经修改了数据库。</span><br><span class="line">if (trySetRunning()) &#123;</span><br><span class="line">    if (tryCheckForInterruptionAndResolve()) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final SettableFuture&lt;ListenableWorker.Result&gt; future &#x3D; SettableFuture.create();</span><br><span class="line">    &#x2F;&#x2F; Call mWorker.startWork() on the main thread.</span><br><span class="line">    mWorkTaskExecutor.getMainThreadExecutor()</span><br><span class="line">            .execute(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        &#x2F;&#x2F; 调用Worker执行工作任务</span><br><span class="line">                        mInnerFuture &#x3D; mWorker.startWork();</span><br><span class="line">                        &#x2F;&#x2F; 将任务结果回调添加到期望回调中</span><br><span class="line">                        future.setFuture(mInnerFuture);</span><br><span class="line">                    &#125; catch (Throwable e) &#123;</span><br><span class="line">                        future.setException(e);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Avoid synthetic accessors.</span><br><span class="line">    final String workDescription &#x3D; mWorkDescription;</span><br><span class="line">    future.addListener(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        @SuppressLint(&quot;SyntheticAccessor&quot;)</span><br><span class="line">        public void run() &#123;</span><br><span class="line">           &#x2F;&#x2F; 最终调用到resolve(false);</span><br><span class="line">           resolve(false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, mWorkTaskExecutor.getBackgroundExecutor());</span><br><span class="line">&#125; else &#123;</span><br><span class="line">     &#x2F;&#x2F; 最终调用到resolve(false);</span><br><span class="line">     resolve(boolean);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void resolve(final boolean needsReschedule) &#123;</span><br><span class="line">    &#x2F;&#x2F; 数据库事务操作</span><br><span class="line">    </span><br><span class="line">    mFuture.set(needsReschedule);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>runWorker()</code> 中包含各种任务状态的判断，并尝试将任务置为运行状态，若设置运行状态成功，则调用<code>Worker.startWork()</code> 即最终会走向个人定义的Worker的<code>doWork()</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public final @NonNull ListenableFuture&lt;Result&gt; startWork() &#123;</span><br><span class="line">        mFuture &#x3D; SettableFuture.create();</span><br><span class="line">        getBackgroundExecutor().execute(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Result result &#x3D; doWork();</span><br><span class="line">                    mFuture.set(result);</span><br><span class="line">                &#125; catch (Throwable throwable) &#123;</span><br><span class="line">                    mFuture.setException(throwable);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        return mFuture;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>后续跟进<code>resolve</code>, 此方法除了数据库相关操作（更新Worker状态）外，最终会执行<code>mFuture.set(needsReschedule)</code>，即目标期望回调。</p>
<p>在跟进绕来绕去的<code>mFuture.set(needsReschedule)</code>之前，先回想一下，还记得<code>WorkManagerImpl.startWork</code>代码片段里的初始化代码段，future.addListener中 FutureListener 是一个Runnable对象，而addListener入参最终会被封装到<code>AbstractFuture.Listener</code>中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此处Runnable task实际为FutureListener</span></span><br><span class="line">Listener(Runnable task, Executor executor) &#123;</span><br><span class="line">    <span class="keyword">this</span>.task = task;</span><br><span class="line">    <span class="keyword">this</span>.executor = executor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>切回正题，继续跟进<code>mFuture.set(needsReschedule)</code>，此处set(boolean)最终会调用<code>AbstractFuture.set()</code>,继而调用<code>AbstractFuture.complete</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">set</span><span class="params">(<span class="meta">@Nullable</span> V value)</span> </span>&#123;</span><br><span class="line">    Object valueToSet = value == <span class="keyword">null</span> ? NULL : value;</span><br><span class="line">    <span class="keyword">if</span> (ATOMIC_HELPER.casValue(<span class="keyword">this</span>, <span class="keyword">null</span>, valueToSet)) &#123;</span><br><span class="line">        complete(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>AbstractFuture.complete</code>会遍历期望回调结合，找出其中代表执行结果回调的项并执行Runnable回调封装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void complete(AbstractFuture&lt;?&gt; future) &#123;</span><br><span class="line">	Listener next &#x3D; null;</span><br><span class="line">	outer:</span><br><span class="line">	while (true) &#123;</span><br><span class="line">		future.releaseWaiters();</span><br><span class="line">		future.afterDone();</span><br><span class="line">		next &#x3D; future.clearListeners(next);</span><br><span class="line">		future &#x3D; null;</span><br><span class="line">		while (next !&#x3D; null) &#123;</span><br><span class="line">			Listener curr &#x3D; next;</span><br><span class="line">			next &#x3D; next.next;</span><br><span class="line">			Runnable task &#x3D; curr.task;</span><br><span class="line">			if (task instanceof SetFuture) &#123;</span><br><span class="line">			    &#x2F;&#x2F; do something</span><br><span class="line">			    continue outer;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">			    &#x2F;&#x2F; 执行Runnable回调封装</span><br><span class="line">				executeListener(task, curr.executor);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		break;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里<code>executeListener(task, curr.executor)</code>中的task参数即在Processor中封装<code>WorkWrapper</code>时的<code>FutureListener</code>参数，即此处最终会执行<code>FutureListener.run()</code>方法，从而调用<code>mExecutionListener.onExecuted(mWorkSpecId, needsReschedule)</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureListener</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// something</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> needsReschedule;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            needsReschedule = mFuture.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">            <span class="comment">// Should never really happen(?)</span></span><br><span class="line">            needsReschedule = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mExecutionListener.onExecuted(mWorkSpecId, needsReschedule);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们回想一下<code>Processor.startWork()</code>中关于设置futureListener的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">future.addListener(</span><br><span class="line">        <span class="keyword">new</span> FutureListener(<span class="keyword">this</span>, id, future),</span><br><span class="line">        mWorkTaskExecutor.getMainThreadExecutor());</span><br></pre></td></tr></table></figure>
<p>此处FutureListener中的第一个参数ExecutionListener是“this”，即会调用<code>ExecutionListener.onExecuted()</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onExecuted</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@NonNull</span> <span class="keyword">final</span> String workSpecId,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> needsReschedule)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        mEnqueuedWorkMap.remove(workSpecId);</span><br><span class="line">        <span class="comment">// mOuterListeners来自哪里，还记得本节SystemJobService最开始需要记住的addExecutionListener吗，没错，就是这里。</span></span><br><span class="line">        <span class="keyword">for</span> (ExecutionListener executionListener : mOuterListeners) &#123;</span><br><span class="line">            executionListener.onExecuted(workSpecId, needsReschedule);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们来看看<code>mOuterListeners</code>赋值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addExecutionListener</span><span class="params">(<span class="meta">@NonNull</span> ExecutionListener executionListener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        mOuterListeners.add(executionListener);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>嗨，跑了一圈，我们又回来了，即上面<code>onExecuted</code>中遍历执行的<code>executionListener.onExecuted(workSpecId, needsReschedule)</code>，<br>以SystemJobService为例，会调用<code>SystemJobService.onExecuted()</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onExecuted</span><span class="params">(<span class="meta">@NonNull</span> String workSpecId, <span class="keyword">boolean</span> needsReschedule)</span> </span>&#123;</span><br><span class="line">    Logger.get().debug(TAG, String.format(<span class="string">&quot;%s executed on JobScheduler&quot;</span>, workSpecId));</span><br><span class="line">    JobParameters parameters;</span><br><span class="line">    <span class="keyword">synchronized</span> (mJobParameters) &#123;</span><br><span class="line">        parameters = mJobParameters.remove(workSpecId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (parameters != <span class="keyword">null</span>) &#123;</span><br><span class="line">        jobFinished(parameters, needsReschedule);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，从XXXService调用SystemXXXService执行任务到最终任务结束及回调流程形成了一个完整的链。</p>
]]></content>
      <categories>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>WorkManager</tag>
      </tags>
  </entry>
  <entry>
    <title>WorkManager基本使用及源码分析(六) - SystemForegroundService</title>
    <url>/2021/02/06/WorkManager%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E5%85%AD)%20-%20SystemForegroundService/</url>
    <content><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="#part_source">源码篇</a><ul>
<li><a href="#SystemForegroundService">SystemForegroundService</a></li>
</ul>
</li>
</ul>
<hr>
<h3 id="源码篇"><a href="#源码篇" class="headerlink" title=" 源码篇"></a><span id="part_source"> 源码篇</h3><p>上一篇中我们了解了WorkManager使用的的主要组件，猜测了各个组件的作用，并简单介绍了WorkManager是如何初始化的。本篇将延续前文，介绍WorkManager中Service组件之一的SystemForegroundService。</p>
<p><strong><span id="SystemForegroundService"> SystemForegroundService</strong></p>
<p>在看过前面<code>SystemAlarmService & SystenJobService</code> 后，我本以为<br><code>SystemForegroundService</code>也如前者一般是处理任务执行的，但简单阅读代码后发现并非如此，尽管结构上与前者类似，但其主要作用是<strong>给运行任务的服务提权，保证其在前台执行</strong>。</p>
<a id="more"></a>

<p> <code>SystemAlarmService & SystenJobService</code>相似，<code>SystemForegroundService</code>也是<code>LifecycleService</code>的子类，主要方法有：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate();</span><br><span class="line">    sForegroundService = <span class="keyword">this</span>;</span><br><span class="line">    initializeDispatcher();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(<span class="meta">@Nullable</span> Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onStartCommand(intent, flags, startId);</span><br><span class="line">    <span class="comment">// 若正在被关闭，则</span></span><br><span class="line">    <span class="keyword">if</span> (mIsShutdown) &#123;</span><br><span class="line">        <span class="comment">// 结束旧    Dispatcher 的生命周期</span></span><br><span class="line">        mDispatcher.onDestroy();</span><br><span class="line">        <span class="comment">// 创建新的Dispatcher并设置新的生命周期</span></span><br><span class="line">        initializeDispatcher();</span><br><span class="line">        mIsShutdown = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (intent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 告诉Dispatcher 有活儿来了</span></span><br><span class="line">        mDispatcher.onStartCommand(intent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果服务崩溃，我们希望所有未确认的意图都得到重新交付。</span></span><br><span class="line">    <span class="keyword">return</span> Service.START_REDELIVER_INTENT;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initializeDispatcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mHandler = <span class="keyword">new</span> Handler(Looper.getMainLooper());</span><br><span class="line">    mNotificationManager = (NotificationManager)</span><br><span class="line">            getApplicationContext().getSystemService(Context.NOTIFICATION_SERVICE);</span><br><span class="line">    mDispatcher = <span class="keyword">new</span> SystemForegroundDispatcher(getApplicationContext());</span><br><span class="line">    mDispatcher.setCallback(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始化时创建新的SystemForegroundDispatcher绑定并设置新的生命周期，当收到指令被启动时，调用<code>SystemForegroundDispatcher.onStartCommand()</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SystemForegroundDispatcher#onStartCommand</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onStartCommand</span><span class="params">(<span class="meta">@NonNull</span> Intent intent)</span> </span>&#123;</span><br><span class="line">    String action = intent.getAction();</span><br><span class="line">    <span class="keyword">if</span> (ACTION_START_FOREGROUND.equals(action)) &#123;</span><br><span class="line">        handleStartForeground(intent);</span><br><span class="line">        <span class="comment">// 调用handleNotify()，它反过来调用start前台()作为处理这个命令的一部分。这对一些原始设备制造商来说很重要。</span></span><br><span class="line">        handleNotify(intent);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ACTION_NOTIFY.equals(action)) &#123;</span><br><span class="line">        handleNotify(intent);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ACTION_CANCEL_WORK.equals(action)) &#123;</span><br><span class="line">        handleCancelWork(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当intent (<em>此处intent可视作前面提到的SystemXXXService的意图</em>) 状态处于启动、更新状态时会调用<code>handleNotify(intent)</code>，取消时会调用<code>handleCancelWork(intent)</code>,<br>状态为取消时，则最终会调用<code>mWorkManagerImpl.cancelWorkById(UUID.fromString(workSpecId))</code>取消任务执行。</p>
<p>我们再来看看handleNotify干了哪些事情吧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SystemForegroundDispatcher#handleNotify</span></span><br><span class="line"><span class="meta">@MainThread</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleNotify</span><span class="params">(<span class="meta">@NonNull</span> Intent intent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> notificationId = intent.getIntExtra(KEY_NOTIFICATION_ID, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> notificationType = intent.getIntExtra(KEY_FOREGROUND_SERVICE_TYPE, <span class="number">0</span>);</span><br><span class="line">    String workSpecId = intent.getStringExtra(KEY_WORKSPEC_ID);</span><br><span class="line">    Notification notification = intent.getParcelableExtra(KEY_NOTIFICATION);</span><br><span class="line">    <span class="keyword">if</span> (notification != <span class="keyword">null</span> &amp;&amp; mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ForegroundInfo info = <span class="keyword">new</span> ForegroundInfo(</span><br><span class="line">                notificationId, notification, notificationType);</span><br><span class="line">        <span class="comment">// 缓存信息</span></span><br><span class="line">        mForegroundInfoById.put(workSpecId, info);</span><br><span class="line">        <span class="keyword">if</span> (TextUtils.isEmpty(mCurrentForegroundWorkSpecId)) &#123;</span><br><span class="line">            <span class="comment">// 这是拥有前台生命周期的当前workSpecId.</span></span><br><span class="line">            mCurrentForegroundWorkSpecId = workSpecId;</span><br><span class="line">            mCallback.startForeground(notificationId, notificationType, notification);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 更新通知</span></span><br><span class="line">            mCallback.notify(notificationId, notification);</span><br><span class="line">            <span class="comment">// 如有必要，更新前台的通知，使其成为当前所有前台服务类型的联合。</span></span><br><span class="line">            <span class="keyword">if</span> (notificationType != FOREGROUND_SERVICE_TYPE_NONE</span><br><span class="line">                    &amp;&amp; Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q) &#123;</span><br><span class="line">                <span class="keyword">int</span> foregroundServiceType = FOREGROUND_SERVICE_TYPE_NONE;</span><br><span class="line">                <span class="keyword">for</span> (Map.Entry&lt;String, ForegroundInfo&gt; entry : mForegroundInfoById.entrySet()) &#123;</span><br><span class="line">                    ForegroundInfo foregroundInfo = entry.getValue();</span><br><span class="line">                    foregroundServiceType |= foregroundInfo.getForegroundServiceType();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//缓存中取出信息</span></span><br><span class="line">                ForegroundInfo currentInfo = mForegroundInfoById.get(mCurrentForegroundWorkSpecId);</span><br><span class="line">                <span class="keyword">if</span> (currentInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mCallback.startForeground(</span><br><span class="line">                            currentInfo.getNotificationId(),</span><br><span class="line">                            foregroundServiceType,</span><br><span class="line">                            currentInfo.getNotification()</span><br><span class="line">                    );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若当前服务intent是首个，那么就启动<code>SystemForegroundService.startForeground()</code>做周期性递归，而<code>SystemForegroundService.startForeground()</code>实际上是一个空方法，类似于使用了<code>Looper</code>保证<code>SystemForegroundService</code>一直运行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; SystemForegroundService#startForeground</span><br><span class="line">@Override</span><br><span class="line">public void startForeground(</span><br><span class="line">        final int notificationId,</span><br><span class="line">        final int notificationType,</span><br><span class="line">        @NonNull final Notification notification) &#123;</span><br><span class="line"></span><br><span class="line">    mHandler.post(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            if (Build.VERSION.SDK_INT &gt;&#x3D; Build.VERSION_CODES.Q) &#123;</span><br><span class="line">                startForeground(notificationId, notification, notificationType);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                startForeground(notificationId, notification);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若当前服务intent不是首个，则更新一则通知，并合并前台服务类型，<code>mCallback.notify(notificationId, notification)</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SystemForegroundService#notify</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> notificationId, <span class="meta">@NonNull</span> <span class="keyword">final</span> Notification notification)</span> </span>&#123;</span><br><span class="line">    mHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            mNotificationManager.notify(notificationId, notification);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><code>SystemForegroundService</code>会在任务启动时启动，且会创建一个类似于<code>Looper</code>的结构保持服务前台持续运行，后续有任务触发时，会发送notification以保证其执行任务的服务可被视作前台服务保持运行。</p>
]]></content>
      <categories>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>WorkManager</tag>
      </tags>
  </entry>
  <entry>
    <title>WorkManager基本使用及源码分析(四) - SystemJobService</title>
    <url>/2021/02/06/WorkManager%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E5%9B%9B)%20-%20SystemJobService/</url>
    <content><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="#part_source">源码篇</a><ul>
<li><a href="#SystemJobService">SystemJobService</a></li>
</ul>
</li>
</ul>
<hr>
<h3 id="源码篇"><a href="#源码篇" class="headerlink" title=" 源码篇"></a><span id="part_source"> 源码篇</h3><p>上一篇中我们简单使用了WorkManager的一般功能，基础使用还是比较简单的。<strong>“WorkManager 是一个 API，可供您轻松调度那些即使在退出应用或重启设备后仍应运行的可延期异步任务”</strong>。那么我们来了解一下他到底是怎么工作的吧。</p>
<p><strong><span id="SystemJobService"> SystemJobService</strong></p>
<blockquote>
<p>Service invoked by {@link android.app.job.JobScheduler} to run work tasks.</p>
</blockquote>
<p>服务将被JobScheduler调用来执行工作任务。<br>从描述可得<code>SystemJobService</code>与<code>SystemAlarmService</code>职责是一致的，都是“run work tasks”。</p>
<a id="more"></a>

<p>类似地，我们可以猜测<code>SystemJobService</code>执行流程始于<code>onStartJob</code>终于<code>onStopJob</code>。</p>
<p><code>SystemJobService.onCreate()</code>获取了<code>WorkManagerImpl</code>实例并将执行监听绑定到（任务）处理器Processor：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 还记得WorkManagerImpl是哪里初始化的吗？</span><br><span class="line">mWorkManagerImpl &#x3D; WorkManagerImpl.getInstance(getApplicationContext());</span><br><span class="line">&#x2F;&#x2F; 记住此处addExecutionListener</span><br><span class="line">&#x2F;&#x2F; 记住此处addExecutionListener</span><br><span class="line">&#x2F;&#x2F; 记住此处addExecutionListener</span><br><span class="line">mWorkManagerImpl.getProcessor().addExecutionListener(this);</span><br></pre></td></tr></table></figure>
<p>当SystemJobService被调用时会执行<code>SystemJobService.onStartJob()</code>，此时会将JobParameters以workId为Key存入工作Map中，并初始化<code>WorkerParameters.RuntimeExtras</code>, 最终调用<code>mWorkManagerImpl.startWork(workSpecId, runtimeExtras)</code>执行任务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onStartJob</span><span class="params">(<span class="meta">@NonNull</span> JobParameters params)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// WorkManagerImpl NonNull</span></span><br><span class="line">    String workSpecId = getWorkSpecIdFromJobParameters(params);</span><br><span class="line">    <span class="comment">// workSpecId NonNull</span></span><br><span class="line">    <span class="comment">// 保证mJobParameters 工作参数集只进或只出</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mJobParameters) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mJobParameters.containsKey(workSpecId)) &#123;</span><br><span class="line">           <span class="comment">// log</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 存入工作参数</span></span><br><span class="line">        mJobParameters.put(workSpecId, params);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化WorkerParameters.RuntimeExtras</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// WorkManagerImpl执行任务</span></span><br><span class="line">    mWorkManagerImpl.startWork(workSpecId, runtimeExtras);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>WorkManagerImpl.startWork</code>后续会执行<code> mWorkManagerImpl.getProcessor().startWork(mWorkSpecId, mRuntimeExtras)</code>。</p>
<p>由于内容流程较长且属于公共流程，关于<code>Processor.startWork()</code>将单独整理未一小节，<a href="./WorkManager%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%BA%94)+-+Processor.md">点击此处查看</a>。</p>
<p>由<code>Processor.startWork()</code>中代码可知，流程末尾<code>onExecuted</code>中遍历执行的<code>executionListener.onExecuted(workSpecId, needsReschedule)</code>会调用<code>SystemJobService.onExecuted()</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onExecuted</span><span class="params">(<span class="meta">@NonNull</span> String workSpecId, <span class="keyword">boolean</span> needsReschedule)</span> </span>&#123;</span><br><span class="line">    Logger.get().debug(TAG, String.format(<span class="string">&quot;%s executed on JobScheduler&quot;</span>, workSpecId));</span><br><span class="line">    JobParameters parameters;</span><br><span class="line">    <span class="keyword">synchronized</span> (mJobParameters) &#123;</span><br><span class="line">        parameters = mJobParameters.remove(workSpecId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (parameters != <span class="keyword">null</span>) &#123;</span><br><span class="line">        jobFinished(parameters, needsReschedule);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，根据JobService的生命周期，我们可以认定，最后会调用<code>SystemJobService.onStopJob()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onStopJob</span><span class="params">(<span class="meta">@NonNull</span> JobParameters params)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mWorkManagerImpl == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String workSpecId = getWorkSpecIdFromJobParameters(params);</span><br><span class="line">    <span class="keyword">if</span> (TextUtils.isEmpty(workSpecId)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// mJobParameters数据安全</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mJobParameters) &#123;</span><br><span class="line">        <span class="comment">// 移出任务参数队列（Map）</span></span><br><span class="line">        mJobParameters.remove(workSpecId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 结束此任务</span></span><br><span class="line">    mWorkManagerImpl.stopWork(workSpecId);</span><br><span class="line">    <span class="keyword">return</span> !mWorkManagerImpl.getProcessor().isCancelled(workSpecId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，从JobService调用SystemJobService执行任务到最终任务结束流程形成了一个完整的链。</p>
]]></content>
      <categories>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>WorkManager</tag>
      </tags>
  </entry>
  <entry>
    <title>WorkManager基本使用及源码分析(一) - 使用篇</title>
    <url>/2021/02/06/WorkManager%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%B8%80)%20-%20%E4%BD%BF%E7%94%A8%E7%AF%87/</url>
    <content><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="#zero">ZERO</a></li>
<li><a href="#part_use">1. 使用篇</a><ul>
<li><a href="#dependencies">1.1 声明依赖项</a></li>
<li><a href="#how_to_use">1.2 该如何使用？</a></li>
<li><a href="#task_type">1.3 WorkRequest类型</a></li>
<li><a href="#general_operation">1.4 一般操作</a><ul>
<li><a href="#task_listener">1.4.1 任务监听</a></li>
<li><a href="#transfer_data">1.4.2 传递数据</a></li>
<li><a href="#multiple_ask">1.4.3 多任务串联</a></li>
<li><a href="#UniqueWork">1.4.4 唯一任务</a></li>
<li><a href="#task_onstraint">1.4.5 任务约束</a></li>
<li><a href="#task_delay">1.4.6 任务延时</a></li>
<li><a href="#retry_rollback">1.4.7 重试和退避政策</a></li>
<li><a href="#work_tag">1.4.8 标记工作</a></li>
<li><a href="#work_cancel">1.4.9 取消工作</a></li>
</ul>
</li>
<li><a href="#attention">1.5 注意事项</a></li>
</ul>
</li>
</ul>
<hr>
<h3 id="ZERO"><a href="#ZERO" class="headerlink" title="ZERO"></a><a href="#zero">ZERO</a></h3><p><strong>Q:</strong> 什么是WorkManager？为什么要使用它？</p>
<blockquote>
<p>WorkManager 是一个 API，可供您轻松调度那些即使在退出应用或重启设备后仍应运行的可延期异步任务。WorkManager API 是一个适合用来替换先前的 Android 后台调度 API（包括 FirebaseJobDispatcher、GcmNetworkManager 和 JobScheduler）的组件，我们也建议您这样做。WorkManager 在其现代、一致的 API 中整合了其前身的功能，该 API 支持 API 级别 14，在开发时即考虑到了对电池续航的影响。</p>
</blockquote>
<p><strong>Q:</strong> 一定要使用WorkManager吗？</p>
<blockquote>
<p>如果您的应用以 Android 10（API 级别 29）或更高版本为目标平台，那么您对 FirebaseJobDispatcher 和 GcmNetworkManager API 的调用在搭载 Android Marshmallow (6.0) 及更高版本的设备上将无法正常工作。</p>
</blockquote>
<p>由上一问题可知，WorkManager是对 FirebaseJobDispatcher 和 GcmNetworkManager API 的替换，在一定情境下，显然更推荐您使用WorkManager。</p>
<hr>
<p>本章主要内容为WorkManager基本使用及源码分析，涉及WorkManager入门使用、源码分析两个部分，可根据个人需要选择部分内容阅读。</p>
<p>本章所述WorkManager相关内容均基于<code>WorkManager:2.4.0</code>;</p>
<p>本章涉及代码内容均使用<strong>Java</strong>语言编写，Java版本1.8；</p>
<p><a href="https://github.com/TinloneX">本章演示项目地址：https://github.com/TinloneX</a></p>
<p><a href="https://developer.android.google.cn/topic/libraries/architecture/workmanager">参考官方文档请点击这里</a></p>
<a id="more"></a>

<h3 id="1-使用篇"><a href="#1-使用篇" class="headerlink" title=" 1. 使用篇"></a><span id="part_use"> 1. 使用篇</h3><blockquote>
<p>WorkManager is a library used to enqueue deferrable work that is guaranteed to execute sometime after its Constraints are met. WorkManager allows observation of work status and the ability to create complex chains of work. </p>
</blockquote>
<p>WorkManager是一个用于将可延迟的工作放入队列的库，这些工作保证在满足其约束后的某个时间内执行。WorkManager允许观察工作状态，并能够创建复杂的工作链。</p>
<p><strong>注意：WorkManager 需要 compileSdk 版本 28 或更高版本。</strong></p>
<h4 id="1-1-声明依赖项"><a href="#1-1-声明依赖项" class="headerlink" title=" 1.1 声明依赖项"></a><span id="dependencies"> 1.1 声明依赖项</h4><p>如需添加 WorkManager 的依赖项，您必须将 Google Maven 代码库添加到项目中：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 项目根目录下build.gradle</span></span><br><span class="line"><span class="keyword">allprojects</span> &#123;</span><br><span class="line">    <span class="keyword">repositories</span> &#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在应用或模块的 build.gradle 文件中添加所需工件的依赖项：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app/build.gradle</span></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">  <span class="keyword">def</span> work_version = <span class="string">&quot;2.4.0&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// (Java only) 单纯使用java可引用此依赖</span></span><br><span class="line">    implementation <span class="string">&quot;androidx.work:work-runtime:$work_version&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Kotlin + coroutines 使用kotlin+协程可引用此依赖</span></span><br><span class="line">    implementation <span class="string">&quot;androidx.work:work-runtime-ktx:$work_version&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional - RxJava2 support 意图支持RxJava2的WorkManager可引用此依赖</span></span><br><span class="line">    implementation <span class="string">&quot;androidx.work:work-rxjava2:$work_version&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional - GCMNetworkManager support   @①</span></span><br><span class="line">    implementation <span class="string">&quot;androidx.work:work-gcm:$work_version&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// optional - Test helpers  测试工件</span></span><br><span class="line">    androidTestImplementation <span class="string">&quot;androidx.work:work-testing:$work_version&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>以上依赖均只需引用一个即可，此文档及代码均使用<code>androidx.work:work-runtime:2.4.0</code>。</li>
<li>特别的，① <blockquote>
<p>androidx.work:work-gcm:2.2.0 是一个新的 Maven 工件，当 Google Play 服务可用于 API 级别 22 或更低级别时，该工件支持将 GCMNetworkManager 用作调度程序。这是一个可选的依赖项，有助于在较旧的 API 版本上进行更稳定且性能更高的后台处理工作。如果您的应用使用 Google Play 服务，请将此依赖项添加到 gradle 文件，以自动获得 GCMNetworkManager 支持。如果 Play 服务不可用，WorkManager 将继续在旧款设备上回退到 AlarmManager。</p>
</blockquote>
</li>
</ul>
<p>下面我们将正式进入WorkManager使用篇</p>
<h4 id="1-2-该如何使用"><a href="#1-2-该如何使用" class="headerlink" title=" 1.2 该如何使用"></a><span id="how_to_use"> 1.2 该如何使用</h4><p>在讲解任务类型及其一般使用前，我们先了解WorkManager工作的流程：</p>
<ul>
<li><strong>谁来做</strong> 定义一个负责工作的<strong>Worker</strong><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SimpleWorker extends Worker &#123;</span><br><span class="line">@NonNull</span><br><span class="line">    @Override</span><br><span class="line">    public Result doWork() &#123;</span><br><span class="line">        &#x2F;&#x2F; return Result.failure(); &#x2F;&#x2F; 执行失败</span><br><span class="line">        &#x2F;&#x2F; return Result.retry();   &#x2F;&#x2F; 重试 </span><br><span class="line">        &#x2F;&#x2F; return Result.success(); &#x2F;&#x2F; 执行成功</span><br><span class="line">        return null;                &#x2F;&#x2F; 执行结束？</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
Worker是WorkManager最终实现任务的“工人”，它不用管会在什么实际执行任务，被安排怎样执行任务，只管埋头处理任务<code>doWork</code>并根据任务执行情况反馈任务结果<code>return Result</code>。</li>
</ul>
<p>Worker执行结果Result：表示任务状态，他一般有<code>failure</code>、<code>retry</code>、<code>success</code>三个状态，且<code>failure</code>、<code>success</code>可以携带数据<code>Data</code>，此处仅做了解，<a href="#periodic_task">传递数据</a>中将做具体说明。</p>
<ul>
<li><strong>怎么做</strong> 定义制定工作方案的<strong>WorkRequest</strong></li>
</ul>
<ol>
<li><strong>非重复性工作：</strong> 工人应该一次性把工作做掉<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OneTimeWorkRequest workRequest1 = OneTimeWorkRequest.from(SimpleWorker.class);</span><br></pre></td></tr></table></figure></li>
<li><strong>周期任务：</strong> 工人应该每隔多久做一次工作</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PeriodicWorkRequest request &#x3D; new PeriodicWorkRequest</span><br><span class="line">               .Builder(SimpleWorker.class, 16, TimeUnit.MINUTES).build();</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> 关于周期任务有一个<strong>霸王条款：</strong></p>
<blockquote>
<p>注意：可以定义的最短重复间隔是 15 分钟（与 JobScheduler API 相同）。</p>
</blockquote>
<blockquote>
<p>如果您的工作的性质致使其对运行时间敏感，您可以将 PeriodicWorkRequest 配置为在每个时间间隔的灵活时间段内运行。</p>
</blockquote>
<p><a href="https://developer.android.google.cn/topic/libraries/architecture/workmanager/how-to/define-work#flexible_run_intervals">点此获取“灵活的运行间隔”说明</a></p>
<ul>
<li><strong>谁来管</strong> 工作方案谁来审批谁来管理<strong>WorkManager</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WorkManager.getInstance(myContext).enqueue(myWorkRequest);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>自此，通过Worker + WorkRequest + WorkManager就可以完成一次最简工作的调用流程，其中<strong>Worker执行工作，WorkRequest封装工作，WorkManager管理工作</strong>。</p>
<h4 id="1-3-WorkRequest类型"><a href="#1-3-WorkRequest类型" class="headerlink" title=" 1.3 WorkRequest类型"></a><span id="task_type"> 1.3 WorkRequest类型</h4><p>WorkRequest 目前有两个子类，分别为单次执行任务 <code>OneTimeWorkRequest</code>和周期执行任务 <code>PeriodicWorkRequest</code>. 他们的主要区别是任务执行方案不同导致的状态变化不同。</p>
<p><a href="https://github.com/TinloneX/WorkManagerDemo/blob/main/images/OneTimeWork_state.png">简单单次执行任务 OneTimeWorkRequest 工作状态图</a>：</p>
<p><img src="https://github.com/TinloneX/WorkManagerDemo/blob/main/images/OneTimeWork_state.png" alt="OneTimeWork_STATE"></p>
<blockquote>
<p>对于 one-time 工作请求，工作的初始状态为 ENQUEUED。</p>
</blockquote>
<blockquote>
<p>在 ENQUEUED 状态下，您的工作会在满足其 Constraints 和初始延迟计时要求后立即运行。接下来，该工作会转为 RUNNING 状态，然后可能会根据工作的结果转为 SUCCEEDED、FAILED 状态；或者，如果结果是 retry，它可能会回到 ENQUEUED 状态。在此过程中，随时都可以取消工作，取消后工作将进入 CANCELLED 状态。</p>
</blockquote>
<p><a href="https://github.com/TinloneX/WorkManagerDemo/blob/main/images/PeriodicWork_state.png">周期执行任务 PeriodicWorkRequest 工作状态图</a>：</p>
<p><img src="https://github.com/TinloneX/WorkManagerDemo/blob/main/images/PeriodicWork_state.png" alt="PeriodicWork_STATE"></p>
<p>周期性工作的初始状态为 ENQUEUED，正常执行情况下，周期性工作的状态在ENQUEUED ↔RUNNING之间交替，知道任务被取消时，状态为CANCELLED。</p>
<blockquote>
<p>成功和失败状态仅适用于一次性工作和链式工作。定期工作只有一个终止状态 CANCELLED。这是因为定期工作永远不会结束。每次运行后，无论结果如何，系统都会重新对其进行调度。</p>
</blockquote>
<p>若工作状态图无法展示，参见<a href="https://developer.android.google.cn/topic/libraries/architecture/workmanager/how-to/states-and-observation">Android-Developers/WorkManager</a>。</p>
<h4 id="1-4-一般操作"><a href="#1-4-一般操作" class="headerlink" title=" 1.4 一般操作"></a><span id="general_operation"> 1.4 一般操作</h4><p>上<a href="#how_to_use">1.2</a>中，描述了最简工作的编写，那么除了这些基本的<strong>谁来做</strong>、<strong>怎么做</strong>、<strong>谁来管</strong>外，WorkManager还有哪些可以操作的点呢？</p>
<p><strong><span id="task_listener">1.4.1 任务监听</strong> （怎么关注任务进度）</p>
<p>上面<a href="#task_type">1.3</a>中介绍了的状态，我们该如何监听这些状态呢？</p>
<p>方式1 ：</p>
<p><em>注：本文及案例未详尽的实践此方式, 此小节内容均来自<a href="https://developer.android.google.cn/topic/libraries/architecture/workmanager/how-to/managing-work#observing">官方文档</a></em></p>
<blockquote>
<p>在将工作加入队列后，您可以随时按其 name、id 或与其关联的 tag 在 WorkManager 中进行查询，以检查其状态</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; by id</span><br><span class="line">workManager.getWorkInfoById(syncWorker.id); &#x2F;&#x2F; ListenableFuture&lt;WorkInfo&gt;</span><br><span class="line">&#x2F;&#x2F; by name</span><br><span class="line">workManager.getWorkInfosForUniqueWork(&quot;sync&quot;); &#x2F;&#x2F; ListenableFuture&lt;List&lt;WorkInfo&gt;&gt;</span><br><span class="line">&#x2F;&#x2F; by tag</span><br><span class="line">workManager.getWorkInfosByTag(&quot;syncTag&quot;); &#x2F;&#x2F; ListenableFuture&lt;List&lt;WorkInfo&gt;&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 此处尝试使用此方式监听，可监听到部分状态</span><br><span class="line">WorkManager.getInstance(this).getWorkInfoById(workRequest.getId()).addListener(() -&gt; Utils.log(future), Runnable::run);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>该查询会返回 WorkInfo 对象的 ListenableFuture，该值包含工作的 id、其标记、其当前的 State 以及通过 Result.success(outputData) 设置的任何输出数据。</p>
</blockquote>
<p>方式2：</p>
<blockquote>
<p>利用每个方法的 LiveData 变种，您可以通过注册监听器来观察 WorkInfo 的变化。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WorkManager.getInstance(context)</span><br><span class="line">            .getWorkInfoByIdLiveData(workRequest.getId())</span><br><span class="line">            .observe(lifecycleOwner, new Observer&lt;WorkInfo&gt;() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void onChanged(WorkInfo workInfo) &#123;</span><br><span class="line">                    &#x2F;&#x2F; workInfo.getState() 可获取任务状态</span><br><span class="line">                    Utils.log(workInfo.getState());</span><br><span class="line">                    &#x2F;&#x2F; workInfo.getOutputData() 可获取任务传递的数据（详见1.4.2）</span><br><span class="line">                    if (workInfo.getState().isFinished()) &#123;</span><br><span class="line">                        Utils.log(workInfo.getOutputData());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure>
<p>复杂的工作查询：</p>
<p> <em><a href="https://developer.android.google.cn/topic/libraries/architecture/workmanager/how-to/managing-work#complex-queries">官方文档</a></em></p>
<blockquote>
<p>WorkManager 2.4.0 及更高版本支持使用 WorkQuery 对象对已加入队列的作业进行复杂查询。WorkQuery 支持按工作的标记、状态和唯一工作名称的组合进行查询。</p>
</blockquote>
<blockquote>
<p>以下示例说明了如何查找带有“syncTag”标记、处于 FAILED 或 CANCELLED 状态，且唯一工作名称为“preProcess”或“sync”的所有工作。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">WorkQuery workQuery = WorkQuery.Builder</span><br><span class="line">       .fromTags(Arrays.asList(<span class="string">&quot;syncTag&quot;</span>))</span><br><span class="line">       .addStates(Arrays.asList(WorkInfo.State.FAILED, WorkInfo.State.CANCELLED))</span><br><span class="line">       .addUniqueWorkNames(Arrays.asList(<span class="string">&quot;preProcess&quot;</span>, <span class="string">&quot;sync&quot;</span>)</span><br><span class="line">     )</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">ListenableFuture&lt;List&lt;WorkInfo&gt;&gt; workInfos = workManager.getWorkInfos(workQuery);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注：经实践，此方法获取的是<code>workManager.getWorkInfos(workQuery)</code>调用时任务的状态，若想使用此方法持续观察任务状态，建议使用以下方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此处应将Utils.executor()视作 ThreadPoolExecutor</span></span><br><span class="line">Utils.executor().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    ListenableFuture&lt;List&lt;WorkInfo&gt;&gt; workInfos = WorkManager.getInstance(MainActivity.<span class="keyword">this</span>)</span><br><span class="line">                            .getWorkInfos(workQuery);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        List&lt;WorkInfo&gt; infos = workInfos.get();</span><br><span class="line">                        Utils.log(infos);</span><br><span class="line">                        <span class="keyword">for</span> (WorkInfo info : infos) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (info.getState() == WorkInfo.State.SUCCEEDED ||</span><br><span class="line">                                    info.getState() == WorkInfo.State.CANCELLED) &#123;</span><br><span class="line">                                <span class="keyword">return</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        Utils.log(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<p>附：如需了解<strong>如何观察工作器的中间进度</strong>，可<a href="https://developer.android.google.cn/topic/libraries/architecture/workmanager/how-to/intermediate-progress#observing_progress">点击此处查看</a></p>
<p>特别的，我们可以借助AndroidStudio看板观察WorkManager状态。</p>
<ul>
<li>AndroidStudio白狐之前的版本可使用DataBase Inspector 观察 androidx.work.workdb数据库中WorkSpec表获取WorkRequest信息；</li>
<li>AndroidStudio白狐版则可直接使用WorkManager Inspector查看WorkRequest信息。</li>
</ul>
<p><strong><span id="transfer_data">1.4.2 传递数据</strong></p>
<p>在一些业务场景下，我们需要向任务中传递数据，可以使用<code>androidx.work.Data</code>向WorkRequest中添加数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建需传递的数据</span><br><span class="line">Data data &#x3D; new Data.Builder().putString(&quot;message&quot;, &quot;MainActivity&quot;).build();</span><br><span class="line">&#x2F;&#x2F; 单次执行任务</span><br><span class="line">OneTimeWorkRequest request1 &#x3D; new OneTimeWorkRequest.Builder(Task4DataWorker.class)</span><br><span class="line">        &#x2F;&#x2F; 向WorkRequest中添加数据</span><br><span class="line">        .setInputData(data).build();</span><br><span class="line">&#x2F;&#x2F; 将任务加入队列</span><br><span class="line">WorkManager.getInstance(this).enqueue(request1);</span><br></pre></td></tr></table></figure>
<p>需要注意的是，由Data源码可知，此处传递数据仅支持基础数据类型及其封装、String以及上述类型的数组：</p>
<blockquote>
<p>Puts an input key-value pair into the Builder. Valid types are: Boolean, Integer,  Long, Float, Double, String, and array versions of each of those types. Invalid types throw an {@link IllegalArgumentException}.</p>
</blockquote>
<p><em>当然的，有没有想使用反射向Data中的mValues注入其他类型呢？<code>Map<String, Object> mValues = new HashMap<>();</code>, 期待你的尝试！</em></p>
<p>有传递数据自然有获取数据，我们可以Worker中通过<code>getInputData()</code>获取<br>传入的Data对象，通过Data获取传入的值，也可以通过Data和Result将值传递给观察者。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Task4DataWorker extends Worker &#123;</span><br><span class="line"></span><br><span class="line">    public Task4DataWorker(@NonNull Context context, @NonNull WorkerParameters workerParams) &#123;</span><br><span class="line">        super(context, workerParams);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressLint(&quot;RestrictedApi&quot;)</span><br><span class="line">    @NonNull</span><br><span class="line">    @Override</span><br><span class="line">    public Result doWork() &#123;</span><br><span class="line">        String message &#x3D; getInputData().getString(&quot;message&quot;);</span><br><span class="line">        Data myMsg &#x3D; new Data.Builder().putString(&quot;message&quot;, &quot;message from Worker&quot;).build();</span><br><span class="line">        return new Result.Success(myMsg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而从Worker中传出的Data则可在WorkRequest的工作状态WorkInfo中取得：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WorkManager.getInstance(context)</span><br><span class="line">               .getWorkInfoByIdLiveData(workRequest.getId())</span><br><span class="line">               .observe(context, workInfo -&gt; &#123;</span><br><span class="line">                   if (workInfo!&#x3D;null)&#123;</span><br><span class="line">                       if (workInfo.getState().isFinished()) &#123;</span><br><span class="line">                           String message &#x3D; workInfo.getOutputData().getString(&quot;message&quot;);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;);</span><br></pre></td></tr></table></figure>
<p><strong><span id="multiple_ask">1.4.3 多任务串联</strong></p>
<p>除一般的单一任务的场景外，我们面对的业务往往也要处理多个任务的场景，此时我们可以串联多个任务，也可以将多个任务编组成任务链去使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WorkManager.getInstance(this).beginWith(workRequest2)</span><br><span class="line">                .then(workRequest3)</span><br><span class="line">                .then(workRequest4)</span><br><span class="line">                .enqueue();</span><br><span class="line">&#x2F;&#x2F; or</span><br><span class="line">WorkContinuation continuation &#x3D; WorkManager.getInstance(this)</span><br><span class="line">                .beginWith(workRequest2)</span><br><span class="line">                .then(workRequest3)</span><br><span class="line">                .then(workRequest4);</span><br><span class="line"></span><br><span class="line">continuation.then(workRequest).enqueue();</span><br></pre></td></tr></table></figure>
<p>特别的，如需了解<strong>任务链的高级用法及合并器</strong>相关内容，<a href="https://developer.android.google.cn/topic/libraries/architecture/workmanager/how-to/chain-work#input-mergers">请点击此处查看官方文档</a>，其中关于<a href="https://developer.android.google.cn/topic/libraries/architecture/workmanager/how-to/chain-work#work-statuses">链接和工作状态</a>的说明图文并茂，更易于理解。</p>
<p><strong><span id="UniqueWork">1.4.4 唯一任务</strong></p>
<blockquote>
<p>唯一工作是一个很实用的概念，可确保同一时刻只有一个具有特定名称的工作实例。与 ID 不同的是，唯一名称是人类可读的，由开发者指定，而不是由 WorkManager 自动生成。与标记不同，唯一名称仅与一个工作实例相关联。</p>
</blockquote>
<blockquote>
<p>唯一工作既可用于一次性工作，也可用于定期工作。您可以通过调用以下方法之一创建唯一工作序列，具体取决于您是调度重复工作还是一次性工作。WorkManager.enqueueUniqueWork()（用于一次性工作）<br>    WorkManager.enqueueUniquePeriodicWork()（用于定期工作）</p>
</blockquote>
<p>这两种方法都接受 3 个参数：</p>
<pre><code>uniqueWorkName - 用于唯一标识工作请求的 String。
existingWorkPolicy - 此 enum 可告知 WorkManager：如果已有使用该名称且尚未完成的唯一工作链，应执行什么操作。如需了解详情，请参阅冲突解决政策。
work - 要调度的 WorkRequest。
</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OneTimeWorkRequest workRequest &#x3D; new OneTimeWorkRequest.Builder(SimpleWorker2.class).build();</span><br><span class="line">OneTimeWorkRequest workRequest2 &#x3D; new OneTimeWorkRequest.Builder(SimpleWorker2.class).build();</span><br><span class="line"></span><br><span class="line">WorkManager.getInstance(this).beginUniqueWork(&quot;SimpleWorker&quot;,</span><br><span class="line">        ExistingWorkPolicy.REPLACE, workRequest)</span><br><span class="line">&#x2F;&#x2F;      ExistingWorkPolicy.APPEND, workRequest)</span><br><span class="line">&#x2F;&#x2F;      ExistingWorkPolicy.KEEP, workRequest)</span><br><span class="line">        .then(workRequest2)</span><br><span class="line">&#x2F;&#x2F;      .then(workRequest)</span><br><span class="line">        .enqueue();</span><br></pre></td></tr></table></figure>
<p>此处定义的唯一，仅在任务正在执行且出现相同<code>uniqueWorkName</code>名称时，existingWorkPolicy才生效，无法影响已结束的同名任务（此同名仅与uniqueWorkName有关）。<br>以定义两个相同<code>uniqueWorkName</code>的WorkRequest为例，来观察existingWorkPolicy值的作用及影响：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 若发现名为“SimpleWorker”的任务，则使用此链替换目标后续操作</span><br><span class="line">&#x2F;&#x2F; 任务链 A</span><br><span class="line">WorkManager.getInstance(this).beginUniqueWork(&quot;SimpleWorker&quot;,</span><br><span class="line">        ExistingWorkPolicy.REPLACE, workRequest)</span><br><span class="line">        .then(request3)</span><br><span class="line">        .enqueue();</span><br><span class="line">&#x2F;&#x2F; 若发现名为“SimpleWorker”的任务，则保留目标的原操作，此链不执行</span><br><span class="line">&#x2F;&#x2F; 任务链 B</span><br><span class="line">WorkManager.getInstance(this).beginUniqueWork(&quot;SimpleWorker&quot;,</span><br><span class="line">        ExistingWorkPolicy.KEEP, workRequest5)</span><br><span class="line">        .then(request2)</span><br><span class="line">        .enqueue();</span><br></pre></td></tr></table></figure>
<p>上述两个任务链，若先执行A再执行B，此时效果为：</p>
<pre><code>workUnique2 start   // 任务链A触发
workUnique2 end     // 任务链A触发完毕
doWork start: SimpleWorker  // 任务链A耗时任务workRequest开始执行
workUnique start    // 任务链B触发
workUnique end      // 任务链B触发完毕
doWork end: SimpleWorker // 任务链A耗时任务workRequest执行完毕
doWork: SimpleWorker3   // 任务链A执行后续任务request3
任务链B并未执行
</code></pre>
<p>上述两个任务链，若先执行B再执行A，此时效果为：</p>
<pre><code>workUnique start    // 任务链B触发
workUnique end      // 任务链B触发完毕
doWork start: SimpleWorker5 // 任务链B耗时任务workRequest5开始执行
workUnique2 start   // 任务链A触发
workUnique2 end     // 任务链A触发完毕
doWork start: SimpleWorker  // 任务链A耗时任务workRequest开始执行
doWork end: SimpleWorker5   // 任务链B耗时任务workRequest5执行完毕
doWork end: SimpleWorker    // 任务链A耗时任务workRequest执行完毕
doWork: SimpleWorker3       // 任务链A执行后续任务request3
任务链B耗时任务被执行但后续操作被同名任务链A覆盖
</code></pre>
<p>同理，我们将任务链A的冲突方案分别定义为<code>ExistingWorkPolicy.APPEND</code>、<code>ExistingWorkPolicy.APPEND_OR_REPLACE</code>，观察执行情况，得出如下结论：</p>
<ul>
<li>ExistingWorkPolicy.REPLACE 会替换正在执行的同名任务重新执行，并使用自己的任务链覆盖原任务链；</li>
<li>ExistingWorkPolicy.KEEP 会保持原任务链执行，自己不执行；</li>
<li>ExistingWorkPolicy.APPEND 会等待原任务链同名任务及后续任务执行完毕，才执行自己的任务链；</li>
<li>ExistingWorkPolicy.APPEND_OR_REPLACE 若原任务链及新任务链未被取消或中断，则<br>与APPEND性质一致, 其他情况：<blockquote>
<p>If there is existing pending (uncompleted) work with the same unique name, append the newly-specified work as the child of all the leaves of that work sequence. Otherwise, insert the newly-specified work as the start of a new sequence. Note: If there are failed or cancelled prerequisites, these prerequisites are dropped and the newly-specified work is the start of a new sequence.如果存在具有相同唯一名称的未决(未完成)工作，则将新指定的工作附加为该工作序列的所有叶节点的子节点。否则，插入新指定的工作作为新序列的开始。注意:如果有失败或取消的先决条件，这些先决条件将被删除，而新指定的工作将是一个新序列的开始。</p>
</blockquote>
</li>
</ul>
<p><strong><span id="task_onstraint">1.4.5 任务约束</strong></p>
<p><a href="https://developer.android.google.cn/topic/libraries/architecture/workmanager/how-to/define-work#work-constraints">参见文档</a></p>
<blockquote>
<p>Constraints可确保将工作延迟到满足最佳条件时运行。以下约束适用于 WorkManager。</p>
</blockquote>
<pre><code>NetworkType     约束运行工作所需的网络类型。例如 Wi-Fi (UNMETERED)。
BatteryNotLow     如果设置为 true，那么当设备处于“电量不足模式”时，工作不会运行。
RequiresCharging     如果设置为 true，那么工作只能在设备充电时运行。
DeviceIdle     如果设置为 true，则要求用户的设备必须处于空闲状态，才能运行工作。如果您要运行批量操作，否则可能会降低用户设备上正在积极运行的其他应用的性能，建议您使用此约束。
StorageNotLow     如果设置为 true，那么当用户设备上的存储空间不足时，工作不会运行
</code></pre>
<p>注意：<br>实际测试中，使用Android 6.0~11.0等一系列版本的模拟器测试发现</p>
<ul>
<li>9.0以下版本手机，不论应用是否在前台，进程是否存活，只要满足约束条件任务就会尽快执行；</li>
<li>9.0及以上版本手机，应用进程DEAD状态，在符合约束条件时任务也不一定会尽快执行，甚至即使进入App也不一定能立马得到执行，除非有新的WorkRequest入队。</li>
</ul>
<p><strong><span id="task_delay">1.4.6 任务延时</strong></p>
<p><a href="https://developer.android.google.cn/topic/libraries/architecture/workmanager/how-to/define-work#delayed_work">参见文档</a></p>
<blockquote>
<p>如果工作没有约束，或者当工作加入队列时所有约束都得到了满足，那么系统可能会选择立即运行该工作。如果您不希望工作立即运行，可以将工作指定为在经过一段最短初始延迟时间后再启动。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WorkRequest myWorkRequest &#x3D;</span><br><span class="line">      new OneTimeWorkRequest.Builder(MyWork.class)</span><br><span class="line">               .setInitialDelay(10, TimeUnit.MINUTES)</span><br><span class="line">               .build();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：执行工作器的确切时间还取决于 WorkRequest 中使用的约束和系统优化方式。WorkManager 经过设计，能够在满足这些约束的情况下提供可能的最佳行为。<br>定期工作只有首次运行时会延迟</p>
</blockquote>
<p><strong><span id="retry_rollback">1.4.7 重试和退避政策</strong></p>
<p><a href="https://developer.android.google.cn/topic/libraries/architecture/workmanager/how-to/define-work#retry_and_backoff_policy">参见文档</a></p>
<p>若Worker返回结果Result.retry()时，触发重试退避政策，即下次调度Worker应在多长时间以后，支持设置退避时间基数和基数递增方式，递增方式目前支持线性<code>LINEAR</code>和指数<code>EXPONENTIAL</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OneTimeWorkRequest workRequest &#x3D; new OneTimeWorkRequest.Builder(RetryWorker.class)</span><br><span class="line">                .setBackoffCriteria(BackoffPolicy.LINEAR,</span><br><span class="line">                        OneTimeWorkRequest.MIN_BACKOFF_MILLIS,</span><br><span class="line">                        TimeUnit.MILLISECONDS)</span><br><span class="line">                .build();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：退避延迟时间不精确，在两次重试之间可能会有几秒钟的差异，但绝不会低于配置中指定的初始退避延迟时间。</p>
</blockquote>
<p>退避时间在满足执行条件情况下也并不会完全精确，若不满足执行条件则会等待其条件满足：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 无约束</span><br><span class="line">间隔时间(ms): 10109 </span><br><span class="line">间隔时间(ms): 20094</span><br><span class="line">间隔时间(ms): 30093</span><br><span class="line">...</span><br><span class="line">&#x2F;&#x2F; 约束：计费(量)网络环境下</span><br><span class="line">间隔时间(ms): 10121</span><br><span class="line">间隔时间(ms): 20143</span><br><span class="line">间隔时间(ms): 30103</span><br><span class="line">&#x2F;&#x2F; 关闭wifi喝个茶再连接wifi</span><br><span class="line">间隔时间(ms): 146521</span><br><span class="line">间隔时间(ms): 50132</span><br></pre></td></tr></table></figure>
<p><strong><span id="work_tag">1.4.8 标记工作</strong></p>
<p><a href="https://developer.android.google.cn/topic/libraries/architecture/workmanager/how-to/define-work#tag_work">参见文档</a></p>
<p>你可以为WorkRequest添加tag，从而使得你可以通过<code>WorkManager.getWorkInfosByTag(String)</code>获取WorkRequest的工作状态WorkInfo，你也可以直接通过<code>WorkManager.cancelAllWorkByTag(String)</code>取消对应标记的所有WorkRequest.</p>
<p>由WorkRequest中关于tag的定义<code>Set<String> mTags</code>可知，你可以为WorkRequest定义多个标记，当然的，你也可以为多个WorkRequest定义同一个标记用以统一管理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WorkRequest request &#x3D;</span><br><span class="line">       new OneTimeWorkRequest.Builder(SimpleWorker.class)</span><br><span class="line">       .addTag(&quot;TAG&quot;)</span><br><span class="line">       .build();</span><br><span class="line">&#x2F;&#x2F; 根据tag取消任务</span><br><span class="line">WorkManager.getInstance(this).cancelAllWorkByTag(&quot;TAG&quot;);</span><br><span class="line">&#x2F;&#x2F; 根据tag查找任务状态</span><br><span class="line">WorkManager.getInstance(this).getWorkInfosByTag(&quot;TAG&quot;);</span><br></pre></td></tr></table></figure>
<p><strong><span id="work_cancel">1.4.9 取消工作</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; by id</span><br><span class="line">workManager.cancelWorkById(syncWorker.id);</span><br><span class="line">&#x2F;&#x2F; by name</span><br><span class="line">workManager.cancelUniqueWork(&quot;sync&quot;);</span><br><span class="line">&#x2F;&#x2F; by tag</span><br><span class="line">workManager.cancelAllWorkByTag(&quot;syncTag&quot;);</span><br></pre></td></tr></table></figure>
<p><a href="https://developer.android.google.cn/topic/libraries/architecture/workmanager/how-to/managing-work#stop-worker">点此了解“停止正在运行的工作器”的相关内容</a></p>
<h4 id="1-5-注意事项"><a href="#1-5-注意事项" class="headerlink" title=" 1.5 注意事项"></a><span id="attention"> 1.5 注意事项</h4><p>这里我们总结一下使用WorkManager的一些小Tips。</p>
<ul>
<li>PeriodicWorkRequest周期任务可以定义的最短重复间隔是 15 分钟（与 JobScheduler API 相同）</li>
<li>延迟工作：执行工作器的确切时间还取决于 WorkRequest 中使用的约束和系统优化方式。WorkManager 经过设计，能够在满足这些约束的情况下提供可能的最佳行为。</li>
<li>退避延迟时间不精确，在两次重试之间可能会有几秒钟的差异，但绝不会低于配置中指定的初始退避延迟时间。</li>
<li>cancelAllWorkByTag(String) 会取消具有给定标记的所有工作。</li>
<li>WorkRequest保证一定执行，但不保证一定在什么时间执行。</li>
</ul>
<hr>
<p>引用文献：</p>
<ol>
<li><a href="https://developer.android.google.cn/topic/libraries/architecture/workmanager">WorkManager官方文档</a></li>
</ol>
<h4 id="源码篇正在奋力码字中。。。"><a href="#源码篇正在奋力码字中。。。" class="headerlink" title="源码篇正在奋力码字中。。。"></a>源码篇正在奋力码字中。。。</h4>]]></content>
      <categories>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>WorkManager</tag>
      </tags>
  </entry>
  <entry>
    <title>WorkManager基本使用及源码分析(七) - BroadcastReceiver</title>
    <url>/2021/02/15/WorkManager%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%B8%83)%20-%20BroadcastReceiver/</url>
    <content><![CDATA[<ul>
<li><a href="#source_broadcast">源码篇 - 广播接收者</a></li>
<li><a href="#ForceStopRunnable">ForceStopRunnable</a><ul>
<li><a href="#fsr_BroadcastReceiver">BroadcastReceiver</a></li>
</ul>
</li>
<li><a href="#ConstraintProxy">ConstraintProxy</a><ul>
<li><a href="#BatteryNotLowProxy">BatteryNotLowProxy</a></li>
<li><a href="#BatteryChargingProxy">BatteryChargingProxy</a></li>
<li><a href="#StorageNotLowProxy">StorageNotLowProxy</a></li>
<li><a href="#NetworkStateProxy">NetworkStateProxy</a></li>
</ul>
</li>
<li><a href="#ConstraintProxyUpdateReceiver">ConstraintProxyUpdateReceiver</a></li>
<li><a href="#RescheduleReceiver">RescheduleReceiver</a></li>
<li><a href="#DiagnosticsReceiver">DiagnosticsReceiver</a></li>
</ul>
<h3 id="源码篇-广播接收者"><a href="#源码篇-广播接收者" class="headerlink" title=" 源码篇 - 广播接收者"></a><span id="source_broadcast"> 源码篇 - 广播接收者</h3><p>此篇将重点介绍WorkManager使用的重要组件:广播接收者,主要涉及意外停止监听广播<code>ForceStopRunnable.BroadcastReceiver</code>、约束状态监听广播<code>ConstraintProxy.*</code>、启动重新规划服务的广播<code>RescheduleReceiver</code>、代理约束更新广播<code>ConstraintProxyUpdateReceiver</code>、测试诊断广播<code>DiagnosticsReceiver</code>。此类组件为WorkManager稳定运行、重新规划、约束更新提供了支持。</p>
<a id="more"></a>

<h4 id="ForceStopRunnable"><a href="#ForceStopRunnable" class="headerlink" title=" ForceStopRunnable"></a><span id="ForceStopRunnable"> ForceStopRunnable</h4><blockquote>
<p>WorkManager is restarted after an app was force stopped. Alarms and Jobs get cancelled when an application is force-stopped. To reschedule, we create a pending alarm that will not survive force stops.</p>
</blockquote>
<p>强制停止应用程序后，<code>WorkManager</code>将重新启动。当应用被强制停止时，<code>Alarms</code>和<code>Jobs</code>将被取消。为了重新安排，我们要创建一个无法通过强制停止的<code>Alarm</code>。</p>
<p>在介绍<code>ForceStopRunnable.BroadcastReceiver</code>前,我们先简单看一下它的外部类<code>ForceStopRunnable</code>。</p>
<p><code>ForceStopRunnable</code>是一个Runnable对象，核心方法是<code>run</code>, 其在<code>WorkManager</code>初始化时调用<code>WorkManagerImpl.internalInit()</code>, 构造并调用了<code>ForceStopRunnable.run()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果需要，将数据库迁移到不备份的目录。</span></span><br><span class="line">    WorkDatabasePathHelper.migrateDatabase(mContext);</span><br><span class="line">    <span class="comment">// 清除属于WorkManager的无效作业，以及由于应用程序崩溃(运行状态)而可能被中断的作业。</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> needsScheduling = cleanUp();</span><br><span class="line">        <span class="keyword">if</span> (shouldRescheduleWorkers()) &#123;</span><br><span class="line">            mWorkManager.rescheduleEligibleWork();</span><br><span class="line">            <span class="comment">// 将WorkManager标记为已迁移。</span></span><br><span class="line">            mWorkManager.getPreferenceUtils().setNeedsReschedule(<span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isForceStopped()) &#123;</span><br><span class="line">            <span class="comment">// 异常退出，重新规划任务</span></span><br><span class="line">            mWorkManager.rescheduleEligibleWork();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (needsScheduling) &#123;</span><br><span class="line">           <span class="comment">// 发现未完成任务，规划它们</span></span><br><span class="line">            Schedulers.schedule(</span><br><span class="line">                    mWorkManager.getConfiguration(),</span><br><span class="line">                    mWorkManager.getWorkDatabase(),</span><br><span class="line">                    mWorkManager.getSchedulers());</span><br><span class="line">        &#125;</span><br><span class="line">        mWorkManager.onForceStopRunnableCompleted();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLiteCantOpenDatabaseException</span><br><span class="line">            | SQLiteDatabaseCorruptException</span><br><span class="line">            | SQLiteAccessPermException exception) &#123;</span><br><span class="line">        <span class="comment">// ForceStopRunnable通常是访问数据库(或应用程序的内部数据目录)的第一件事。</span></span><br><span class="line">        <span class="comment">// 这意味着奇怪的PackageManager错误被归咎于ForceStopRunnable，这是不幸的。</span></span><br><span class="line">        <span class="comment">// 这为开发人员提供了更好的错误消息。</span></span><br><span class="line">        String message =</span><br><span class="line">                <span class="string">&quot;The file system on the device is in a bad state. WorkManager cannot access &quot;</span></span><br><span class="line">                        + <span class="string">&quot;the app&#x27;s internal data store.&quot;</span>;</span><br><span class="line">        Logger.get().error(TAG, message, exception);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(message, exception);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们发现<code>ForceStopRunable</code>主要职责是处理异常中断后对WorkManager中任务进行清理和重新规划,<code>run()</code>主要干了3件事:</p>
<ul>
<li>如果需要，将数据库迁移到不备份的目录</li>
<li>取消无效的JobScheduler作业/重新调度以前正在运行的作业</li>
<li>针对异常中断时WorkManager的状态进行不同的调度操作</li>
</ul>
<p>那么他是如何判断是否是强制中断的呢，我们可以看下强制中断判断代码<code>isForceStopped()</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@VisibleForTesting</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isForceStopped</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当应用程序在Eclair MR1强制停止启动时，Alarm被取消。</span></span><br><span class="line">    <span class="comment">// 在N-MR1中引入了强制停止作业的取消(SDK 25)。</span></span><br><span class="line">    <span class="comment">// 尽管API 23、24可能是安全的，但oem可能会选择采用不同的方法。</span></span><br><span class="line">    PendingIntent pendingIntent = getPendingIntent(mContext, FLAG_NO_CREATE);</span><br><span class="line">    <span class="keyword">if</span> (pendingIntent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        setAlarm(mContext);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过判断闹钟广播是否存在来确定应用是否被强行停止，若不存在即闹钟Alarm被取消即是强制中断，此时将重新设置一个闹钟Alarm;</p>
<p>让我们来看看上文中的<code>ForceStopRunnable.BroadcastReceiver</code>闹钟广播。</p>
<h5 id="BroadcastReceiver"><a href="#BroadcastReceiver" class="headerlink" title=" BroadcastReceiver"></a><span id="BroadcastReceiver"> BroadcastReceiver</h5><blockquote>
<p>A {@link android.content.BroadcastReceiver} which takes care of recreating the long lived alarm which helps track force stops for an application.  This is the target of the alarm set by ForceStopRunnable in {@link #setAlarm(Context)}. 一个{@link android.content.BroadcastReceiver}负责重新创建长寿命的Alarm，这有助于跟踪应用程序的强制停止。这是在{@link #setAlarm(Context)}中由forceoprunnable设置的Alarm目标。</p>
</blockquote>
<p>从描述可知，此广播的主要目的是负责创建长期存活的闹钟，用以追踪应用程序的强制停止。</p>
<p>其代码相对简单，若收到action为<code>ACTION_FORCE_STOP_RESCHEDULE</code>的广播，则设置一个长达十年的可唤醒设备的闹钟，然后再来一次（发送action为<code>ACTION_FORCE_STOP_RESCHEDULE</code>的广播）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ForceStopRunnable</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> PendingIntent <span class="title">getPendingIntent</span><span class="params">(Context context, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    Intent intent = getIntent(context);</span><br><span class="line">    <span class="comment">// 发送广播的PendingIntent</span></span><br><span class="line">    <span class="keyword">return</span> PendingIntent.getBroadcast(context, ALARM_ID, intent, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@VisibleForTesting</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Intent <span class="title">getIntent</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">    intent.setComponent(<span class="keyword">new</span> ComponentName(context, ForceStopRunnable.BroadcastReceiver.class));</span><br><span class="line">    <span class="comment">// 广播intent</span></span><br><span class="line">    intent.setAction(ACTION_FORCE_STOP_RESCHEDULE);</span><br><span class="line">    <span class="keyword">return</span> intent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setAlarm</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    AlarmManager alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);</span><br><span class="line">    <span class="comment">//使用FLAG_UPDATE_CURRENT，因为我们只需要这个Alarm的一次实例</span></span><br><span class="line">    PendingIntent pendingIntent = getPendingIntent(context, FLAG_UPDATE_CURRENT);</span><br><span class="line">    <span class="comment">// 设置执行时间为十年</span></span><br><span class="line">    <span class="keyword">long</span> triggerAt = System.currentTimeMillis() + TEN_YEARS;</span><br><span class="line">    <span class="keyword">if</span> (alarmManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">19</span>) &#123;</span><br><span class="line">            <span class="comment">// RTC_WAKEUP：绝对时间可唤醒类型，十年后，干啥</span></span><br><span class="line">            alarmManager.setExact(RTC_WAKEUP, triggerAt, pendingIntent);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            alarmManager.set(RTC_WAKEUP, triggerAt, pendingIntent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BroadcastReceiver</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">content</span>.<span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Our alarm somehow got triggered, so make sure we reschedule it.  This should really never happen because we set it so far in the future.</span></span><br><span class="line">        <span class="comment">// 我们的闹钟不知怎么被触发了，所以一定要重新安排时间。这是不应该发生的，因为我们将它设置在遥远的未来（嘿，十年后再见）。</span></span><br><span class="line">        <span class="keyword">if</span> (intent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            String action = intent.getAction();</span><br><span class="line">            <span class="keyword">if</span> (ACTION_FORCE_STOP_RESCHEDULE.equals(action)) &#123;</span><br><span class="line">                Logger.get().verbose(</span><br><span class="line">                        TAG,</span><br><span class="line">                        <span class="string">&quot;Rescheduling alarm that keeps track of force-stops.&quot;</span>);</span><br><span class="line">                ForceStopRunnable.setAlarm(context);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有前文可知，应用启动时会初始化WorkManager，WorkManager初始化则会执行<code>ForceStopRunnable.run()</code>, 此时一般会调用setAlarm(), 创建Alarm，极端情况下会存在应用存活十年的情况，此<code>BroadcastReceiver</code>即是用于处理这种情况的，当十年后又收到了这个广播，那么我们在创建一个十年期的闹钟Alarm，哦，天呐。</p>
<h4 id="ConstraintProxy"><a href="#ConstraintProxy" class="headerlink" title=" ConstraintProxy"></a><span id="ConstraintProxy"> ConstraintProxy</h4><h5 id="BatteryNotLowProxy"><a href="#BatteryNotLowProxy" class="headerlink" title=" BatteryNotLowProxy"></a><span id="BatteryNotLowProxy"> BatteryNotLowProxy</h5><h5 id="BatteryChargingProxy"><a href="#BatteryChargingProxy" class="headerlink" title=" BatteryChargingProxy"></a><span id="BatteryChargingProxy"> BatteryChargingProxy</h5><h5 id="StorageNotLowProxy"><a href="#StorageNotLowProxy" class="headerlink" title=" StorageNotLowProxy"></a><span id="StorageNotLowProxy"> StorageNotLowProxy</h5><h5 id="NetworkStateProxy"><a href="#NetworkStateProxy" class="headerlink" title=" NetworkStateProxy"></a><span id="NetworkStateProxy"> NetworkStateProxy</h5><p>上述<code>BatteryNotLowProxy</code>、<code>BatteryChargingProxy</code>、<code>StorageNotLowProxy</code>、<code>NetworkStateProxy</code>均是<code>ConstraintProxy</code>的子类,实现均一致,仅有注册action不同,用以针对不同action的系统广播更新约束状态, 此处一并分析之。</p>
<p>以<code>NetworkStateProxy</code>为例，当网络状态变化，应用收到<code>"android.net.conn.CONNECTIVITY_CHANGE"</code>广播，触发<code>NetworkStateProxy.onReceive()</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">    Logger.get().debug(TAG, String.format(<span class="string">&quot;onReceive : %s&quot;</span>, intent));</span><br><span class="line">    Intent constraintChangedIntent = CommandHandler.createConstraintsChangedIntent(context);</span><br><span class="line">    context.startService(constraintChangedIntent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用<code>CommandHandler.createConstraintsChangedIntent(context)</code>调起<code>SystemAlarmService</code>, 其intent的action为<code>"ACTION_CONSTRAINTS_CHANGED"</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Intent <span class="title">createConstraintsChangedIntent</span><span class="params">(<span class="meta">@NonNull</span> Context context)</span> </span>&#123;</span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent(context, SystemAlarmService.class);</span><br><span class="line">    intent.setAction(ACTION_CONSTRAINTS_CHANGED);</span><br><span class="line">    <span class="keyword">return</span> intent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由<a href="#https://tinlone.com/2021/02/06/WorkManager%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%B8%89)%20-%20SystemAlarmService/">WorkManager基本使用及源码分析(三) - SystemAlarmService</a>讲述流程可知，最终会调用到<code>CommandHandler.onHandleIntent()</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void onHandleIntent(@NonNull Intent intent, int startId, @NonNull SystemAlarmDispatcher dispatcher) &#123;</span><br><span class="line">        String action &#x3D; intent.getAction();</span><br><span class="line"></span><br><span class="line">        if (ACTION_CONSTRAINTS_CHANGED.equals(action)) &#123;</span><br><span class="line">            handleConstraintsChanged(intent, startId, dispatcher);</span><br><span class="line">        &#125; </span><br><span class="line">        &#x2F;&#x2F; 其他</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void handleConstraintsChanged(</span><br><span class="line">        @NonNull Intent intent, int startId,</span><br><span class="line">        @NonNull SystemAlarmDispatcher dispatcher) &#123;</span><br><span class="line">    ConstraintsCommandHandler changedCommandHandler &#x3D;</span><br><span class="line">            new ConstraintsCommandHandler(mContext, startId, dispatcher);</span><br><span class="line">    changedCommandHandler.handleConstraintsChanged();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时intent的action为<code>"ACTION_CONSTRAINTS_CHANGED"</code>，最终会调用到<code>ConstraintsCommandHandler.handleConstraintsChanged()</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void handleConstraintsChanged() &#123;</span><br><span class="line">    List&lt;WorkSpec&gt; candidates &#x3D; mDispatcher.getWorkManager().getWorkDatabase()</span><br><span class="line">            .workSpecDao()</span><br><span class="line">            .getScheduledWork();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;更新约束代理以潜在地禁用先前完成的WorkSpecs的代理。</span><br><span class="line">    ConstraintProxy.updateAll(mContext, candidates);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 这需要在每个约束控制器中填充匹配的WorkSpec id。标记正在更新这些工作的状态</span><br><span class="line">    mWorkConstraintsTracker.replace(candidates);</span><br><span class="line"></span><br><span class="line">    List&lt;WorkSpec&gt; eligibleWorkSpecs &#x3D; new ArrayList&lt;&gt;(candidates.size());</span><br><span class="line">    &#x2F;&#x2F; 筛选候选人应该已经规划好了。</span><br><span class="line">    long now &#x3D; System.currentTimeMillis();</span><br><span class="line">    for (WorkSpec workSpec : candidates) &#123;</span><br><span class="line">        String workSpecId &#x3D; workSpec.id;</span><br><span class="line">        long triggerAt &#x3D; workSpec.calculateNextRunTime();</span><br><span class="line">        &#x2F;&#x2F; 时间条件符合且无约束或约束已符合，则加入符合条件集合</span><br><span class="line">        if (now &gt;&#x3D; triggerAt &amp;&amp; (!workSpec.hasConstraints()</span><br><span class="line">                || mWorkConstraintsTracker.areAllConstraintsMet(workSpecId))) &#123;</span><br><span class="line">            eligibleWorkSpecs.add(workSpec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (WorkSpec workSpec : eligibleWorkSpecs) &#123;</span><br><span class="line">        String workSpecId &#x3D; workSpec.id;</span><br><span class="line">        Intent intent &#x3D; CommandHandler.createDelayMetIntent(mContext, workSpecId);</span><br><span class="line">        &#x2F;&#x2F; 告诉SystemAlarmDispatcher这个工作已经符合条件了，请给安排上</span><br><span class="line">        mDispatcher.postOnMainThread(</span><br><span class="line">                new SystemAlarmDispatcher.AddRunnable(mDispatcher, intent, mStartId));</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 重置正在更新这些工作状态的标记</span><br><span class="line">    mWorkConstraintsTracker.reset();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此方法先获取了规划中的工作生成集合，调用了<code>ConstraintProxy.updateAll()</code>方法更新约束代理以潜在地禁用先前完成的WorkSpecs的代理，遍历判断每个WorkSpec是否符合条件，遍历符合约束条件的列表，告诉<code>SystemAlarmDispatcher</code>添加任务，若<code>SystemAlarmDispatcher</code>中无任务则分发执行任务（还记得processCommand()是一个环状的轮询吗？）。</p>
<p><code>SystemAlarmDispatcher.AddRunnable()</code>后续调用<code>SystemAlarmDispatcher.add()</code>在<a href="#https://tinlone.com/2021/02/06/WorkManager%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%B8%89)%20-%20SystemAlarmService/">WorkManager基本使用及源码分析(三) - SystemAlarmService</a>中有详细说明，此处仅摘要流程。<br><code>SystemAlarmDispatcher.AddRunnable()</code> -&gt; <code>SystemAlarmDispatcher.add()</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SystemAlarmDispatcher</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(<span class="meta">@NonNull</span> <span class="keyword">final</span> Intent intent, <span class="keyword">final</span> <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String action = intent.getAction();</span><br><span class="line">    <span class="keyword">if</span> (TextUtils.isEmpty(action)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (CommandHandler.ACTION_CONSTRAINTS_CHANGED.equals(action)</span><br><span class="line">            &amp;&amp; hasIntentWithAction(CommandHandler.ACTION_CONSTRAINTS_CHANGED)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    intent.putExtra(KEY_START_ID, startId);</span><br><span class="line">    <span class="keyword">synchronized</span> (mIntents) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> hasCommands = !mIntents.isEmpty();</span><br><span class="line">        mIntents.add(intent);</span><br><span class="line">        <span class="keyword">if</span> (!hasCommands) &#123;</span><br><span class="line">            processCommand();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AddRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mDispatcher.add(mIntent, mStartId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ConstraintProxyUpdateReceiver"><a href="#ConstraintProxyUpdateReceiver" class="headerlink" title=" ConstraintProxyUpdateReceiver"></a><span id="ConstraintProxyUpdateReceiver"> ConstraintProxyUpdateReceiver</h4><p>上面讲到<code>ConstraintsCommandHandler.handleConstraintsChanged()</code>第一步会调用<code>ConstraintProxy.updateAll(mContext, candidates)</code>最终会发送广播给<code>ConstraintProxyUpdateReceiver</code>更新约束代理以潜在地禁用先前完成的WorkSpecs的代理,我们简单过一下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void updateAll(Context context, List&lt;WorkSpec&gt; workSpecs) &#123;</span><br><span class="line">    boolean batteryNotLowProxyEnabled &#x3D; false;</span><br><span class="line">    boolean batteryChargingProxyEnabled &#x3D; false;</span><br><span class="line">    boolean storageNotLowProxyEnabled &#x3D; false;</span><br><span class="line">    boolean networkStateProxyEnabled &#x3D; false;</span><br><span class="line">&#x2F;&#x2F; 查找每个WorkSpec（是否有）约束条件状态</span><br><span class="line">    for (WorkSpec workSpec : workSpecs) &#123;</span><br><span class="line">        Constraints constraints &#x3D; workSpec.constraints;</span><br><span class="line">        batteryNotLowProxyEnabled |&#x3D; constraints.requiresBatteryNotLow();</span><br><span class="line">        batteryChargingProxyEnabled |&#x3D; constraints.requiresCharging();</span><br><span class="line">        storageNotLowProxyEnabled |&#x3D; constraints.requiresStorageNotLow();</span><br><span class="line">        networkStateProxyEnabled |&#x3D; constraints.getRequiredNetworkType() !&#x3D; NOT_REQUIRED;</span><br><span class="line">&#x2F;&#x2F; 知道需要全部广播接收者，就不用判断了</span><br><span class="line">        if (batteryNotLowProxyEnabled &amp;&amp; batteryChargingProxyEnabled</span><br><span class="line">                &amp;&amp; storageNotLowProxyEnabled &amp;&amp; networkStateProxyEnabled) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Intent updateProxyIntent &#x3D;</span><br><span class="line">            ConstraintProxyUpdateReceiver.newConstraintProxyUpdateIntent(</span><br><span class="line">                    context,</span><br><span class="line">                    batteryNotLowProxyEnabled,</span><br><span class="line">                    batteryChargingProxyEnabled,</span><br><span class="line">                    storageNotLowProxyEnabled,</span><br><span class="line">                    networkStateProxyEnabled);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ConstraintProxies are being updated via a separate broadcast receiver.</span><br><span class="line">    &#x2F;&#x2F; For more information on why we do this look at b&#x2F;73549299</span><br><span class="line">    context.sendBroadcast(updateProxyIntent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里先是判断需要哪些广播接收者，会发送广播给ConstraintProxyUpdateReceiver，最终会调用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onReceive(@NonNull final Context context, @Nullable final Intent intent) &#123;</span><br><span class="line">    String action &#x3D; intent !&#x3D; null ? intent.getAction() : null;</span><br><span class="line">    if (!ACTION.equals(action)) &#123;</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        final PendingResult pendingResult &#x3D; goAsync();</span><br><span class="line">        WorkManagerImpl workManager &#x3D; WorkManagerImpl.getInstance(context);</span><br><span class="line">        TaskExecutor taskExecutor &#x3D; workManager.getWorkTaskExecutor();</span><br><span class="line">        taskExecutor.executeOnBackgroundThread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    &#x2F;&#x2F; 在后台线程上执行此操作，因为使用PackageManager来启用或禁用代理涉及到对文件系统的写操作。</span><br><span class="line">                    boolean batteryNotLowProxyEnabled &#x3D; intent.getBooleanExtra(</span><br><span class="line">                            KEY_BATTERY_NOT_LOW_PROXY_ENABLED, false);</span><br><span class="line">                    boolean batteryChargingProxyEnabled &#x3D; intent.getBooleanExtra(</span><br><span class="line">                            KEY_BATTERY_CHARGING_PROXY_ENABLED, false);</span><br><span class="line">                    boolean storageNotLowProxyEnabled &#x3D; intent.getBooleanExtra(</span><br><span class="line">                            KEY_STORAGE_NOT_LOW_PROXY_ENABLED, false);</span><br><span class="line">                    boolean networkStateProxyEnabled &#x3D; intent.getBooleanExtra(</span><br><span class="line">                            KEY_NETWORK_STATE_PROXY_ENABLED, false);</span><br><span class="line"></span><br><span class="line">                    Logger.get().debug(</span><br><span class="line">                            TAG,</span><br><span class="line">                            String.format(&quot;Updating proxies: BatteryNotLowProxy enabled (%s), &quot;</span><br><span class="line">                                            + &quot;BatteryChargingProxy enabled (%s), &quot;</span><br><span class="line">                                            + &quot;StorageNotLowProxy (%s), &quot;</span><br><span class="line">                                            + &quot;NetworkStateProxy enabled (%s)&quot;,</span><br><span class="line">                                    batteryNotLowProxyEnabled,</span><br><span class="line">                                    batteryChargingProxyEnabled,</span><br><span class="line">                                    storageNotLowProxyEnabled,</span><br><span class="line">                                    networkStateProxyEnabled));</span><br><span class="line"></span><br><span class="line">                    PackageManagerHelper.setComponentEnabled(context, BatteryNotLowProxy.class,</span><br><span class="line">                            batteryNotLowProxyEnabled);</span><br><span class="line">                    PackageManagerHelper.setComponentEnabled(context,</span><br><span class="line">                            BatteryChargingProxy.class,</span><br><span class="line">                            batteryChargingProxyEnabled);</span><br><span class="line">                    PackageManagerHelper.setComponentEnabled(context, StorageNotLowProxy.class,</span><br><span class="line">                            storageNotLowProxyEnabled);</span><br><span class="line">                    PackageManagerHelper.setComponentEnabled(context, NetworkStateProxy.class,</span><br><span class="line">                            networkStateProxyEnabled);</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    pendingResult.finish();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要执行了获取前文提供的需要哪些约束广播接收器，调用<code>PackageManagerHelper.setComponentEnabled(context, StorageNotLowProxy.class, storageNotLowProxyEnabled)</code>更改广播接收者注册信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 使用&#123;@link PackageManager&#125; 去开&#x2F;关manifest声明的组件</span><br><span class="line"> *</span><br><span class="line"> * @param context &#123;@link Context&#125;</span><br><span class="line"> * @param klazz The class of component</span><br><span class="line"> * @param enabled &#123;@code true&#125; 开关组件</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static void setComponentEnabled(</span><br><span class="line">        @NonNull Context context,</span><br><span class="line">        @NonNull Class&lt;?&gt; klazz,</span><br><span class="line">        boolean enabled) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        PackageManager packageManager &#x3D; context.getPackageManager();</span><br><span class="line">        ComponentName componentName &#x3D; new ComponentName(context, klazz.getName());</span><br><span class="line">        packageManager.setComponentEnabledSetting(componentName,</span><br><span class="line">                enabled</span><br><span class="line">                        ? PackageManager.COMPONENT_ENABLED_STATE_ENABLED</span><br><span class="line">                        : PackageManager.COMPONENT_ENABLED_STATE_DISABLED,</span><br><span class="line">                PackageManager.DONT_KILL_APP);</span><br><span class="line"></span><br><span class="line">    &#125; catch (Exception exception) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="RescheduleReceiver"><a href="#RescheduleReceiver" class="headerlink" title=" RescheduleReceiver"></a><span id="RescheduleReceiver"> RescheduleReceiver</h4><blockquote>
<p>Reschedules alarms on BOOT_COMPLETED and other similar scenarios.</p>
</blockquote>
<p>在BOOT_COMPLETED和其他类似场景下重新调度Alarm。</p>
<h4 id="DiagnosticsReceiver"><a href="#DiagnosticsReceiver" class="headerlink" title=" DiagnosticsReceiver"></a><span id="DiagnosticsReceiver"> DiagnosticsReceiver</h4><blockquote>
<p>The {@link android.content.BroadcastReceiver} which dumps out useful diagnostics information. 输出有用的诊断信息</p>
</blockquote>
]]></content>
      <categories>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>WorkManager</tag>
      </tags>
  </entry>
  <entry>
    <title>Jetpack之应用启动组件-StartUp</title>
    <url>/2021/02/24/Jetpack%E4%B9%8B%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E7%BB%84%E4%BB%B6-StartUp/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>应用程序启动库<code>StartUp</code>提供了一种在应用程序启动时初始化组件的简单、高效的方法。库开发者和应用开发者都可以使用app Startup来简化启动序列，并显式设置初始化顺序。</p>
</blockquote>
<blockquote>
<p>不同于为每个需要初始化的组件定义单独的内容提供程序，App Startup允许你定义共享单个内容提供程序的组件初始化程序。这可以显著提高应用程序的启动时间。</p>
</blockquote>
<p>此组件主要解决的痛点问题是：简化各个外部引用SDK初始化操作，并优化SDK初始化时机，在确保启动速度的情况下以更优更稳定的方式按需初始化SDK（当然，也可以利用它的按需按序执行的功能来初始化某些类）。</p>
<p><a href="https://github.com/TinloneX/ArchitecturalComponentExample">【本系列文章演示案例均存储在github存储库ArchitecturalComponentExample中】</a></p>
<a id="more"></a>

<h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><h4 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h4><p>在<code>app/build.gradle</code>文件的<code>dependencies</code>中加入以下内容：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">&quot;androidx.startup:startup-runtime:1.0.0&quot;</span></span><br></pre></td></tr></table></figure>
<p>若获取依赖包报错，请检查项目目录下<code>build.gradle</code>中是否包含以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="示例项目结构说明"><a href="#示例项目结构说明" class="headerlink" title="示例项目结构说明"></a>示例项目结构说明</h4><p><a href="https://github.com/TinloneX/ArchitecturalComponentExample/tree/main/StartUpExample/StartUpExampleJava">本项目Java版本地址</a></p>
<p><a href="https://github.com/TinloneX/ArchitecturalComponentExample/tree/main/StartUpExample/StartUpExampleKotlin">本项目Kotlin版本地址</a></p>
<p><a href="https://developer.android.google.cn/topic/libraries/app-startup">最简实践请参考官方开发文档</a></p>
<p>本项目示例主要结构如下：</p>
<p><a href="https://imgchr.com/i/yL3Fz9"><img src="https://s3.ax1x.com/2021/02/23/yL3Fz9.png" alt="yL3Fz9.png"></a></p>
<p>图中②部分代表用来初始化各个组件SDK的初始化器。</p>
<p>图中①部分代表模拟的需初始化的三方SDK，<strong>SDK之间存在”有向无环”的相互依赖关系</strong>，依赖关系如下：</p>
<p><a href="https://imgchr.com/i/yL8umq"><img src="https://s3.ax1x.com/2021/02/23/yL8umq.md.png" alt="yL8umq.md.png"></a></p>
<p>上述图中表述的依赖关系为：</p>
<ul>
<li>Cache 依赖于 DatabaseProxy 及 Logger</li>
<li>DatabaseProxy 依赖于 DatabaseHelper 及 Logger</li>
<li>DatabaseHelper 及 TXMap 均依赖于 Logger</li>
</ul>
<h4 id="创建初始化器"><a href="#创建初始化器" class="headerlink" title="创建初始化器"></a>创建初始化器</h4><blockquote>
<p>通过创建一个实现了初始化器接口的类来定义每个组件初始化器。这个接口定义了两个重要的方法:</p>
<ul>
<li>create()方法包含初始化组件所需的所有操作，并返回T的实例。</li>
<li>dependencies()方法，它返回初始化器所依赖的其他初始化器对象的列表。你可以使用这个方法来控制应用程序在启动时运行初始化器的顺序。</li>
</ul>
</blockquote>
<p>依照上述规则，我们来编写Logger的初始化类LoggerInitializer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggerInitializer</span> <span class="keyword">implements</span> <span class="title">Initializer</span>&lt;<span class="title">Logger</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Logger <span class="title">create</span><span class="params">(<span class="meta">@NonNull</span> Context context)</span> </span>&#123;</span><br><span class="line">        Log.i(<span class="string">&quot;loglog&quot;</span>, <span class="string">&quot;create: LoggerInitializer&quot;</span>);</span><br><span class="line">        Logger.initialize();</span><br><span class="line">        <span class="keyword">return</span> Logger.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Class&lt;? extends Initializer&lt;?&gt;&gt;&gt; dependencies() &#123;</span><br><span class="line">        <span class="comment">// 预示没有其他依赖需要初始化</span></span><br><span class="line">        <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>首先初始化器需要实现<code>Initializer<?></code>接口，并传入需初始化的对象的泛型，<em>思考如果不传或传入Void会怎样？</em></li>
<li>实现create方法，此方法中完成组件初始化，如有需要可返回实例</li>
<li>实现dependencies方法，此方法中声明当前初始化组件依赖于其他组件，并返回被依赖组件的初始化器，此处Logger未依赖其他组件，故返回空数组，<em>思考如果返回null会怎样？</em></li>
</ul>
<p>类似的，我们根据组件依赖关系依次定义出各个组件的初始化器，对比上述无依赖的Logger，我们再来看看多个依赖的DatabaseProxy的初始化器是如何定义的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatabaseProxyInitializer</span> <span class="keyword">implements</span> <span class="title">Initializer</span>&lt;<span class="title">DatabaseProxy</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DatabaseProxy <span class="title">create</span><span class="params">(<span class="meta">@NonNull</span> Context context)</span> </span>&#123;</span><br><span class="line">        Log.i(<span class="string">&quot;loglog&quot;</span>, <span class="string">&quot;create: DatabaseProxyInitializer&quot;</span>);</span><br><span class="line">        DatabaseProxy.initialize(DatabaseHelper.getInstance());</span><br><span class="line">        <span class="keyword">return</span> DatabaseProxy.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Class&lt;? extends Initializer&lt;?&gt;&gt;&gt; dependencies() &#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(LoggerInitializer.class, DatabaseHelperInitializer.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到在<code>dependencies</code>中声明了DatabaseProxy依赖于Logger和DatabaseHelper。</p>
<p>接下来，我们尝试一下上述的两个思考题。</p>
<ol>
<li>当Initializer&lt;?&gt;泛型传入Void会怎样？</li>
</ol>
<p>此场景类似于：当我们仅单纯的想执行某组件的初始化而没有返回实例的情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomethingInitializer</span> <span class="keyword">implements</span> <span class="title">Initializer</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Void <span class="title">create</span><span class="params">(<span class="meta">@NonNull</span> Context context)</span> </span>&#123;</span><br><span class="line">        Log.i(<span class="string">&quot;loglog&quot;</span>, <span class="string">&quot;create: SomethingInitializer&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Class&lt;? extends Initializer&lt;?&gt;&gt;&gt; dependencies() &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，我们让TXMap的初始化器去依赖这SomethingInitializer：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapInitializer</span> <span class="keyword">implements</span> <span class="title">Initializer</span>&lt;<span class="title">TXMap</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TXMap <span class="title">create</span><span class="params">(<span class="meta">@NonNull</span> Context context)</span> </span>&#123;</span><br><span class="line">        Log.i(<span class="string">&quot;loglog&quot;</span>, <span class="string">&quot;create: MapInitializer&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TXMap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Class&lt;? extends Initializer&lt;?&gt;&gt;&gt; dependencies() &#123;</span><br><span class="line">        <span class="comment">// map依赖了log，现在我们让它依赖Something</span></span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(LoggerInitializer.class, SomethingInitializer.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们看看其执行结果 <em>（当然，仅编写初始化器的代码仍不能正常工作，还未在AndroidManifest中声明初始化组件，此处我们暂只关注结果，下一节将介绍声明初始化组件）</em>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">I&#x2F;tag: create: LoggerInitializer</span><br><span class="line">I&#x2F;tag: Logger initialized</span><br><span class="line">I&#x2F;tag: create: SomethingInitializer</span><br><span class="line">I&#x2F;tag: create: MapInitializer</span><br><span class="line">I&#x2F;tag: Map initialized</span><br></pre></td></tr></table></figure>
<p>我们可以看到，其依旧正常按需执行了初始化操作，先调用了被TXMap依赖的Logger及Something的初始化器，最终完成Map的初始化。说明，Initializer&lt;?&gt;中有无传入泛型及传入Void泛型，其均可正常执行，正常适用于仅执行初始化操作，无返回实例的情景。</p>
<ol start="2">
<li>如果dependencies返回值为null会发生什么？</li>
</ol>
<p>我们将LoggerInitializer的依赖由<code>return Collections.emptyList()</code>修改为<code>return null</code>然后执行 <em>（仅编写初始化器的代码仍不能正常工作，还未在AndroidManifest中声明初始化组件，此处我们只关注结果，下一节将介绍声明初始化组件）</em>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 报错日志</span><br><span class="line">java.lang.RuntimeException: Unable to get provider androidx.startup.InitializationProvider:</span><br><span class="line">androidx.startup.StartupException:</span><br><span class="line">androidx.startup.StartupException:</span><br><span class="line">java.lang.NullPointerException: Attempt to invoke interface method &#39;boolean java.util.List.isEmpty()&#39; on a null object reference</span><br></pre></td></tr></table></figure>
<p>我们发现程序报错了，故dependencies返回值不能为null，至于原因将在原理篇中具体说明，记住此处【伏笔1】。</p>
<h4 id="注册初始化器提供者"><a href="#注册初始化器提供者" class="headerlink" title="注册初始化器提供者"></a>注册初始化器提供者</h4><p>上文提到，仅编写初始化器并不能完成组件初始化，显然的，我们没有配置其执行的时机。</p>
<blockquote>
<p>应用程序启动包括一个叫做InitializationProvider的特殊内容提供程序，它用来发现和调用你的组件初始化器。应用启动时通过首先检查InitializationProvider清单项下的项来发现组件初始化器。然后，App Startup为它已经发现的任何初始化器调用dependencies()方法。<br>这意味着，为了让组件初始化器在应用启动时被发现，必须满足以下条件之一:</p>
<ul>
<li>组件初始化器在InitializationProvider清单项下有一个对应的项。</li>
<li>组件初始化器在dependencies()方法中列出，它来自一个已经可以发现的初始化器。</li>
</ul>
</blockquote>
<p>此案例中，为了确保应用程序启动时可以发现这些初始化器，请将以下内容添加到清单文件中:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;provider</span><br><span class="line">    android:name&#x3D;&quot;androidx.startup.InitializationProvider&quot;</span><br><span class="line">    android:authorities&#x3D;&quot;$&#123;applicationId&#125;.androidx-startup&quot;</span><br><span class="line">    android:exported&#x3D;&quot;false&quot;</span><br><span class="line">    tools:node&#x3D;&quot;merge&quot;&gt;</span><br><span class="line">    &lt;!-- This entry makes ExampleLoggerInitializer discoverable. --&gt;</span><br><span class="line">    &lt;meta-data</span><br><span class="line">        android:name&#x3D;&quot;com.tinlone.startupexamplejava.initializers.CacheInitializer&quot;</span><br><span class="line">        android:value&#x3D;&quot;androidx.startup&quot; &#x2F;&gt;</span><br><span class="line">    &lt;meta-data</span><br><span class="line">        android:name&#x3D;&quot;com.tinlone.startupexamplejava.initializers.MapInitializer&quot;</span><br><span class="line">        android:value&#x3D;&quot;androidx.startup&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;provider&gt;</span><br></pre></td></tr></table></figure>
<p>上述代码将初始化器传递给初始化提供者。</p>
<p>若初始化链有多个，类似本示例中包含：</p>
<ul>
<li>Logger -&gt; TXMap</li>
<li>Logger -&gt; DatabaseHelper -&gt; DatabaseProxy</li>
</ul>
<p>以上两条独立的链，故此处为每条独立的链的链尾初始化器传递给InitializationProvider，为何要这样写呢？我们也将在源码篇中具体探讨，记住此处【伏笔2】.</p>
<h4 id="手动初始化组件"><a href="#手动初始化组件" class="headerlink" title="手动初始化组件"></a>手动初始化组件</h4><p>当然，如果你不想InitializationProvider自动初始化某些组件，你也可以手动调用初始化流程，此时你应该这样做：</p>
<ul>
<li>将不需要初始化的组件标记为<code>remove</code>:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;meta-data android:name&#x3D;&quot;com.example.ExampleLoggerInitializer&quot;</span><br><span class="line">          tools:node&#x3D;&quot;remove&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>在需要初始化的时机调用以下代码，以Logger为例：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AppInitializer.getInstance(context)</span><br><span class="line">    .initializeComponent(LoggerInitializer.class);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>您在条目中使用工具:node=”remove”，而不是简单地删除条目，以确保合并工具也从所有其他合并的清单文件中删除条目。</p>
</blockquote>
<blockquote>
<p>注意:禁用组件的自动初始化也会禁用该组件的依赖项的自动初始化。</p>
</blockquote>
<p>若你想完全禁止组件自动初始化，你可以将<code>InitializationProvider</code>组件声明为<code>remove</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;provider</span><br><span class="line">    android:name&#x3D;&quot;androidx.startup.InitializationProvider&quot;</span><br><span class="line">    android:authorities&#x3D;&quot;$&#123;applicationId&#125;.androidx-startup&quot;</span><br><span class="line">    tools:node&#x3D;&quot;remove&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p>并在需要初始化的时机调用以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AppInitializer.getInstance(context)</span><br><span class="line">    .initializeComponent(ExampleLoggerInitializer.class);</span><br></pre></td></tr></table></figure>
<h4 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h4><p>StartUp的使用仅需完成上述两个步骤即可，让我们来看一下器执行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">I&#x2F;loglog: create: LoggerInitializer</span><br><span class="line">I&#x2F;loglog: Logger initialized</span><br><span class="line">I&#x2F;loglog: create: SomethingInitializer</span><br><span class="line">I&#x2F;loglog: create: MapInitializer</span><br><span class="line">I&#x2F;loglog: Map initialized</span><br><span class="line">I&#x2F;loglog: create: DatabaseHelperInitializer</span><br><span class="line">I&#x2F;loglog: DatabaseHelper initialized</span><br><span class="line">I&#x2F;loglog: create: DatabaseProxyInitializer</span><br><span class="line">I&#x2F;loglog: DatabaseHelper initialized</span><br><span class="line">I&#x2F;loglog: DatabaseProxy initialized</span><br><span class="line">I&#x2F;loglog: create: CacheInitializer</span><br><span class="line">I&#x2F;loglog: Cache initialized</span><br></pre></td></tr></table></figure>
<p>我们在AndroidManifest中声明的是链尾的初始化器<code>CacheInitializer</code>及<code>MapInitializer</code>, 他却是从依赖链的头开始执行的初始化，他是如何做到完全符合依赖链顺序执行的呢？<br>让我们来简单看一下其原理。</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>上面使用篇中我们埋下了一些伏笔和问题：</p>
<ul>
<li>为什么dependencies返回值不能为null？</li>
<li>为什么要将每条独立的链的链尾初始化器传递给InitializationProvider？</li>
<li>他是如何做到完全符合依赖链顺序执行的？</li>
</ul>
<p>为解答这些问题，我们先从初始化的入口类<code>InitializationProvider</code>看起。</p>
<h4 id="InitializationProvider"><a href="#InitializationProvider" class="headerlink" title="InitializationProvider"></a>InitializationProvider</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestrictTo(RestrictTo.Scope.LIBRARY)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InitializationProvider</span> <span class="keyword">extends</span> <span class="title">ContentProvider</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Context context = getContext();</span><br><span class="line">        <span class="keyword">if</span> (context != <span class="keyword">null</span>) &#123;</span><br><span class="line">            AppInitializer.getInstance(context).discoverAndInitialize();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StartupException(<span class="string">&quot;Context cannot be null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// something else ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>InitializationProvider</code>内容相对简单，其作为内容提供者在初始化时调用了<code> AppInitializer.getInstance(context).discoverAndInitialize()</code>去扫描初始化器配置并执行后续操作。</p>
<h4 id="AppInitializer"><a href="#AppInitializer" class="headerlink" title="AppInitializer"></a>AppInitializer</h4><p>AppInitializer 维持了一个单例结构，主要包含两个重要方法<code>discoverAndInitialize</code>及<code>doInitialize</code>, 分别负责发现初始化器及执行初始化器，我们一一看来。</p>
<h5 id="discoverAndInitialize"><a href="#discoverAndInitialize" class="headerlink" title="discoverAndInitialize()"></a>discoverAndInitialize()</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">discoverAndInitialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Trace.beginSection(SECTION_NAME);</span><br><span class="line">        <span class="comment">// 创建组件标识符，获取InitializationProvider信息</span></span><br><span class="line">        ComponentName provider = <span class="keyword">new</span> ComponentName(mContext.getPackageName(),</span><br><span class="line">                InitializationProvider.class.getName());</span><br><span class="line">        <span class="comment">// 根据组件标识符从包管理器中取得组件，并获取组件元数据</span></span><br><span class="line">        ProviderInfo providerInfo = mContext.getPackageManager()</span><br><span class="line">                .getProviderInfo(provider, GET_META_DATA);</span><br><span class="line">        <span class="comment">// 取得元数据</span></span><br><span class="line">        Bundle metadata = providerInfo.metaData;</span><br><span class="line">        String startup = mContext.getString(R.string.androidx_startup);</span><br><span class="line">        <span class="keyword">if</span> (metadata != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Set&lt;Class&lt;?&gt;&gt; initializing = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            <span class="comment">// 取出元数据中 key的集合， 此处metadata的本质实为ArrayMap，参见&#123;@link Bundle#keySet&#125;</span></span><br><span class="line">            Set&lt;String&gt; keys = metadata.keySet();</span><br><span class="line">            <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">                String value = metadata.getString(key, <span class="keyword">null</span>);</span><br><span class="line">                <span class="comment">// 校验是否为androidx_startup元数据</span></span><br><span class="line">                <span class="keyword">if</span> (startup.equals(value)) &#123;</span><br><span class="line">                    <span class="comment">// 根据元数据key中的全类名生成字节码对象</span></span><br><span class="line">                    Class&lt;?&gt; clazz = Class.forName(key);</span><br><span class="line">                    <span class="comment">// 校验字节码对象是否是 Initializer 的实现类</span></span><br><span class="line">                    <span class="keyword">if</span> (Initializer.class.isAssignableFrom(clazz)) &#123;</span><br><span class="line">                        Class&lt;? extends Initializer&lt;?&gt;&gt; component =</span><br><span class="line">                                (Class&lt;? extends Initializer&lt;?&gt;&gt;) clazz;</span><br><span class="line">                        <span class="comment">// 加入Set备用</span></span><br><span class="line">                        mDiscovered.add(component);</span><br><span class="line">                        <span class="keyword">if</span> (StartupLogger.DEBUG) &#123;</span><br><span class="line">                            StartupLogger.i(String.format(<span class="string">&quot;Discovered %s&quot;</span>, key));</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 执行初始化</span></span><br><span class="line">                        doInitialize(component, initializing);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (PackageManager.NameNotFoundException | ClassNotFoundException exception) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StartupException(exception);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Trace.endSection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由代码可知，其主要做了以下事情：</p>
<ul>
<li>创建组件标识符，获取InitializationProvider信息</li>
<li>根据组件标识符从包管理器中取得组件，并获取组件元数据</li>
<li>取得元数据， 取出元数据中 key的集合</li>
<li>遍历元数据集合（ArrayMap）中的数据，校验是否为androidx_startup元数据</li>
<li>根据元数据key中的全类名生成字节码对象，校验字节码对象是否是 Initializer 的实现类</li>
<li>将Initializer 的实现类 字节码对象加入变量mDiscovered的Set中备用</li>
<li>执行初始化</li>
</ul>
<h5 id="doInitialize"><a href="#doInitialize" class="headerlink" title="doInitialize()"></a>doInitialize()</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; T doInitialize(</span><br><span class="line">        @NonNull Class&lt;? extends Initializer&lt;?&gt;&gt; component,</span><br><span class="line">        @NonNull Set&lt;Class&lt;?&gt;&gt; initializing) &#123;</span><br><span class="line">    synchronized (sLock) &#123;</span><br><span class="line">        boolean isTracingEnabled &#x3D; Trace.isEnabled();</span><br><span class="line">        try &#123;</span><br><span class="line">            if (isTracingEnabled) &#123;</span><br><span class="line">                &#x2F;&#x2F; 这里使用simpleName，因为否则节名会太大。</span><br><span class="line">                Trace.beginSection(component.getSimpleName());</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 保证初始化链无环，initializing为执行记录集合</span><br><span class="line">            &#x2F;&#x2F; 从discoverAndInitialize中传递的initializing值为空，故此判断不会执行</span><br><span class="line">            &#x2F;&#x2F; 从本函数递归执行传递的是已包含执行的初始化器，若此时初始化器有重复，说明相互依赖关系成环了，应抛错</span><br><span class="line">            if (initializing.contains(component)) &#123;</span><br><span class="line">                String message &#x3D; String.format(</span><br><span class="line">                        &quot;Cannot initialize %s. Cycle detected.&quot;, component.getName()</span><br><span class="line">                );</span><br><span class="line">                throw new IllegalStateException(message);</span><br><span class="line">            &#125;</span><br><span class="line">            Object result;</span><br><span class="line">            &#x2F;&#x2F; 若（被多次依赖且）已初始化则跳过</span><br><span class="line">            if (!mInitialized.containsKey(component)) &#123;</span><br><span class="line">                &#x2F;&#x2F; 将需要执行的初始化器字节码对象加入执行记录中</span><br><span class="line">                initializing.add(component);</span><br><span class="line">                try &#123;</span><br><span class="line">                    &#x2F;&#x2F; 获取初始化器实例</span><br><span class="line">                    Object instance &#x3D; component.getDeclaredConstructor().newInstance();</span><br><span class="line">                    Initializer&lt;?&gt; initializer &#x3D; (Initializer&lt;?&gt;) instance;</span><br><span class="line">                    &#x2F;&#x2F; 获取初始化器依赖关系</span><br><span class="line">                    List&lt;Class&lt;? extends Initializer&lt;?&gt;&gt;&gt; dependencies &#x3D;</span><br><span class="line">                            initializer.dependencies();</span><br><span class="line">                    &#x2F;&#x2F; 若此初始化器有相关依赖</span><br><span class="line">                    &#x2F;&#x2F; 是否记得【伏笔1】有提到为何dependencies不能返回null吗？</span><br><span class="line">                    &#x2F;&#x2F; 此处dependencies取得的值并未作空判断，故 null.isEmpty()会报空指针异常</span><br><span class="line">                    if (!dependencies.isEmpty()) &#123;</span><br><span class="line">                        &#x2F;&#x2F; 则遍历依赖，执行其初始化器，并传递初始化执行记录，防止依赖成环</span><br><span class="line">                        for (Class&lt;? extends Initializer&lt;?&gt;&gt; clazz : dependencies) &#123;</span><br><span class="line">                            if (!mInitialized.containsKey(clazz)) &#123;</span><br><span class="line">                                doInitialize(clazz, initializing);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (StartupLogger.DEBUG) &#123;</span><br><span class="line">                        StartupLogger.i(String.format(&quot;Initializing %s&quot;, component.getName()));</span><br><span class="line">                    &#125;</span><br><span class="line">                    result &#x3D; initializer.create(mContext);</span><br><span class="line">                    if (StartupLogger.DEBUG) &#123;</span><br><span class="line">                        StartupLogger.i(String.format(&quot;Initialized %s&quot;, component.getName()));</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F; 执行完毕，移除记录</span><br><span class="line">                    initializing.remove(component);</span><br><span class="line">                    &#x2F;&#x2F; 记录初始化完成</span><br><span class="line">                    mInitialized.put(component, result);</span><br><span class="line">                &#125; catch (Throwable throwable) &#123;</span><br><span class="line">                    throw new StartupException(throwable);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                result &#x3D; mInitialized.get(component);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F; 返回执行结果</span><br><span class="line">            return (T) result;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            Trace.endSection();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由代码可知，其主要做了以下事情：</p>
<ul>
<li>首先根据单链执行记录判断此链中是否有依赖关系成环，成环则抛错</li>
<li>根据初始换执行完成的记录判断（被多次依赖的）依赖是否已被初始化，已初始化则跳过</li>
<li>将需要执行的初始化器字节码对象加入执行记录中备用，用以判断依赖链中是否成环</li>
<li>调用 initializer.dependencies() 获取初始化器依赖关系</li>
<li>若此初始化器有其他依赖则遍历依赖递归调用 doInitialize() 执行至依赖链的链头的初始化</li>
<li>链执行完毕，则移除此链的执行记录</li>
<li>链执行完毕，将元数据中声明的初始化器加入至已完成集合中，用以避免重复初始化</li>
</ul>
<p>那么至此，我们似乎可以解释此节初始留下的三个伏笔问题了。</p>
<ol>
<li>为什么dependencies()返回值不能为null？</li>
</ol>
<p>答：因为在执行初始化前，会判断当前初始化器的dependencies是否为空，但此时使用的时 List.isEmpty() 并未对dependencies判空，故而，若dependencies()返回null，会导致null.isEmpty()的调用，导致空指针异常。</p>
<ol start="2">
<li>为什么要将每条独立的链的链尾初始化器传递给InitializationProvider？</li>
</ol>
<p>答：因为可以根据链尾的初始化器可以通过遍历递归dependencies()获取该链所有以来的初始化器，从而找到链首的初始化器，然后从头至尾折叠递归运算，同时也保证了依赖链顺序执行</p>
<ol start="3">
<li>他是如何做到完全符合依赖链顺序执行的？</li>
</ol>
<p>答同问题2</p>
]]></content>
      <categories>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>StartUp</tag>
      </tags>
  </entry>
</search>
