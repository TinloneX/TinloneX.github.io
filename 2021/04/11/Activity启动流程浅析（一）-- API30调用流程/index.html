<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-material.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"tinlone.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="前言Activity一般是安卓开发接触到的第一个重要组件，代表着与用户交互的活动视窗，活动与活动之间往往不是相互独立的，startActivity()就是从一个活动跳转到另一个活动的桥梁。而对于startActivity()的了解，我们往往只停留在它的使用上，很少去深究它的原理。 今天，就让我们跟随着源码，一步一步的追溯它的调用流程，初步了解下它的调用链，后续我们还可以继续挖掘，关于应用启动、启动">
<meta property="og:type" content="article">
<meta property="og:title" content="Activity启动流程浅析（一）-- 调用流程">
<meta property="og:url" content="http://tinlone.com/2021/04/11/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E6%B5%85%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89--%20API30%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B/index.html">
<meta property="og:site_name" content="Tinlone">
<meta property="og:description" content="前言Activity一般是安卓开发接触到的第一个重要组件，代表着与用户交互的活动视窗，活动与活动之间往往不是相互独立的，startActivity()就是从一个活动跳转到另一个活动的桥梁。而对于startActivity()的了解，我们往往只停留在它的使用上，很少去深究它的原理。 今天，就让我们跟随着源码，一步一步的追溯它的调用流程，初步了解下它的调用链，后续我们还可以继续挖掘，关于应用启动、启动">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://z3.ax1x.com/2021/04/11/cwgcp6.png">
<meta property="article:published_time" content="2021-04-11T10:05:00.592Z">
<meta property="article:modified_time" content="2021-04-11T10:04:40.301Z">
<meta property="article:author" content="Tinlone">
<meta property="article:tag" content="Activity">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://z3.ax1x.com/2021/04/11/cwgcp6.png">

<link rel="canonical" href="http://tinlone.com/2021/04/11/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E6%B5%85%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89--%20API30%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Activity启动流程浅析（一）-- 调用流程 | Tinlone</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Tinlone</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">堕落的🐟</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://tinlone.com/2021/04/11/Activity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E6%B5%85%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89--%20API30%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon-32x32-next.png">
      <meta itemprop="name" content="Tinlone">
      <meta itemprop="description" content="Tinlone的个人博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tinlone">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Activity启动流程浅析（一）-- 调用流程
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-04-11 18:05:00 / 修改时间：18:04:40" itemprop="dateCreated datePublished" datetime="2021-04-11T18:05:00+08:00">2021-04-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/framework/" itemprop="url" rel="index"><span itemprop="name">framework</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Activity一般是安卓开发接触到的第一个重要组件，代表着与用户交互的活动视窗，活动与活动之间往往不是相互独立的，<code>startActivity()</code>就是从一个活动跳转到另一个活动的桥梁。而对于<code>startActivity()</code>的了解，我们往往只停留在它的使用上，很少去深究它的原理<br>。</p>
<p>今天，就让我们跟随着源码，一步一步的追溯它的调用流程，初步了解下它的调用链，后续我们还可以继续挖掘，关于应用启动、启动模式、hook启动流程等相关技术支持。</p>
<p>此系列博客在未声明API版本情况下，将使用<strong>API30</strong> 版本的AndroidSDK源码。</p>
<p>源码查看工具使用AndroidStudio。源码来源<code>%AndroidSDK%/sources</code>。一般方式：备份一份source目录，使用AndroidStudio Open你想观察的api版本的源码目录。</p>
<a id="more"></a>

<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="Activity-startActivity"><a href="#Activity-startActivity" class="headerlink" title="Activity.startActivity()"></a>Activity.startActivity()</h4><p>我们日常编写的<code>activity.startActivity(intent)</code>的代码，实际是调用以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;@link android.app.Activity#startActivity&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.startActivity(intent, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Intent intent, <span class="meta">@Nullable</span> Bundle options)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// API 30 此处新增关于自动填充相关的处理代码，API26无此项</span></span><br><span class="line">    <span class="keyword">if</span> (options != <span class="keyword">null</span>) &#123;</span><br><span class="line">        startActivityForResult(intent, -<span class="number">1</span>, options);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Note we want to go through this call for compatibility with</span></span><br><span class="line">        <span class="comment">// applications that may have overridden the method.</span></span><br><span class="line">        startActivityForResult(intent, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Activity-startActivityForResult"><a href="#Activity-startActivityForResult" class="headerlink" title="Activity.startActivityForResult()"></a>Activity.startActivityForResult()</h4><p>有上述代码可知，startActivity() 实际是调用 startActivityForResult()：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#123;@link android.app.Activity#startActivityForResult&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivityForResult</span><span class="params">(<span class="meta">@RequiresPermission</span> Intent intent, <span class="keyword">int</span> requestCode,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@Nullable</span> Bundle options)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        options = transferSpringboardActivityOptions(options);</span><br><span class="line">        <span class="comment">// 注意此处，mMainThread.getApplicationThread() 实际为 IApplicationThread</span></span><br><span class="line">        Instrumentation.ActivityResult ar =</span><br><span class="line">            mInstrumentation.execStartActivity(</span><br><span class="line">                <span class="keyword">this</span>, mMainThread.getApplicationThread(), mToken, <span class="keyword">this</span>,</span><br><span class="line">                intent, requestCode, options);</span><br><span class="line">        <span class="keyword">if</span> (ar != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mMainThread.sendActivityResult(</span><br><span class="line">                mToken, mEmbeddedID, requestCode, ar.getResultCode(),</span><br><span class="line">                ar.getResultData());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (requestCode &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果这个start请求一个结果，我们可以在收到结果之前避免使活动可见。</span></span><br><span class="line">            <span class="comment">//在onCreate(Bundle savedInstanceState)或onResume()期间设置此代码将保持活动在此期间隐藏，以避免闪烁。</span></span><br><span class="line">            <span class="comment">//这只能在请求结果时执行，因为这保证了无论活动发生了什么，我们都会在活动完成时获得信息</span></span><br><span class="line">            mStartedActivity = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cancelInputsAndStartExitTransition(options);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 实际也是调用mInstrumentation.execStartActivity(this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options);此处不做赘述</span></span><br><span class="line">        <span class="keyword">if</span> (options != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mParent.startActivityFromChild(<span class="keyword">this</span>, intent, requestCode, options);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 注意，我们想要遍历这个方法，以便与可能已覆盖它的现有应用程序兼容。</span></span><br><span class="line">            mParent.startActivityFromChild(<span class="keyword">this</span>, intent, requestCode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处，我们抛开其他代码，关注这里的if else 最终都是调用mInstrumentation.execStartActivity()，从字面意义上说，它代表“执行启动活动”，显然我们应当关注此方法。</p>
<h4 id="Instrumentation-execStartActivity"><a href="#Instrumentation-execStartActivity" class="headerlink" title="Instrumentation.execStartActivity()"></a>Instrumentation.execStartActivity()</h4><p>Instrumentation类。此处我们不做详细分析，但应当知道的是，它的作用及能力：</p>
<blockquote>
<p>实现应用程序插装代码的基类。在启动插装的情况下运行时，这个类将在任何应用程序代码之前为您实例化，允许您监视系统与应用程序之间的所有交互。通过AndroidManifest.xml的&lt; Instrumentation &gt;标签向系统描述了一个Instrumentation实现。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;@link android.app.Instrumentation#execStartActivity&#125;</span><br><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ActivityResult <span class="title">execStartActivity</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Context who, IBinder contextThread, IBinder token, Activity target,</span></span></span><br><span class="line"><span class="function"><span class="params">        Intent intent, <span class="keyword">int</span> requestCode, Bundle options)</span> </span>&#123;</span><br><span class="line">    IApplicationThread whoThread = (IApplicationThread) contextThread;</span><br><span class="line">    <span class="comment">// 此处省略代码</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        intent.migrateExtraStreamToClipData(who);</span><br><span class="line">        intent.prepareToLeaveProcess(who);</span><br><span class="line">        <span class="comment">// 注意此处</span></span><br><span class="line">        <span class="keyword">int</span> result = ActivityTaskManager.getService().startActivity(whoThread,</span><br><span class="line">                who.getBasePackageName(), who.getAttributionTag(), intent,</span><br><span class="line">                intent.resolveTypeIfNeeded(who.getContentResolver()), token,</span><br><span class="line">                target != <span class="keyword">null</span> ? target.mEmbeddedID : <span class="keyword">null</span>, requestCode, <span class="number">0</span>, <span class="keyword">null</span>, options);</span><br><span class="line">        checkStartActivityResult(result, intent);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Failure from system&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，我们可以看到，Instrumentation.execStartActivity()调用了ActivityTaskManager.getService().startActivity()将启动活动委托给了某个“服务”执行，我们来看看这个“服务”是什么。</p>
<h4 id="ActivityTaskManager-getService"><a href="#ActivityTaskManager-getService" class="headerlink" title="ActivityTaskManager.getService()"></a>ActivityTaskManager.getService()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="meta">@link</span> android.app.ActivityTaskManager&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IActivityTaskManager <span class="title">getService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> IActivityTaskManagerSingleton.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@UnsupportedAppUsage(trackingBug = 129726065)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton&lt;IActivityTaskManager&gt; IActivityTaskManagerSingleton =</span><br><span class="line">        <span class="keyword">new</span> Singleton&lt;IActivityTaskManager&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> IActivityTaskManager <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">final</span> IBinder b = ServiceManager.getService(Context.ACTIVITY_TASK_SERVICE);</span><br><span class="line">                <span class="keyword">return</span> IActivityTaskManager.Stub.asInterface(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>
<p>这里代码的作用其实是通过获取IBinder类型的服务生产一个启动活动的代理类，实现方式： <strong>使用的是名为ACTIVITY_TASK_SERVICE的IBinder生产了一个IActivityTaskManager</strong>。</p>
<p>使用过AIDL的同学应该看出来了，这里类似的，也是通过跨进程通信的方式操作的。</p>
<h4 id="IActivityTaskManager-startActivity"><a href="#IActivityTaskManager-startActivity" class="headerlink" title="IActivityTaskManager.startActivity()"></a>IActivityTaskManager.startActivity()</h4><p>由于我们没办法直接获取到IActivityTaskManager的实现类，我们通过搜索<code>IActivityTaskManager.Stub</code>的实现类来寻找前面提到的“服务”具体是什么。</p>
<p><img src="https://z3.ax1x.com/2021/04/11/cwgcp6.png" alt="api30_IActivityTaskManager"></p>
<p>由上图可知，这个“服务”应该就是<code>com.android.server.wm.ActivityTaskManagerService</code>，我们找到startActivity()方法，验证其入参是否一致：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="meta">@link</span> com.android.server.wm.ActivityTaskManagerService&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivity</span><span class="params">(IApplicationThread caller, String callingPackage,</span></span></span><br><span class="line"><span class="function"><span class="params">        String callingFeatureId, Intent intent, String resolvedType, IBinder resultTo,</span></span></span><br><span class="line"><span class="function"><span class="params">        String resultWho, <span class="keyword">int</span> requestCode, <span class="keyword">int</span> startFlags, ProfilerInfo profilerInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">        Bundle bOptions)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> startActivityAsUser(caller, callingPackage, callingFeatureId, intent, resolvedType,</span><br><span class="line">            resultTo, resultWho, requestCode, startFlags, profilerInfo, bOptions,</span><br><span class="line">            UserHandle.getCallingUserId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过入参比对，基本确认此方法是Instrumentation.execStartActivity()中调用<code>ActivityTaskManager.getService().startActivity()</code>的后续流程了。</p>
<p><strong>ActivityTaskManagerService.startActivityAsUser</strong></p>
<p>startActivityAsUser包含一系列重载方法，最终都是执行以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="meta">@link</span> com.android.server.wm.ActivityTaskManagerService&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">startActivityAsUser</span><span class="params">(IApplicationThread caller, String callingPackage,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@Nullable</span> String callingFeatureId, Intent intent, String resolvedType,</span></span></span><br><span class="line"><span class="function"><span class="params">        IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode, <span class="keyword">int</span> startFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">        ProfilerInfo profilerInfo, Bundle bOptions, <span class="keyword">int</span> userId, <span class="keyword">boolean</span> validateIncomingUser)</span> </span>&#123;</span><br><span class="line">    assertPackageMatchesCallingUid(callingPackage);</span><br><span class="line">    enforceNotIsolatedCaller(<span class="string">&quot;startActivityAsUser&quot;</span>);</span><br><span class="line"></span><br><span class="line">    userId = getActivityStartController().checkTargetUser(userId, validateIncomingUser,</span><br><span class="line">            Binder.getCallingPid(), Binder.getCallingUid(), <span class="string">&quot;startActivityAsUser&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Switch to user app stacks here.</span></span><br><span class="line">    <span class="comment">// 注意这里的caller为 IApplicationThread</span></span><br><span class="line">    <span class="keyword">return</span> getActivityStartController().obtainStarter(intent, <span class="string">&quot;startActivityAsUser&quot;</span>)</span><br><span class="line">            .setCaller(caller)</span><br><span class="line">            .setCallingPackage(callingPackage)</span><br><span class="line">            .setCallingFeatureId(callingFeatureId)</span><br><span class="line">            .setResolvedType(resolvedType)</span><br><span class="line">            .setResultTo(resultTo)</span><br><span class="line">            .setResultWho(resultWho)</span><br><span class="line">            .setRequestCode(requestCode)</span><br><span class="line">            .setStartFlags(startFlags)</span><br><span class="line">            .setProfilerInfo(profilerInfo)</span><br><span class="line">            .setActivityOptions(bOptions)</span><br><span class="line">            .setUserId(userId)</span><br><span class="line">            .execute();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里主要通过工厂生产出ActivityStarter对象，并调用execute()执行。</p>
<h4 id="ActivityStarter-execute"><a href="#ActivityStarter-execute" class="headerlink" title="ActivityStarter.execute()"></a>ActivityStarter.execute()</h4><p>由该方法注释我们可知其作用：</p>
<blockquote>
<p>根据前面提供的请求参数解析必要的信息，并执行开始启动活动旅程的请求。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="meta">@link</span> com.android.server.wm.ActivityStarter&#125;</span><br><span class="line">&#123;<span class="meta">@link</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 此处省略代码</span></span><br><span class="line">        <span class="keyword">int</span> res;</span><br><span class="line">        <span class="keyword">synchronized</span> (mService.mGlobalLock) &#123;</span><br><span class="line">            <span class="comment">// 此处省略代码</span></span><br><span class="line">            res = executeRequest(mRequest);</span><br><span class="line"></span><br><span class="line">            Binder.restoreCallingIdentity(origId);</span><br><span class="line">            <span class="comment">// 此处省略代码</span></span><br><span class="line">            <span class="keyword">return</span> getExternalResult(mRequest.waitResult == <span class="keyword">null</span> ? res</span><br><span class="line">                    : waitForResult(res, mLastStartActivityRecord));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        onExecutionComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而这个方法的核心是调用<code>executeRequest(mRequest)</code>，由于代码较长，此处省略具体实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="meta">@link</span> com.android.server.wm.ActivityStarter&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">executeRequest</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略其他定义</span></span><br><span class="line">    <span class="keyword">final</span> IApplicationThread caller = request.caller;</span><br><span class="line">    <span class="keyword">final</span> IBinder resultTo = request.resultTo;</span><br><span class="line">    <span class="comment">// 省略其他检查代码</span></span><br><span class="line">    <span class="comment">// 检查权限等</span></span><br><span class="line">    <span class="keyword">boolean</span> abort = !mSupervisor.checkStartAnyActivityPermission(intent, aInfo, resultWho,</span><br><span class="line">        requestCode, callingPid, callingUid, callingPackage, callingFeatureId,</span><br><span class="line">        request.ignoreTargetSecurity, inTask != <span class="keyword">null</span>, callerApp, resultRecord, resultStack);</span><br><span class="line">    abort |= !mService.mIntentFirewall.checkStartActivity(intent, callingUid,</span><br><span class="line">            callingPid, resolvedType, aInfo.applicationInfo);</span><br><span class="line">    abort |= !mService.getPermissionPolicyInternal().checkStartActivity(intent, callingUid,</span><br><span class="line">            callingPackage);</span><br><span class="line">    <span class="comment">// 省略其他检查及设置状态代码</span></span><br><span class="line">    <span class="comment">// 创建ActivityRecord，注意此处callerApp为 对 IApplicationThread的封装</span></span><br><span class="line">    <span class="keyword">final</span> ActivityRecord r = <span class="keyword">new</span> ActivityRecord(mService, callerApp, callingPid, callingUid,</span><br><span class="line">            callingPackage, callingFeatureId, intent, resolvedType, aInfo,</span><br><span class="line">            mService.getGlobalConfiguration(), resultRecord, resultWho, requestCode,</span><br><span class="line">            request.componentSpecified, voiceSession != <span class="keyword">null</span>, mSupervisor, checkedOptions,</span><br><span class="line">            sourceRecord);</span><br><span class="line">    mLastStartActivityRecord = r;</span><br><span class="line">    <span class="comment">// 省略代码</span></span><br><span class="line">    mService.onStartActivitySetDidAppSwitch();</span><br><span class="line">    mController.doPendingActivityLaunches(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    mLastStartActivityResult = startActivityUnchecked(r, sourceRecord, voiceSession,</span><br><span class="line">            request.voiceInteractor, startFlags, <span class="keyword">true</span> <span class="comment">/* doResume */</span>, checkedOptions, inTask,</span><br><span class="line">            restrictedBgActivity, intentGrants);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (request.outActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">        request.outActivity[<span class="number">0</span>] = mLastStartActivityRecord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mLastStartActivityResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>executeRequest 做了基本的启动检查，创建包含IApplicationThread对象的Activity的表示类ActivityRecord（历史堆栈中的一个条目，表示一个活动），并最终调用 startActivityUnchecked() 方法，startActivityUnchecked()中主要调用 startActivityInner() 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="meta">@link</span> com.android.server.wm.ActivityStarter&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">startActivityInner</span><span class="params">(<span class="keyword">final</span> ActivityRecord r, ActivityRecord sourceRecord,</span></span></span><br><span class="line"><span class="function"><span class="params">        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> startFlags, <span class="keyword">boolean</span> doResume, ActivityOptions options, Task inTask,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> restrictedBgActivity, NeededUriGrants intentGrants)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略代码</span></span><br><span class="line">    <span class="comment">// 计算是否有一个现有的任务可用于加载Activity。</span></span><br><span class="line">    <span class="keyword">final</span> Task targetTask = reusedTask != <span class="keyword">null</span> ? reusedTask : computeTargetTask();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> newTask = targetTask == <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 省略以下代码：</span></span><br><span class="line">    <span class="comment">// 以下判断主要针对目标Activity</span></span><br><span class="line">    <span class="comment">// 判断是否正在栈顶</span></span><br><span class="line">    <span class="comment">// 判断并执行是否可以栈顶复用</span></span><br><span class="line">    <span class="comment">// 判断并执行是否需要开启新栈</span></span><br><span class="line">    <span class="comment">// 判断并执行是否移动到栈顶（singleTask弹栈）</span></span><br><span class="line">    <span class="comment">// =====</span></span><br><span class="line">    <span class="comment">// 操作目标Activity栈，启动模式、转场动画相关逻辑</span></span><br><span class="line">    mTargetStack.startActivityLocked(mStartActivity, topStack.getTopNonFinishingActivity(),</span><br><span class="line">                newTask, mKeepCurTransition, mOptions);</span><br><span class="line">    <span class="keyword">if</span> (mDoResume) &#123;</span><br><span class="line">        <span class="keyword">final</span> ActivityRecord topTaskActivity =</span><br><span class="line">                mStartActivity.getTask().topRunningActivityLocked();</span><br><span class="line">        <span class="keyword">if</span> (!mTargetStack.isTopActivityFocusable()</span><br><span class="line">                || (topTaskActivity != <span class="keyword">null</span> &amp;&amp; topTaskActivity.isTaskOverlay()</span><br><span class="line">                &amp;&amp; mStartActivity != topTaskActivity)) &#123;</span><br><span class="line">            <span class="comment">// 如果该活动是不可调焦的，我们不能恢复它，但仍然希望确保它在开始时可见(这也将触发进入动画)。</span></span><br><span class="line">            <span class="comment">// 这方面的一个例子是PIP活动。同样，我们不希望在一个任务中恢复当前有覆盖的活动，因为开始的活动只是需要在可见的暂停状态，直到覆盖被删除。</span></span><br><span class="line">            <span class="comment">// 传递&#123;@code null&#125;作为start参数可以确保所有活动都是可见的。</span></span><br><span class="line">            mTargetStack.ensureActivitiesVisible(<span class="keyword">null</span> <span class="comment">/* starting */</span>,</span><br><span class="line">                    <span class="number">0</span> <span class="comment">/* configChanges */</span>, !PRESERVE_WINDOWS);</span><br><span class="line">            <span class="comment">// 继续并告诉窗口管理器为这个活动执行应用程序过渡，因为应用程序过渡不会通过resume通道触发。</span></span><br><span class="line">            mTargetStack.getDisplay().mDisplayContent.executeAppTransition();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果目标堆栈之前不是可调焦的(该堆栈上之前的top运行活动不可见)，那么之前任何将该堆栈移动到该堆栈的调用都不会更新被调焦的堆栈。</span></span><br><span class="line">            <span class="comment">// 如果现在启动新的活动允许任务堆栈可调焦，那么请确保我们现在相应地更新已调焦的堆栈。</span></span><br><span class="line">            <span class="keyword">if</span> (mTargetStack.isTopActivityFocusable()</span><br><span class="line">                    &amp;&amp; !mRootWindowContainer.isTopDisplayFocusedStack(mTargetStack)) &#123;</span><br><span class="line">                mTargetStack.moveToFront(<span class="string">&quot;startActivityInner&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            mRootWindowContainer.resumeFocusedStacksTopActivities(</span><br><span class="line">                    mTargetStack, mStartActivity, mOptions);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     mRootWindowContainer.updateUserStack(mStartActivity.mUserId, mTargetStack);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当活动启动时，立即更新最近任务列表</span></span><br><span class="line">    mSupervisor.mRecentTasks.add(mStartActivity.getTask());</span><br><span class="line">    mSupervisor.handleNonResizableTaskIfNeeded(mStartActivity.getTask(),</span><br><span class="line">            mPreferredWindowingMode, mPreferredTaskDisplayArea, mTargetStack);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> START_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于这里代码较长，故忽略了大量代码，我们对这个方法的功能做一个简单的总结：</p>
<ul>
<li>根据当前栈的情况，判断目标Activity入栈操作：是否需要新栈，是否栈顶复用，是否弹栈等</li>
<li>转场动画相关操作</li>
<li>判断目标活动是否可获得焦点，执行对应操作</li>
</ul>
<p>那么，在判断目标活动是否可获得焦点的分支里，我们启动的activity自然是需要焦点（可见可操作）的，所以我们主要关注<code>mRootWindowContainer.resumeFocusedStacksTopActivities(mTargetStack, mStartActivity, mOptions);</code>.</p>
<h4 id="RootWindowContainer-resumeFocusedStacksTopActivities"><a href="#RootWindowContainer-resumeFocusedStacksTopActivities" class="headerlink" title="RootWindowContainer.resumeFocusedStacksTopActivities()"></a>RootWindowContainer.resumeFocusedStacksTopActivities()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="meta">@link</span> com.android.server.wm.RootWindowContainer&#125;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">resumeFocusedStacksTopActivities</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mStackSupervisor.readyToResume()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 如果目标在栈顶展示区域，则调用（状态模式）ResumeActivityItem执行resume操作</span></span><br><span class="line">    <span class="keyword">if</span> (targetStack != <span class="keyword">null</span> &amp;&amp; (targetStack.isTopStackInDisplayArea()</span><br><span class="line">            || getTopDisplayFocusedStack() == targetStack)) &#123;</span><br><span class="line">        result = targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> displayNdx = getChildCount() - <span class="number">1</span>; displayNdx &gt;= <span class="number">0</span>; --displayNdx) &#123;</span><br><span class="line">        <span class="comment">// 省略展示区域相关判断及计算</span></span><br><span class="line">        <span class="keyword">if</span> (!resumedOnDisplay) &#123;</span><br><span class="line">            <span class="comment">// 在没有有效活动的情况下(例如，设备刚刚启动或启动程序崩溃)，可能什么都没有恢复显示。</span></span><br><span class="line">            <span class="comment">// 显式地请求集中堆栈中的top活动的resume将确保至少home活动被启动和恢复，并且不会发生递归。</span></span><br><span class="line">            <span class="keyword">final</span> ActivityStack focusedStack = display.getFocusedStack();</span><br><span class="line">            <span class="keyword">if</span> (focusedStack != <span class="keyword">null</span>) &#123;</span><br><span class="line">                result |= focusedStack.resumeTopActivityUncheckedLocked(target, targetOptions);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (targetStack == <span class="keyword">null</span>) &#123;</span><br><span class="line">                result |= resumeHomeActivity(<span class="keyword">null</span> <span class="comment">/* prev */</span>, <span class="string">&quot;no-focusable-task&quot;</span>,</span><br><span class="line">                        display.getDefaultTaskDisplayArea());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>观察上述代码，主要做了以下事情：</p>
<ul>
<li>如果目标已展示在栈顶可见区域，则执行resume</li>
<li>如果不存在有效的活动（崩溃或首次启动），则启动首页</li>
<li>如果存在有效活动（存在有焦点的栈），继续执行启动流程</li>
</ul>
<p>此处，我们以存在有效活动为条件，继续关注启动流程，跟进resumeTopActivityUncheckedLocked()；</p>
<h4 id="ActivityStack-resumeTopActivityUncheckedLocked"><a href="#ActivityStack-resumeTopActivityUncheckedLocked" class="headerlink" title="ActivityStack.resumeTopActivityUncheckedLocked()"></a>ActivityStack.resumeTopActivityUncheckedLocked()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="meta">@link</span> com.android.server.wm.ActivityStack&#125;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">resumeTopActivityUncheckedLocked</span><span class="params">(ActivityRecord prev, ActivityOptions options)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mInResumeTopActivity) &#123;</span><br><span class="line">        <span class="comment">// （如果在栈顶可见）,甚至不要开始递归.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 防止递归。</span></span><br><span class="line">        mInResumeTopActivity = <span class="keyword">true</span>;</span><br><span class="line">        result = resumeTopActivityInnerLocked(prev, options);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当恢复top活动时，可能需要暂停top活动(例如，返回锁屏。</span></span><br><span class="line">        <span class="comment">// 我们在&#123;@link #resumeTopActivityUncheckedLocked&#125;中取消了正常的暂停逻辑，因为顶部活动在结束时恢复。我们在这里再次调用&#123;@link ActivityStackSupervisor# checkreadyforsleepplocked&#125;来确保任何必要的暂停逻辑发生。</span></span><br><span class="line">        <span class="comment">// 在不考虑锁屏的情况下，活动将被显示，对&#123;@link ActivityStackSupervisor# checkreadyforsleepplocked&#125;的调用被跳过。</span></span><br><span class="line">        <span class="keyword">final</span> ActivityRecord next = topRunningActivity(<span class="keyword">true</span> <span class="comment">/* focusableOnly */</span>);</span><br><span class="line">        <span class="keyword">if</span> (next == <span class="keyword">null</span> || !next.canTurnScreenOn()) &#123;</span><br><span class="line">            checkReadyForSleep();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mInResumeTopActivity = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>观察代码，这里主要做了防止递归调用的措施，以及调用了resumeTopActivityInnerLocked()方法，代码较长，此处将做忽略和拆解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="meta">@link</span> com.android.server.wm.ActivityStack&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">resumeTopActivityInnerLocked</span><span class="params">(ActivityRecord prev, ActivityOptions options)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 忽略部分判断</span></span><br><span class="line">    <span class="keyword">if</span> (!hasRunningActivity) &#123;</span><br><span class="line">        <span class="comment">// 栈里没有活动了，我们去别的地方看看。</span></span><br><span class="line">        <span class="comment">// 备注：注意，此处可能会出现递归调用，即会调用前面的流程：RootWindowContainer.resumeFocusedStacksTopActivities()</span></span><br><span class="line">        <span class="comment">// 这里也是前序流程中防范递归的原因</span></span><br><span class="line">        <span class="keyword">return</span> resumeNextFocusableActivityWhenStackIsEmpty(prev, options);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略大量代码</span></span><br><span class="line">    <span class="comment">// 执行栈中其他activity的pause操作</span></span><br><span class="line">    <span class="comment">// 我们正在启动下一个活动，因此告诉窗口管理器前一个活动将很快被隐藏。这样它就可以知道在计算所需的屏幕方向时忽略它。</span></span><br><span class="line">    <span class="keyword">if</span> (next.attachedToProcess()) &#123;</span><br><span class="line">    <span class="comment">// 更新进程信息</span></span><br><span class="line">    <span class="comment">// 检查特殊场景，例如半透明Activity等</span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 哎呀，需要重新启动这个Activity!</span></span><br><span class="line">        <span class="keyword">if</span> (!next.hasBeenLaunched) &#123;</span><br><span class="line">            next.hasBeenLaunched = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (SHOW_APP_STARTING_PREVIEW) &#123;</span><br><span class="line">                next.showStartingWindow(<span class="keyword">null</span> <span class="comment">/* prev */</span>, <span class="keyword">false</span> <span class="comment">/* newTask */</span>,</span><br><span class="line">                        <span class="keyword">false</span> <span class="comment">/* taskSwich */</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_SWITCH) Slog.v(TAG_SWITCH, <span class="string">&quot;Restarting: &quot;</span> + next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_STATES) Slog.d(TAG_STATES, <span class="string">&quot;resumeTopActivityLocked: Restarting &quot;</span> + next);</span><br><span class="line">        mStackSupervisor.startSpecificActivity(next, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码比较长，其中大部分的操作在上述代码的注释中有说明，此处不做过多关注，我们看到与startActivity()有关的代码为<code>mStackSupervisor.startSpecificActivity(next, true, true)</code>, 我们来看一下它的作用是什么。</p>
<h4 id="ActivityStackSupervisor-startSpecificActivity"><a href="#ActivityStackSupervisor-startSpecificActivity" class="headerlink" title="ActivityStackSupervisor.startSpecificActivity()"></a>ActivityStackSupervisor.startSpecificActivity()</h4><p>Supervisor ：主管。这个类字面意思是活动栈的主管，它的作用从注释中可以了解到：</p>
<blockquote>
<ul>
<li>将与层次结构相关的东西移动到RootWindowContainer</li>
<li>将与活动生命周期相关的东西移动到一个新的类ActivityLifeCycler中</li>
<li>移动接口事物到ActivityTaskManagerService。</li>
<li>所有其他的小事情到其他文件。</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">void startSpecificActivity(ActivityRecord r, boolean andResume, boolean checkConfig) &#123;</span><br><span class="line">    &#x2F;&#x2F; Is this activity&#39;s application already running?</span><br><span class="line">    &#x2F;&#x2F; 真是个糟糕的注释，让我想起了偶尔会遇到的一个报错  ┗|｀O′|┛</span><br><span class="line">    final WindowProcessController wpc &#x3D;</span><br><span class="line">            mService.getProcessController(r.processName, r.info.applicationInfo.uid);</span><br><span class="line"></span><br><span class="line">    boolean knownToBeDead &#x3D; false;</span><br><span class="line">    &#x2F;&#x2F; 如果applicationThread存在，则执行真实的启动Activity</span><br><span class="line">    if (wpc !&#x3D; null &amp;&amp; wpc.hasThread()) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            realStartActivityLocked(r, wpc, andResume, checkConfig);</span><br><span class="line">            return;</span><br><span class="line">        &#125; catch (RemoteException e) &#123;</span><br><span class="line">            Slog.w(TAG, &quot;Exception when starting activity &quot;</span><br><span class="line">                    + r.intent.getComponent().flattenToShortString(), e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 如果抛出了死对象异常——重新启动应用程序。</span><br><span class="line">        knownToBeDead &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r.notifyUnknownVisibilityLaunchedForKeyguardTransition();</span><br><span class="line"></span><br><span class="line">    final boolean isTop &#x3D; andResume &amp;&amp; r.isTopRunningActivity();</span><br><span class="line">    &#x2F;&#x2F; 若applicationThread不存在，将启动新的进程</span><br><span class="line">    mService.startProcessAsync(r, knownToBeDead, isTop, isTop ? &quot;top-activity&quot; : &quot;activity&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中，主要做了三次校验：</p>
<ul>
<li>若目标ApplicationThread对象存在，则继续执行启动流程</li>
<li>若启动流程执行失败，则重启应用程序</li>
<li>若目标ApplicationThread对象不存在，则启动新的进程；此流程暂不做关注，可自行跟进，最终会调用ActivityManagerService.startProcessLocked()及后续ZygoteProcess相关方法。</li>
</ul>
<h4 id="ActivityStackSupervisor-realStartActivityLocked"><a href="#ActivityStackSupervisor-realStartActivityLocked" class="headerlink" title="ActivityStackSupervisor.realStartActivityLocked()"></a>ActivityStackSupervisor.realStartActivityLocked()</h4><p>ActivityStackSupervisor.realStartActivityLocked()基本算得上启动流程中相当重要的一部分了，基本算得上是调用链的结束，后续将执行目标ActivityThread执行Launch操作，故单独做一小节讲述。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="meta">@link</span> com.android.server.wm.ActivityStackSupervisor&#125;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">realStartActivityLocked</span><span class="params">(ActivityRecord r, WindowProcessController proc,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> andResume, <span class="keyword">boolean</span> checkConfig)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mRootWindowContainer.allPausedActivitiesComplete()) &#123;</span><br><span class="line">        <span class="comment">// 当有活动暂停时，我们跳过开始任何新的活动，直到暂停完成。</span></span><br><span class="line">        <span class="comment">// 注意:对于在暂停状态下启动的活动，我们也会这样做，因为它们首先会被恢复，然后在客户端暂停。</span></span><br><span class="line">        <span class="comment">// 思考：那么，你会担心当此启动未成功吗？可还记得。我们启动流程其实包含递归操作，如果此次中断，不代表后续就不再执行启动操作了。</span></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_SWITCH || DEBUG_PAUSE || DEBUG_STATES) Slog.v(TAG_PAUSE,</span><br><span class="line">                <span class="string">&quot;realStartActivityLocked: Skipping start of r=&quot;</span> + r</span><br><span class="line">                + <span class="string">&quot; some activities pausing...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略大量代码    </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 因为我们可能会在系统进程中启动一个活动，所以这可能不会跨越创建新配置的绑定器接口。因此，我们必须总是在这里创建一个新的配置。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> MergedConfiguration mergedConfiguration = <span class="keyword">new</span> MergedConfiguration(</span><br><span class="line">            proc.getConfiguration(), r.getMergedOverrideConfiguration());</span><br><span class="line">    r.setLastReportedConfiguration(mergedConfiguration);</span><br><span class="line"></span><br><span class="line">    logIfTransactionTooLarge(r.intent, r.getSavedState());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建活动启动事务。</span></span><br><span class="line">    <span class="keyword">final</span> ClientTransaction clientTransaction = ClientTransaction.obtain(</span><br><span class="line">            proc.getThread(), r.appToken);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> DisplayContent dc = r.getDisplay().mDisplayContent;</span><br><span class="line">    clientTransaction.addCallback(LaunchActivityItem.obtain(<span class="keyword">new</span> Intent(r.intent),</span><br><span class="line">            System.identityHashCode(r), r.info,</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> Have this take the merged configuration instead of separate global</span></span><br><span class="line">            <span class="comment">// and override configs.</span></span><br><span class="line">            mergedConfiguration.getGlobalConfiguration(),</span><br><span class="line">            mergedConfiguration.getOverrideConfiguration(), r.compat,</span><br><span class="line">            r.launchedFromPackage, task.voiceInteractor, proc.getReportedProcState(),</span><br><span class="line">            r.getSavedState(), r.getPersistentSavedState(), results, newIntents,</span><br><span class="line">            dc.isNextTransitionForward(), proc.createProfilerInfoIfNeeded(),</span><br><span class="line">            r.assistToken, r.createFixedRotationAdjustmentsIfNeeded()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set desired final state.</span></span><br><span class="line">    <span class="keyword">final</span> ActivityLifecycleItem lifecycleItem;</span><br><span class="line">    <span class="keyword">if</span> (andResume) &#123;</span><br><span class="line">        lifecycleItem = ResumeActivityItem.obtain(dc.isNextTransitionForward());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        lifecycleItem = PauseActivityItem.obtain();</span><br><span class="line">    &#125;</span><br><span class="line">    clientTransaction.setLifecycleStateRequest(lifecycleItem);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Schedule transaction.</span></span><br><span class="line">    mService.getLifecycleManager().scheduleTransaction(clientTransaction);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 再次省略大量代码</span></span><br><span class="line">    <span class="comment">// 设置活动状态后，执行OOM评分，使流程可以更新为最新状态。    </span></span><br><span class="line">    proc.onStartActivity(mService.mTopProcessState, r.info);</span><br><span class="line">    <span class="comment">//如果需要，启动新版本设置屏幕。我们在启动初始化的activity(即home)之后做这个操作，这样它就有机会在后台初始化自己，使切换回它更快，看起来更好。</span></span><br><span class="line">    <span class="keyword">if</span> (mRootWindowContainer.isTopDisplayFocusedStack(stack)) &#123;</span><br><span class="line">        mService.getActivityStartController().startSetupActivity();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新我们绑定到的任何可能关心其客户端是否有活动的服务。</span></span><br><span class="line">    <span class="keyword">if</span> (r.app != <span class="keyword">null</span>) &#123;</span><br><span class="line">        r.app.updateServiceConnectionActivities();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上述代码及注释我们可知，realStartActivityLocked的主要功能是：</p>
<ul>
<li>若有正在pause的活动，等待它操作完毕</li>
<li>创建 LaunchActivityItem （启动Activity的策略/状态）并封装成事务</li>
<li>执行启动Activity的事务</li>
<li>更新进程信息及其他相关服务</li>
</ul>
<p>那么，我们知道activity启动流程的最后两步即是：创建 LaunchActivityItem 及执行 ClientTransaction，这里我们分两各部分介绍，先介绍 ClientTransaction 的调用流程，再介绍 LaunchActivityItem 是什么。</p>
<h4 id="执行LaunchActivityItem事务"><a href="#执行LaunchActivityItem事务" class="headerlink" title="执行LaunchActivityItem事务"></a>执行LaunchActivityItem事务</h4><p>ActivityStackSupervisor.realStartActivityLocked()中调用的<code>mService.getLifecycleManager().scheduleTransaction(clientTransaction);</code>实际是ClientLifecycleManager.scheduleTransaction()：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="meta">@link</span> com.android.server.wm.ClientLifecycleManager&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTransaction</span><span class="params">(ClientTransaction transaction)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> IApplicationThread client = transaction.getClient();</span><br><span class="line">    transaction.schedule();</span><br><span class="line">    <span class="keyword">if</span> (!(client <span class="keyword">instanceof</span> Binder)) &#123;</span><br><span class="line">        <span class="comment">// 如果client不是Binder的实例——它是一个远程调用，此时可以安全地回收对象。</span></span><br><span class="line">        <span class="comment">// 在ActivityThread的客户端上执行事务后，用于本地调用的所有对象都将被回收。</span></span><br><span class="line">        transaction.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里主要调用了<code>ClientTransaction.schedule()</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="meta">@link</span> android.app.servertransaction.ClientTransaction&#125;</span><br><span class="line"><span class="comment">/** Target client. */</span></span><br><span class="line"><span class="keyword">private</span> IApplicationThread mClient;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">schedule</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    mClient.scheduleTransaction(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由代码可知，这里调用了IApplicationThread.scheduleTransaction()。这里的IApplicationThread来源于ClientTransaction.obtain()入参，向前追溯则是通过ActivityRecorder获取的，实际是前述启动流程中传递的caller【此处描述可能不够严谨，如有错误请评论或联系作者】。</p>
<p>这里我们首先应该找到 IApplicationThread的实现，如果你对ActivityThread有一定了解的话，可以知道其内部类 ApplicationThread 实现了 IApplicationThread.Stub：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&#123;@link android.app.ActivityThread&#125;</span><br><span class="line"></span><br><span class="line">public final class ActivityThread extends ClientTransactionHandler &#123;</span><br><span class="line"></span><br><span class="line">    private class ApplicationThread extends IApplicationThread.Stub &#123;</span><br><span class="line">        &#x2F;&#x2F; 忽略其他代码</span><br><span class="line">        @Override</span><br><span class="line">        public void scheduleTransaction(ClientTransaction transaction) throws RemoteException &#123;</span><br><span class="line">            ActivityThread.this.scheduleTransaction(transaction);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public abstract class ClientTransactionHandler &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Schedule phase related logic and handlers.</span><br><span class="line"></span><br><span class="line">    &#x2F;** Prepare and schedule transaction for execution. *&#x2F;</span><br><span class="line">    void scheduleTransaction(ClientTransaction transaction) &#123;</span><br><span class="line">        transaction.preExecute(this);</span><br><span class="line">        sendMessage(ActivityThread.H.EXECUTE_TRANSACTION, transaction);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  class H extends Handler &#123;</span><br><span class="line">      </span><br><span class="line">      public void handleMessage(Message msg) &#123;</span><br><span class="line">            switch (msg.what) &#123;</span><br><span class="line">                case EXECUTE_TRANSACTION:</span><br><span class="line">                    final ClientTransaction transaction &#x3D; (ClientTransaction) msg.obj;</span><br><span class="line">                    mTransactionExecutor.execute(transaction);</span><br><span class="line">                    if (isSystem()) &#123;</span><br><span class="line">                        &#x2F;&#x2F; 系统进程内部的客户端事务在客户端循环，而不是在ClientLifecycleManager中循环，以避免在此消息被处理之前被清除。</span><br><span class="line">                        transaction.recycle();</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F; TODO(lifecycler): Recycle locally scheduled transactions.</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>那么，调用IApplicationThread.scheduleTransaction()，实际上是向ActivityThread.H发送了Message，而后ActivityThread.H处理消息并调用了<code>mTransactionExecutor.execute(transaction)</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="meta">@link</span> android.app.servertransaction.TransactionExecutor&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 忽略代码</span></span><br><span class="line"></span><br><span class="line">    executeCallbacks(transaction);</span><br><span class="line"></span><br><span class="line">    executeLifecycleState(transaction);</span><br><span class="line">    mPendingActions.clear();</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_RESOLVER) Slog.d(TAG, tId(transaction) + <span class="string">&quot;End resolving transaction&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cycle through all states requested by callbacks and execute them at proper times. */</span></span><br><span class="line"><span class="meta">@VisibleForTesting</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeCallbacks</span><span class="params">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 忽略代码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> size = callbacks.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        <span class="keyword">final</span> ClientTransactionItem item = callbacks.get(i);</span><br><span class="line">        <span class="comment">// 忽略代码</span></span><br><span class="line"></span><br><span class="line">        item.execute(mTransactionHandler, token, mPendingActions);</span><br><span class="line">        item.postExecute(mTransactionHandler, token, mPendingActions);</span><br><span class="line">        <span class="comment">// 忽略代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TransactionExecutor.execute()及后续executeCallbacks()最终调用到了 BaseClientRequest.execute()，也就是LaunchActivityItem.execute()。</p>
<h4 id="LaunchActivityItem"><a href="#LaunchActivityItem" class="headerlink" title="LaunchActivityItem"></a>LaunchActivityItem</h4><p>在Android API 29及以上SDK中，Google将可以调度和执行的到客户端的回调消息封装为事务，包含Launch、Start、Stop等各种状态。</p>
<p>继承自 ClientTransactionItem 及上层 BaseClientRequest，核心方法为execute(ClientTransactionHandler client, IBinder token, PendingTransactionActions pendingActions)，已知的ClientTransactionHandler 有ActivityThread。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="meta">@link</span> android.app.servertransaction.LaunchActivityItem&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(ClientTransactionHandler client, IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">        PendingTransactionActions pendingActions)</span> </span>&#123;</span><br><span class="line">    Trace.traceBegin(TRACE_TAG_ACTIVITY_MANAGER, <span class="string">&quot;activityStart&quot;</span>);</span><br><span class="line">    ActivityClientRecord r = <span class="keyword">new</span> ActivityClientRecord(token, mIntent, mIdent, mInfo,</span><br><span class="line">            mOverrideConfig, mCompatInfo, mReferrer, mVoiceInteractor, mState, mPersistentState,</span><br><span class="line">            mPendingResults, mPendingNewIntents, mIsForward,</span><br><span class="line">            mProfilerInfo, client, mAssistToken, mFixedRotationAdjustments);</span><br><span class="line">    client.handleLaunchActivity(r, pendingActions, <span class="keyword">null</span> <span class="comment">/* customIntent */</span>);</span><br><span class="line">    Trace.traceEnd(TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LaunchActivityItem.execute()中主要调用了<code>client.handleLaunchActivity(r, pendingActions, null /* customIntent */)</code>，也就是调用了ActivityThread的相关方法。</p>
<p>当然的ActivityThread.handleLaunchActivity() 就是实际的新的Activity从创建到展示的流程了。</p>
<p>至此，其实整个从 startActivity的调用到目标Activity创建的调用流程就已经分析完毕了。</p>
<p>最后，我们来画一画整个流程的时序图。</p>
<p>【时序图还在画，观众老爷请稍候】</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Activity/" rel="tag"># Activity</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/04/04/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/" rel="prev" title="性能优化之内存优化">
      <i class="fa fa-chevron-left"></i> 性能优化之内存优化
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">2.</span> <span class="nav-text">源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Activity-startActivity"><span class="nav-number">2.1.</span> <span class="nav-text">Activity.startActivity()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Activity-startActivityForResult"><span class="nav-number">2.2.</span> <span class="nav-text">Activity.startActivityForResult()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Instrumentation-execStartActivity"><span class="nav-number">2.3.</span> <span class="nav-text">Instrumentation.execStartActivity()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ActivityTaskManager-getService"><span class="nav-number">2.4.</span> <span class="nav-text">ActivityTaskManager.getService()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IActivityTaskManager-startActivity"><span class="nav-number">2.5.</span> <span class="nav-text">IActivityTaskManager.startActivity()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ActivityStarter-execute"><span class="nav-number">2.6.</span> <span class="nav-text">ActivityStarter.execute()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RootWindowContainer-resumeFocusedStacksTopActivities"><span class="nav-number">2.7.</span> <span class="nav-text">RootWindowContainer.resumeFocusedStacksTopActivities()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ActivityStack-resumeTopActivityUncheckedLocked"><span class="nav-number">2.8.</span> <span class="nav-text">ActivityStack.resumeTopActivityUncheckedLocked()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ActivityStackSupervisor-startSpecificActivity"><span class="nav-number">2.9.</span> <span class="nav-text">ActivityStackSupervisor.startSpecificActivity()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ActivityStackSupervisor-realStartActivityLocked"><span class="nav-number">2.10.</span> <span class="nav-text">ActivityStackSupervisor.realStartActivityLocked()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%89%A7%E8%A1%8CLaunchActivityItem%E4%BA%8B%E5%8A%A1"><span class="nav-number">2.11.</span> <span class="nav-text">执行LaunchActivityItem事务</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LaunchActivityItem"><span class="nav-number">2.12.</span> <span class="nav-text">LaunchActivityItem</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Tinlone"
      src="/images/favicon-32x32-next.png">
  <p class="site-author-name" itemprop="name">Tinlone</p>
  <div class="site-description" itemprop="description">Tinlone的个人博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
	
	<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=16435049&auto=1&height=66"></iframe>
	
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Tinlone</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">53k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">48 分钟</span>
</div>
<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
